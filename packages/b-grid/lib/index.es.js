import { reactive as Rt, inject as mt, computed as _, provide as bn, createCommentVNode as Ve, watch as lt, h as o, defineComponent as pt, ref as ke, onMounted as wn, onUnmounted as $n, nextTick as me, onBeforeUnmount as Us, TransitionGroup as Fr, Teleport as ks, onActivated as Cm, onDeactivated as gb, resolveComponent as qo, useSlots as hb, useAttrs as vb, openBlock as bb, createBlock as xb, unref as yb, mergeProps as Cb, toHandlers as wb, createSlots as Eb, withCtx as cu, createElementVNode as uu, normalizeClass as Sb, renderSlot as ci, renderList as Ld, normalizeProps as Db, guardReactiveProps as Ob, createApp as Tb } from "vue";
const Mb = "4.0.20", ll = {
  coreVersion: Mb,
  uiVersion: "",
  tableVersion: ""
};
function Ib(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Vb = {
  cookies: {
    path: "/"
  },
  treeOptions: {
    parentKey: "parentId",
    key: "id",
    children: "children"
  },
  parseDateFormat: "yyyy-MM-dd HH:mm:ss",
  firstDayOfWeek: 1
}, pr = Vb;
function Pb(e, t, n) {
  if (e)
    if (e.forEach)
      e.forEach(t, n);
    else
      for (var s = 0, i = e.length; s < i; s++)
        t.call(n, e[s], s, e);
}
var Qo = Pb, kb = Object.prototype.toString, wm = kb, $b = wm;
function Rb(e) {
  return function(t) {
    return "[object " + e + "]" === $b.call(t);
  };
}
var _i = Rb, Nb = _i, Fb = Array.isArray || Nb("Array"), Gn = Fb;
function Lb(e, t) {
  return e && e.hasOwnProperty ? e.hasOwnProperty(t) : !1;
}
var $s = Lb, Ab = $s;
function Bb(e, t, n) {
  if (e)
    for (var s in e)
      Ab(e, s) && t.call(n, e[s], s, e);
}
var Wi = Bb, _b = Gn, Wb = Qo, zb = Wi;
function Hb(e, t, n) {
  return e && (_b(e) ? Wb : zb)(e, t, n);
}
var xo = Hb;
function jb(e) {
  return function(t) {
    return typeof t === e;
  };
}
var Gl = jb, qb = Gl, Ub = qb("function"), fs = Ub, Gb = xo;
function Kb(e, t) {
  var n = Object[e];
  return function(s) {
    var i = [];
    if (s) {
      if (n)
        return n(s);
      Gb(s, t > 1 ? function(l) {
        i.push(["" + l, s[l]]);
      } : function() {
        i.push(arguments[t]);
      });
    }
    return i;
  };
}
var rd = Kb, Yb = rd, Xb = Yb("keys", 1), mr = Xb, Zb = wm, Jb = Wi, Qb = Qo;
function du(e, t) {
  var n = e.__proto__.constructor;
  return t ? new n(t) : new n();
}
function ca(e, t) {
  return t ? Em(e, t) : e;
}
function Em(e, t) {
  if (e)
    switch (Zb.call(e)) {
      case "[object Object]": {
        var n = Object.create(Object.getPrototypeOf(e));
        return Jb(e, function(a, c) {
          n[c] = ca(a, t);
        }), n;
      }
      case "[object Date]":
      case "[object RegExp]":
        return du(e, e.valueOf());
      case "[object Array]":
      case "[object Arguments]": {
        var s = [];
        return Qb(e, function(a) {
          s.push(ca(a, t));
        }), s;
      }
      case "[object Set]": {
        var i = du(e);
        return i.forEach(function(a) {
          i.add(ca(a, t));
        }), i;
      }
      case "[object Map]": {
        var l = du(e);
        return l.forEach(function(a, c) {
          l.set(c, ca(a, t));
        }), l;
      }
    }
  return e;
}
function ex(e, t) {
  return e && Em(e, t);
}
var ld = ex, tx = Qo, nx = mr, ox = Gn, sx = ld, Ad = Object.assign;
function Bd(e, t, n) {
  for (var s = t.length, i, l = 1; l < s; l++)
    i = t[l], tx(nx(t[l]), n ? function(a) {
      e[a] = sx(i[a], n);
    } : function(a) {
      e[a] = i[a];
    });
  return e;
}
var rx = function(e) {
  if (e) {
    var t = arguments;
    if (e === !0) {
      if (t.length > 1)
        return e = ox(e[1]) ? [] : {}, Bd(e, t, !0);
    } else
      return Ad ? Ad.apply(Object, t) : Bd(e, t);
  }
  return e;
}, Rs = rx, lx = pr, ix = Qo, ax = xo, cx = fs, ux = Rs, Qr = function() {
};
function dx() {
  ix(arguments, function(e) {
    ax(e, function(t, n) {
      Qr[n] = cx(t) ? function() {
        var s = t.apply(Qr.$context, arguments);
        return Qr.$context = null, s;
      } : t;
    });
  });
}
function fx(e) {
  return ux(lx, e);
}
Qr.VERSION = "3.5.32";
Qr.mixin = dx;
Qr.setup = fx;
var px = Qr;
function mx(e, t, n) {
  for (var s = e.length - 1; s >= 0; s--)
    t.call(n, e[s], s, e);
}
var id = mx, gx = id, hx = mr;
function vx(e, t, n) {
  gx(hx(e), function(s) {
    t.call(n, e[s], s, e);
  });
}
var Sm = vx;
function bx(e) {
  return e === null;
}
var gr = bx, xx = gr;
function yx(e, t) {
  return function(n) {
    return xx(n) ? t : n[e];
  };
}
var Kl = yx, Cx = xo, wx = fs, Ex = Kl;
function Sx(e, t, n) {
  var s = {};
  if (e)
    if (t)
      wx(t) || (t = Ex(t)), Cx(e, function(i, l) {
        s[l] = t.call(n, i, l, e);
      });
    else
      return e;
  return s;
}
var Dx = Sx;
function Ox(e) {
  return e ? e.constructor === Object : !1;
}
var Yl = Ox, _d = Gn, Wd = Yl, Tx = xo;
function Dm(e, t) {
  return Wd(e) && Wd(t) || _d(e) && _d(t) ? (Tx(t, function(n, s) {
    e[s] = Dm(e[s], n);
  }), e) : t;
}
var Mx = function(e) {
  e || (e = {});
  for (var t = arguments, n = t.length, s, i = 1; i < n; i++)
    s = t[i], s && Dm(e, s);
  return e;
}, Ix = Mx, Vx = xo;
function Px(e, t, n) {
  var s = [];
  if (e && arguments.length > 1) {
    if (e.map)
      return e.map(t, n);
    Vx(e, function() {
      s.push(t.apply(n, arguments));
    });
  }
  return s;
}
var Xl = Px, kx = $s, $x = Gn;
function Rx(e, t, n, s, i) {
  return function(l, a, c) {
    if (l && a) {
      if (e && l[e])
        return l[e](a, c);
      if (t && $x(l)) {
        for (var m = 0, u = l.length; m < u; m++)
          if (!!a.call(c, l[m], m, l) === s)
            return [!0, !1, m, l[m]][n];
      } else
        for (var d in l)
          if (kx(l, d) && !!a.call(c, l[d], d, l) === s)
            return [!0, !1, d, l[d]][n];
    }
    return i;
  };
}
var $c = Rx, Nx = $c, Fx = Nx("some", 1, 0, !0, !1), Om = Fx, Lx = $c, Ax = Lx("every", 1, 1, !1, !0), Tm = Ax, Bx = $s;
function _x(e, t) {
  if (e) {
    if (e.includes)
      return e.includes(t);
    for (var n in e)
      if (Bx(e, n) && t === e[n])
        return !0;
  }
  return !1;
}
var zi = _x, zd = Gn, Hd = zi;
function Wx(e, t) {
  var n, s = 0;
  if (zd(e) && zd(t)) {
    for (n = t.length; s < n; s++)
      if (!Hd(e, t[s]))
        return !1;
    return !0;
  }
  return Hd(e, t);
}
var Mm = Wx, jd = xo, zx = zi, Hx = fs, jx = Kl;
function qx(e, t, n) {
  var s = [];
  if (t) {
    Hx(t) || (t = jx(t));
    var i, l = {};
    jd(e, function(a, c) {
      i = t.call(n, a, c, e), l[i] || (l[i] = 1, s.push(a));
    });
  } else
    jd(e, function(a) {
      zx(s, a) || s.push(a);
    });
  return s;
}
var Im = qx, Ux = Xl;
function Gx(e) {
  return Ux(e, function(t) {
    return t;
  });
}
var ad = Gx, Kx = Im, Yx = ad;
function Xx() {
  for (var e = arguments, t = [], n = 0, s = e.length; n < s; n++)
    t = t.concat(Yx(e[n]));
  return Kx(t);
}
var Zx = Xx, Jx = "undefined", Ns = Jx, Qx = Ns, ey = Gl, ty = ey(Qx), Gs = ty, ny = gr, oy = Gs;
function sy(e) {
  return ny(e) || oy(e);
}
var Br = sy, ry = /(.+)?\[(\d+)\]$/, Vm = ry;
function ly(e) {
  return e ? e.splice && e.join ? e : ("" + e).replace(/(\[\d+\])\.?/g, "$1.").replace(/\.$/, "").split(".") : [];
}
var cd = ly, iy = Vm, ay = cd, cy = $s, uy = Gs, Pm = Br;
function dy(e, t, n) {
  if (Pm(e))
    return n;
  var s = py(e, t);
  return uy(s) ? n : s;
}
function fy(e, t) {
  var n = t ? t.match(iy) : "";
  return n ? n[1] ? e[n[1]] ? e[n[1]][n[2]] : void 0 : e[n[2]] : e[t];
}
function py(e, t) {
  if (e) {
    var n, s, i, l = 0;
    if (e[t] || cy(e, t))
      return e[t];
    if (s = ay(t), i = s.length, i) {
      for (n = e; l < i; l++)
        if (n = fy(n, s[l]), Pm(n))
          return l === i - 1 ? n : void 0;
    }
    return n;
  }
}
var Hi = dy, qd = Qo, my = ad, Ud = Xl, Gd = Gn, gy = fs, hy = Yl, Kd = Gs, vy = gr, by = Br, xy = Hi, yy = Kl, Cy = "asc", wy = "desc";
function Gu(e, t) {
  return Kd(e) ? 1 : vy(e) ? Kd(t) ? -1 : 1 : e && e.localeCompare ? e.localeCompare(t) : e > t ? 1 : -1;
}
function Ey(e, t, n) {
  return function(s, i) {
    var l = s[e], a = i[e];
    return l === a ? n ? n(s, i) : 0 : t.order === wy ? Gu(a, l) : Gu(l, a);
  };
}
function Sy(e, t, n, s) {
  var i = [];
  return n = Gd(n) ? n : [n], qd(n, function(l, a) {
    if (l) {
      var c = l, m;
      Gd(l) ? (c = l[0], m = l[1]) : hy(l) && (c = l.field, m = l.order), i.push({
        field: c,
        order: m || Cy
      }), qd(t, gy(c) ? function(u, d) {
        u[a] = c.call(s, u.data, d, e);
      } : function(u) {
        u[a] = c ? xy(u.data, c) : u.data;
      });
    }
  }), i;
}
function Dy(e, t, n) {
  if (e) {
    if (by(t))
      return my(e).sort(Gu);
    for (var s, i = Ud(e, function(c) {
      return { data: c };
    }), l = Sy(e, i, t, n), a = l.length - 1; a >= 0; )
      s = Ey(a, l[a], s), a--;
    return s && (i = i.sort(s)), Ud(i, yy("data"));
  }
  return [];
}
var ud = Dy, Oy = ud, Ty = Oy, My = Ty;
function Iy(e, t) {
  return e >= t ? e : (e = e >> 0) + Math.round(Math.random() * ((t || 9) - e));
}
var km = Iy, Vy = rd, Py = Vy("values", 0), Zl = Py, ky = km, $y = Zl;
function Ry(e) {
  for (var t, n = [], s = $y(e), i = s.length - 1; i >= 0; i--)
    t = i > 0 ? ky(0, i) : 0, n.push(s[t]), s.splice(t, 1);
  return n;
}
var $m = Ry, Ny = $m;
function Fy(e, t) {
  var n = Ny(e);
  return arguments.length <= 1 ? n[0] : (t < n.length && (n.length = t || 0), n);
}
var Ly = Fy;
function Ay(e) {
  return function(t) {
    if (t) {
      var n = e(t && t.replace ? t.replace(/,/g, "") : t);
      if (!isNaN(n))
        return n;
    }
    return 0;
  };
}
var Rm = Ay, By = Rm, _y = By(parseFloat), il = _y, Yd = il;
function Wy(e, t, n) {
  var s = [], i = arguments.length;
  if (e) {
    if (t = i >= 2 ? Yd(t) : 0, n = i >= 3 ? Yd(n) : e.length, e.slice)
      return e.slice(t, n);
    for (; t < n; t++)
      s.push(e[t]);
  }
  return s;
}
var al = Wy, zy = xo;
function Hy(e, t, n) {
  var s = [];
  if (e && t) {
    if (e.filter)
      return e.filter(t, n);
    zy(e, function(i, l) {
      t.call(n, i, l, e) && s.push(i);
    });
  }
  return s;
}
var jy = Hy, qy = $c, Uy = qy("", 0, 2, !0), Gy = Uy, Ky = $c, Yy = Ky("find", 1, 3, !0), Xy = Yy, Zy = Gn, Jy = Zl;
function Qy(e, t, n) {
  if (e) {
    Zy(e) || (e = Jy(e));
    for (var s = e.length - 1; s >= 0; s--)
      if (t.call(n, e[s], s, e))
        return e[s];
  }
}
var eC = Qy, tC = mr;
function nC(e, t, n) {
  if (e) {
    var s, i, l = 0, a = null, c = n, m = arguments.length > 2, u = tC(e);
    if (e.length && e.reduce)
      return i = function() {
        return t.apply(a, arguments);
      }, m ? e.reduce(i, c) : e.reduce(i);
    for (m && (l = 1, c = e[u[0]]), s = u.length; l < s; l++)
      c = t.call(a, c, e[u[l]], l, e);
    return c;
  }
}
var oC = nC, sC = Gn;
function rC(e, t, n, s) {
  if (sC(e) && e.copyWithin)
    return e.copyWithin(t, n, s);
  var i, l, a = t >> 0, c = n >> 0, m = e.length, u = arguments.length > 3 ? s >> 0 : m;
  if (a < m && (a = a >= 0 ? a : m + a, a >= 0 && (c = c >= 0 ? c : m + c, u = u >= 0 ? u : m + u, c < u)))
    for (i = 0, l = e.slice(c, u); a < m && !(l.length <= i); a++)
      e[a] = l[i++];
  return e;
}
var lC = rC, iC = Gn;
function aC(e, t) {
  var n, s = [], i = t >> 0 || 1;
  if (iC(e))
    if (i >= 0 && e.length > i)
      for (n = 0; n < e.length; )
        s.push(e.slice(n, n + i)), n += i;
    else
      s = e.length ? [e] : e;
  return s;
}
var cC = aC, uC = Xl, dC = Kl;
function fC(e, t) {
  return uC(e, dC(t));
}
var Nm = fC, pC = fs, Xd = Br, mC = Hi, gC = Qo;
function hC(e) {
  return function(t, n) {
    if (t && t.length) {
      var s, i;
      return gC(t, function(l, a) {
        n && (l = pC(n) ? n(l, a, t) : mC(l, n)), !Xd(l) && (Xd(s) || e(s, l)) && (i = a, s = l);
      }), t[i];
    }
    return s;
  };
}
var Fm = hC, vC = Fm, bC = vC(function(e, t) {
  return e < t;
}), Lm = bC, xC = Nm, yC = Lm;
function CC(e) {
  var t, n, s, i = [];
  if (e && e.length)
    for (t = 0, n = yC(e, function(l) {
      return l ? l.length : 0;
    }), s = n ? n.length : 0; t < s; t++)
      i.push(xC(e, t));
  return i;
}
var Am = CC, wC = Am;
function EC() {
  return wC(arguments);
}
var SC = EC, DC = Zl, OC = xo;
function TC(e, t) {
  var n = {};
  return t = t || [], OC(DC(e), function(s, i) {
    n[s] = t[i];
  }), n;
}
var MC = TC, Bm = Gn, IC = Qo;
function _m(e, t) {
  var n = [];
  return IC(e, function(s) {
    n = n.concat(Bm(s) ? t ? _m(s, t) : s : [s]);
  }), n;
}
function VC(e, t) {
  return Bm(e) ? _m(e, t) : [];
}
var PC = VC, kC = Xl, $C = Gn;
function RC(e, t) {
  for (var n = 0, s = t.length; e && n < s; )
    e = e[t[n++]];
  return s && e ? e : 0;
}
function NC(e, t) {
  for (var n, s = arguments, i = [], l = [], a = 2, c = s.length; a < c; a++)
    i.push(s[a]);
  if ($C(t)) {
    for (c = t.length - 1, a = 0; a < c; a++)
      l.push(t[a]);
    t = t[c];
  }
  return kC(e, function(m) {
    if (l.length && (m = RC(m, l)), n = m[t] || t, n && n.apply)
      return n.apply(m, i);
  });
}
var FC = NC;
function LC(e, t) {
  try {
    delete e[t];
  } catch {
    e[t] = void 0;
  }
}
var Wm = LC, AC = Gn, BC = id, _C = Sm;
function WC(e, t, n) {
  return e && (AC(e) ? BC : _C)(e, t, n);
}
var zm = WC, zC = Gl, HC = zC("object"), Rc = HC, jC = Wm, qC = Yl, UC = Rc, GC = Gn, KC = gr, YC = Rs, XC = Wi;
function ZC(e, t, n) {
  if (e) {
    var s, i = arguments.length > 1 && (KC(t) || !UC(t)), l = i ? n : t;
    if (qC(e))
      XC(e, i ? function(a, c) {
        e[c] = t;
      } : function(a, c) {
        jC(e, c);
      }), l && YC(e, l);
    else if (GC(e)) {
      if (i)
        for (s = e.length; s > 0; )
          s--, e[s] = t;
      else
        e.length = 0;
      l && e.push.apply(e, l);
    }
  }
  return e;
}
var Hm = ZC, JC = Wm, QC = fs, ew = Gn, tw = xo, nw = Qo, ow = zm, sw = Hm, rw = Br;
function lw(e) {
  return function(t, n) {
    return n === e;
  };
}
function iw(e, t, n) {
  if (e) {
    if (!rw(t)) {
      var s = [], i = [];
      return QC(t) || (t = lw(t)), tw(e, function(l, a, c) {
        t.call(n, l, a, c) && s.push(a);
      }), ew(e) ? ow(s, function(l, a) {
        i.push(e[l]), e.splice(l, 1);
      }) : (i = {}, nw(s, function(l) {
        i[l] = e[l], JC(e, l);
      })), i;
    }
    return sw(e);
  }
  return e;
}
var jm = iw, aw = pr, cw = ud, uw = ld, dw = Br, Ku = xo, fw = jm, pw = Rs;
function mw(e, t) {
  Ku(e, function(n) {
    n[t] && !n[t].length && fw(n, t);
  });
}
function gw(e, t) {
  var n = pw({}, aw.treeOptions, t), s = n.strict, i = n.key, l = n.parentKey, a = n.children, c = n.mapChildren, m = n.sortKey, u = n.reverse, d = n.data, p = [], w = {}, v = {}, D, S, x;
  return m && (e = cw(uw(e), m), u && (e = e.reverse())), Ku(e, function(h) {
    D = h[i], v[D] = !0;
  }), Ku(e, function(h) {
    D = h[i], d ? (S = {}, S[d] = h) : S = h, x = h[l], w[D] = w[D] || [], S[i] = D, S[l] = x, D === x && (x = null, console.log("Fix infinite Loop.", h)), w[x] = w[x] || [], w[x].push(S), S[a] = w[D], c && (S[c] = w[D]), (!s || s && dw(x)) && (v[x] || p.push(S));
  }), s && mw(e, a), p;
}
var hw = gw, vw = pr, bw = xo, xw = Rs;
function qm(e, t, n) {
  var s = n.children, i = n.data, l = n.clear;
  return bw(t, function(a) {
    var c = a[s];
    i && (a = a[i]), e.push(a), c && c.length && qm(e, c, n), l && delete a[s];
  }), e;
}
function yw(e, t) {
  return qm([], e, xw({}, vw.treeOptions, t));
}
var Cw = yw;
function ww(e) {
  return function(t, n, s, i) {
    var l = s || {}, a = l.children || "children";
    return e(null, t, n, i, [], [], a, l);
  };
}
var Nc = ww, Ew = Nc;
function Um(e, t, n, s, i, l, a, c) {
  if (t) {
    var m, u, d, p, w, v;
    for (u = 0, d = t.length; u < d; u++) {
      if (m = t[u], p = i.concat(["" + u]), w = l.concat([m]), n.call(s, m, u, t, p, e, w))
        return { index: u, item: m, path: p, items: t, parent: e, nodes: w };
      if (a && m && (v = Um(m, m[a], n, s, p.concat([a]), w, a), v))
        return v;
    }
  }
}
var Sw = Ew(Um), Dw = Sw, Ow = Nc, Tw = xo;
function Gm(e, t, n, s, i, l, a, c) {
  var m, u;
  Tw(t, function(d, p) {
    m = i.concat(["" + p]), u = l.concat([d]), n.call(s, d, p, t, m, e, u), d && a && (m.push(a), Gm(d, d[a], n, s, m, u, a));
  });
}
var Mw = Ow(Gm), Km = Mw, Iw = Nc, Vw = Xl;
function Ym(e, t, n, s, i, l, a, c) {
  var m, u, d, p = c.mapChildren || a;
  return Vw(t, function(w, v) {
    return m = i.concat(["" + v]), u = l.concat([w]), d = n.call(s, w, v, t, m, e, u), d && w && a && w[a] && (d[p] = Ym(w, w[a], n, s, m, u, a, c)), d;
  });
}
var Pw = Iw(Ym), kw = Pw, $w = Km;
function Rw(e, t, n, s) {
  var i = [];
  return e && t && $w(e, function(l, a, c, m, u, d) {
    t.call(s, l, a, c, m, u, d) && i.push(l);
  }, n), i;
}
var Nw = Rw, Fw = Nc, Lw = Qo, Aw = Rs;
function Xm(e, t, n, s, i, l, a, c, m) {
  var u, d, p, w, v, D = [], S = m.original, x = m.data, h = m.mapChildren || c, O = m.isEvery;
  return Lw(n, function(g, b) {
    u = l.concat(["" + b]), d = a.concat([g]), w = e && !O || s.call(i, g, b, n, u, t, d), v = c && g[c], w || v ? (S ? p = g : (p = Aw({}, g), x && (p[x] = g)), p[h] = Xm(w, g, g[c], s, i, u, d, c, m), (w || p[h].length) && D.push(p)) : w && D.push(p);
  }), D;
}
var Bw = Fw(function(e, t, n, s, i, l, a, c) {
  return Xm(0, e, t, n, s, i, l, a, c);
}), _w = Bw;
function Ww(e, t) {
  if (e.indexOf)
    return e.indexOf(t);
  for (var n = 0, s = e.length; n < s; n++)
    if (t === e[n])
      return n;
}
var Zm = Ww;
function zw(e, t) {
  if (e.lastIndexOf)
    return e.lastIndexOf(t);
  for (var n = e.length - 1; n >= 0; n--)
    if (t === e[n])
      return n;
  return -1;
}
var Jm = zw, Hw = Gl, jw = Hw("number"), Ks = jw, qw = Ks;
function Uw(e) {
  return qw(e) && isNaN(e);
}
var Gw = Uw, Kw = Gl, Yw = Kw("string"), hr = Yw, Xw = _i, Zw = Xw("Date"), _r = Zw, Jw = parseInt, ji = Jw;
function Qw(e) {
  return Date.UTC(e.y, e.M || 0, e.d || 1, e.H || 0, e.m || 0, e.s || 0, e.S || 0);
}
var eE = Qw;
function tE(e) {
  return e.getTime();
}
var ys = tE, Dc = ji, Zd = eE, nE = ys, oE = hr, sE = _r;
function qi(e) {
  return "(\\d{" + e + "})";
}
function rE(e) {
  return e < 10 ? e * 100 : e < 100 ? e * 10 : e;
}
function Jd(e) {
  return isNaN(e) ? e : Dc(e);
}
var pl = qi(2), Ol = qi("1,2"), Qm = qi("1,7"), eg = qi("3,4"), tg = ".{1}", ui = tg + Ol, ng = "(([zZ])|([-+]\\d{2}:?\\d{2}))", Qd = [eg, ui, ui, ui, ui, ui, tg + Qm, ng], Yu = [];
for (var fu = Qd.length - 1; fu >= 0; fu--) {
  for (var ef = "", el = 0; el < fu + 1; el++)
    ef += Qd[el];
  Yu.push(new RegExp("^" + ef + "$"));
}
function lE(e) {
  for (var t, n = {}, s = 0, i = Yu.length; s < i; s++)
    if (t = e.match(Yu[s]), t) {
      n.y = t[1], n.M = t[2], n.d = t[3], n.H = t[4], n.m = t[5], n.s = t[6], n.S = t[7], n.Z = t[8];
      break;
    }
  return n;
}
var tf = [
  ["yyyy", eg],
  ["yy", pl],
  ["MM", pl],
  ["M", Ol],
  ["dd", pl],
  ["d", Ol],
  ["HH", pl],
  ["H", Ol],
  ["mm", pl],
  ["m", Ol],
  ["ss", pl],
  ["s", Ol],
  ["SSS", qi(3)],
  ["S", Qm],
  ["Z", ng]
], og = {}, sg = ["\\[([^\\]]+)\\]"];
for (var el = 0; el < tf.length; el++) {
  var pu = tf[el];
  og[pu[0]] = pu[1] + "?", sg.push(pu[0]);
}
var iE = new RegExp(sg.join("|"), "g"), nf = {};
function aE(e, t) {
  var n = nf[t];
  if (!n) {
    var s = [], i = t.replace(/([$(){}*+.?\\^|])/g, "\\$1").replace(iE, function(d, p) {
      var w = d.charAt(0);
      return w === "[" ? p : (s.push(w), og[d]);
    });
    n = nf[t] = {
      _i: s,
      _r: new RegExp(i)
    };
  }
  var l = {}, a = e.match(n._r);
  if (a) {
    for (var c = n._i, m = 1, u = a.length; m < u; m++)
      l[c[m - 1]] = a[m];
    return l;
  }
  return l;
}
function cE(e) {
  if (/^[zZ]/.test(e.Z))
    return new Date(Zd(e));
  var t = e.Z.match(/([-+])(\d{2}):?(\d{2})/);
  return t ? new Date(Zd(e) - (t[1] === "-" ? -1 : 1) * Dc(t[2]) * 36e5 + Dc(t[3]) * 6e4) : /* @__PURE__ */ new Date("");
}
function uE(e, t) {
  if (e) {
    var n = sE(e);
    if (n || !t && /^[0-9]{11,15}$/.test(e))
      return new Date(n ? nE(e) : Dc(e));
    if (oE(e)) {
      var s = t ? aE(e, t) : lE(e);
      if (s.y)
        return s.M && (s.M = Jd(s.M) - 1), s.S && (s.S = rE(Jd(s.S.substring(0, 3)))), s.Z ? cE(s) : new Date(s.y, s.M || 0, s.d || 1, s.H || 0, s.m || 0, s.s || 0, s.S || 0);
    }
  }
  return /* @__PURE__ */ new Date("");
}
var ps = uE;
function dE() {
  return /* @__PURE__ */ new Date();
}
var Fc = dE, fE = _r, pE = ps, mE = Fc;
function gE(e) {
  var t, n = e ? pE(e) : mE();
  return fE(n) ? (t = n.getFullYear(), t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0)) : !1;
}
var rg = gE, hE = Gn, vE = $s;
function bE(e, t, n) {
  if (e) {
    if (hE(e))
      for (var s = 0, i = e.length; s < i && t.call(n, e[s], s, e) !== !1; s++)
        ;
    else
      for (var l in e)
        if (vE(e, l) && t.call(n, e[l], l, e) === !1)
          break;
  }
}
var xE = bE, yE = Gn, CE = $s;
function wE(e, t, n) {
  if (e) {
    var s, i;
    if (yE(e))
      for (s = e.length - 1; s >= 0 && t.call(n, e[s], s, e) !== !1; s--)
        ;
    else
      for (i = CE(e), s = i.length - 1; s >= 0 && t.call(n, e[i[s]], i[s], e) !== !1; s--)
        ;
  }
}
var EE = wE, SE = Gn, DE = hr, OE = $s;
function TE(e, t) {
  return function(n, s) {
    if (n) {
      if (n[e])
        return n[e](s);
      if (DE(n) || SE(n))
        return t(n, s);
      for (var i in n)
        if (OE(n, i) && s === n[i])
          return i;
    }
    return -1;
  };
}
var lg = TE, ME = lg, IE = Zm, VE = ME("indexOf", IE), PE = VE, kE = lg, $E = Jm, RE = kE("lastIndexOf", $E), ig = RE, NE = Gn, FE = hr, LE = xo;
function AE(e) {
  var t = 0;
  return FE(e) || NE(e) ? e.length : (LE(e, function() {
    t++;
  }), t);
}
var ag = AE, BE = Ks;
function _E(e) {
  return BE(e) && isFinite(e);
}
var WE = _E, zE = Gn, HE = gr, jE = function(e) {
  return !HE(e) && !isNaN(e) && !zE(e) && e % 1 === 0;
}, cg = jE, qE = Gn, UE = cg, GE = gr;
function KE(e) {
  return !GE(e) && !isNaN(e) && !qE(e) && !UE(e);
}
var YE = KE, XE = Gl, ZE = XE("boolean"), ug = ZE, JE = _i, QE = JE("RegExp"), dd = QE, eS = _i, tS = eS("Error"), dg = tS;
function nS(e) {
  return e ? e.constructor === TypeError : !1;
}
var oS = nS;
function sS(e) {
  for (var t in e)
    return !1;
  return !0;
}
var fg = sS, rS = Ns, lS = typeof Symbol !== rS;
function iS(e) {
  return lS && Symbol.isSymbol ? Symbol.isSymbol(e) : typeof e == "symbol";
}
var pg = iS, aS = _i, cS = aS("Arguments"), uS = cS, dS = hr, fS = Ks;
function pS(e) {
  return !!(e && dS(e.nodeName) && fS(e.nodeType));
}
var mS = pS, gS = Ns, hS = typeof document === gS ? 0 : document, fd = hS, vS = fd;
function bS(e) {
  return !!(e && vS && e.nodeType === 9);
}
var xS = bS, yS = Ns, CS = typeof window === yS ? 0 : window, mg = CS, wS = mg;
function ES(e) {
  return !!(wS && (e && e === e.window));
}
var SS = ES, DS = Ns, OS = typeof FormData !== DS;
function TS(e) {
  return OS && e instanceof FormData;
}
var MS = TS, IS = Ns, VS = typeof Map !== IS;
function PS(e) {
  return VS && e instanceof Map;
}
var kS = PS, $S = Ns, RS = typeof WeakMap !== $S;
function NS(e) {
  return RS && e instanceof WeakMap;
}
var FS = NS, LS = Ns, AS = typeof Set !== LS;
function BS(e) {
  return AS && e instanceof Set;
}
var _S = BS, WS = Ns, zS = typeof WeakSet !== WS;
function HS(e) {
  return zS && e instanceof WeakSet;
}
var jS = HS, qS = fs, US = hr, GS = Gn, KS = $s;
function YS(e) {
  return function(t, n, s) {
    if (t && qS(n)) {
      if (GS(t) || US(t))
        return e(t, n, s);
      for (var i in t)
        if (KS(t, i) && n.call(s, t[i], i, t))
          return i;
    }
    return -1;
  };
}
var gg = YS, XS = gg, ZS = XS(function(e, t, n) {
  for (var s = 0, i = e.length; s < i; s++)
    if (t.call(n, e[s], s, e))
      return s;
  return -1;
}), pd = ZS, of = Ks, sf = Gn, rf = hr, JS = dd, QS = _r, eD = ug, tD = Gs, lf = mr, nD = Tm;
function hg(e, t, n, s, i, l, a) {
  if (e === t)
    return !0;
  if (e && t && !of(e) && !of(t) && !rf(e) && !rf(t)) {
    if (JS(e))
      return n("" + e, "" + t, i, l, a);
    if (QS(e) || eD(e))
      return n(+e, +t, i, l, a);
    var c, m, u, d = sf(e), p = sf(t);
    if (d || p ? d && p : e.constructor === t.constructor)
      return m = lf(e), u = lf(t), s && (c = s(e, t, i)), m.length === u.length ? tD(c) ? nD(m, function(w, v) {
        return w === u[v] && hg(e[w], t[u[v]], n, s, d || p ? v : w, e, t);
      }) : !!c : !1;
  }
  return n(e, t, i, l, a);
}
var vg = hg;
function oD(e, t) {
  return e === t;
}
var bg = oD, sD = vg, rD = bg;
function lD(e, t) {
  return sD(e, t, rD);
}
var xg = lD, af = mr, iD = pd, cf = xg, aD = Om, cD = Mm;
function uD(e, t) {
  var n = af(e), s = af(t);
  if (s.length) {
    if (cD(n, s))
      return aD(s, function(i) {
        return iD(n, function(l) {
          return l === i && cf(e[l], t[i]);
        }) > -1;
      });
  } else
    return !0;
  return cf(e, t);
}
var dD = uD, uf = vg, df = bg, fD = fs, pD = Gs;
function mD(e, t, n) {
  return fD(n) ? uf(e, t, function(s, i, l, a, c) {
    var m = n(s, i, l, a, c);
    return pD(m) ? df(s, i) : !!m;
  }, n) : uf(e, t, df);
}
var gD = mD, hD = pg, vD = _r, bD = Gn, xD = dd, yD = dg, CD = gr;
function wD(e) {
  return CD(e) ? "null" : hD(e) ? "symbol" : vD(e) ? "date" : bD(e) ? "array" : xD(e) ? "regexp" : yD(e) ? "error" : typeof e;
}
var ED = wD, SD = 0;
function DD(e) {
  return [e, ++SD].join("");
}
var OD = DD, TD = gg, MD = TD(function(e, t, n) {
  for (var s = e.length - 1; s >= 0; s--)
    if (t.call(n, e[s], s, e))
      return s;
  return -1;
}), ID = MD, VD = Yl, PD = hr;
function kD(e) {
  if (VD(e))
    return e;
  if (PD(e))
    try {
      return JSON.parse(e);
    } catch {
    }
  return {};
}
var $D = kD, RD = Br;
function ND(e) {
  return RD(e) ? "" : JSON.stringify(e);
}
var FD = ND, LD = rd, AD = LD("entries", 2), BD = AD, _D = fs, WD = Gn, zD = xo, HD = pd;
function jD(e, t) {
  return function(n, s) {
    var i, l, a = {}, c = [], m = this, u = arguments, d = u.length;
    if (!_D(s)) {
      for (l = 1; l < d; l++)
        i = u[l], c.push.apply(c, WD(i) ? i : [i]);
      s = 0;
    }
    return zD(n, function(p, w) {
      ((s ? s.call(m, p, w, n) : HD(c, function(v) {
        return v === w;
      }) > -1) ? e : t) && (a[w] = p);
    }), a;
  };
}
var yg = jD, qD = yg, UD = qD(1, 0), GD = UD, KD = yg, YD = KD(0, 1), XD = YD, ZD = Zl;
function JD(e) {
  return ZD(e)[0];
}
var QD = JD, eO = Zl;
function tO(e) {
  var t = eO(e);
  return t[t.length - 1];
}
var nO = tO, oO = Vm, sO = cd, ua = $s;
function rO(e, t) {
  if (e) {
    if (ua(e, t))
      return !0;
    var n, s, i, l, a, c, m = sO(t), u = 0, d = m.length;
    for (a = e; u < d && (c = !1, n = m[u], l = n ? n.match(oO) : "", l ? (s = l[1], i = l[2], s ? a[s] && ua(a[s], i) && (c = !0, a = a[s][i]) : ua(a, i) && (c = !0, a = a[i])) : ua(a, n) && (c = !0, a = a[n]), c); u++)
      if (u === d - 1)
        return !0;
  }
  return !1;
}
var lO = rO, ff = ji, iO = cd, aO = $s, pf = /(.+)?\[(\d+)\]$/;
function cO(e, t, n, s, i) {
  if (e[t])
    n && (e[t] = i);
  else {
    var l, a, c = t ? t.match(pf) : null;
    if (n)
      a = i;
    else {
      var m = s ? s.match(pf) : null;
      m && !m[1] ? a = new Array(ff(m[2]) + 1) : a = {};
    }
    return c ? c[1] ? (l = ff(c[2]), e[c[1]] ? n ? e[c[1]][l] = a : e[c[1]][l] ? a = e[c[1]][l] : e[c[1]][l] = a : (e[c[1]] = new Array(l + 1), e[c[1]][l] = a)) : e[c[2]] = a : e[t] = a, a;
  }
  return e[t];
}
function uO(e, t, n) {
  if (e) {
    if ((e[t] || aO(e, t)) && !mf(t))
      e[t] = n;
    else
      for (var s = e, i = iO(t), l = i.length, a = 0; a < l; a++)
        if (!mf(i[a])) {
          var c = a === l - 1;
          s = cO(s, i[a], c, c ? null : i[a + 1], n);
        }
  }
  return e;
}
function mf(e) {
  return e === "__proto__" || e === "constructor" || e === "prototype";
}
var dO = uO, fO = fg, pO = Rc, mO = fs, gO = Kl, hO = xo;
function vO(e) {
  return function() {
    return fO(e);
  };
}
function bO(e, t, n) {
  var s, i = {};
  return e && (t && pO(t) ? t = vO(t) : mO(t) || (t = gO(t)), hO(e, function(l, a) {
    s = t ? t.call(n, l, a, e) : l, i[s] ? i[s].push(l) : i[s] = [l];
  })), i;
}
var Cg = bO, xO = Cg, yO = Wi;
function CO(e, t, n) {
  var s = xO(e, t, n || this);
  return yO(s, function(i, l) {
    s[l] = i.length;
  }), s;
}
var wO = CO;
function EO(e, t, n) {
  var s, i, l = [], a = arguments;
  if (a.length < 2 && (t = a[0], e = 0), s = e >> 0, i = t >> 0, s < t)
    for (n = n >> 0 || 1; s < i; s += n)
      l.push(s);
  return l;
}
var SO = EO, gf = mr, DO = al, OO = zi, TO = Qo, MO = Rs;
function IO(e, t) {
  if (e && t) {
    var n = MO.apply(this, [{}].concat(DO(arguments, 1))), s = gf(n);
    TO(gf(e), function(i) {
      OO(s, i) && (e[i] = n[i]);
    });
  }
  return e;
}
var VO = IO, PO = Fm, kO = PO(function(e, t) {
  return e > t;
}), $O = kO;
function RO(e) {
  return (e.split(".")[1] || "").length;
}
var Lc = RO, NO = ji;
function FO(e, t) {
  if (e.repeat)
    return e.repeat(t);
  var n = isNaN(t) ? [] : new Array(NO(t));
  return n.join(e) + (n.length > 0 ? e : "");
}
var Ui = FO;
function LO(e, t) {
  return e.substring(0, t) + "." + e.substring(t, e.length);
}
var wg = LO, da = Ui, mu = wg;
function AO(e) {
  var t = "" + e, n = t.match(/^([-+]?)((\d+)|((\d+)?[.](\d+)?))e([-+]{1})([0-9]+)$/);
  if (n) {
    var s = e < 0, i = s ? "-" : "", l = n[3] || "", a = n[5] || "", c = n[6] || "", m = n[7], u = n[8], d = u - c.length, p = u - l.length, w = u - a.length;
    return m === "+" ? l ? i + l + da("0", u) : d > 0 ? i + a + c + da("0", d) : i + a + mu(c, u) : l ? p > 0 ? i + "0." + da("0", Math.abs(p)) + l : i + mu(l, p) : w > 0 ? i + "0." + da("0", Math.abs(w)) + a + c : i + mu(a, w) + c;
  }
  return t;
}
var Wr = AO, hf = Lc, vf = Wr;
function BO(e, t) {
  var n = vf(e), s = vf(t);
  return parseInt(n.replace(".", "")) * parseInt(s.replace(".", "")) / Math.pow(10, hf(n) + hf(s));
}
var Eg = BO, _O = Eg, bf = il, WO = Wr;
function zO(e) {
  return function(t, n) {
    var s = bf(t), i = s;
    if (s) {
      n = n >> 0;
      var l = WO(s), a = l.split("."), c = a[0], m = a[1] || "", u = m.substring(0, n + 1), d = c + (u ? "." + u : "");
      if (n >= m.length)
        return bf(d);
      if (d = s, n > 0) {
        var p = Math.pow(10, n);
        i = Math[e](_O(d, p)) / p;
      } else
        i = Math[e](d);
    }
    return i;
  };
}
var md = zO, HO = md, jO = HO("round"), gd = jO, qO = md, UO = qO("ceil"), Sg = UO, GO = md, KO = GO("floor"), Dg = KO, YO = Br, XO = Ks, ZO = Wr;
function JO(e) {
  return XO(e) ? ZO(e) : "" + (YO(e) ? "" : e);
}
var es = JO, QO = gd, eT = es, tT = Ui, nT = wg;
function oT(e, t) {
  t = t >> 0;
  var n = eT(QO(e, t)), s = n.split("."), i = s[0], l = s[1] || "", a = t - l.length;
  return t ? a > 0 ? i + "." + l + tT("0", a) : i + nT(l, Math.abs(a)) : i;
}
var hd = oT, sT = pr, rT = gd, lT = Sg, iT = Dg, aT = Ks, cT = es, uT = hd, dT = Wr, fT = Rs;
function pT(e, t) {
  var n = fT({}, sT.commafyOptions, t), s = n.digits, i = aT(e), l, a, c, m, u;
  return i ? (l = (n.ceil ? lT : n.floor ? iT : rT)(e, s), a = dT(s ? uT(l, s) : l).split("."), m = a[0], u = a[1], c = m && l < 0, c && (m = m.substring(1, m.length))) : (l = cT(e).replace(/,/g, ""), a = l ? [l] : [], m = a[0]), a.length ? (c ? "-" : "") + m.replace(new RegExp("(?=(?!(\\b))(.{" + (n.spaceNumber || 3) + "})+$)", "g"), n.separator || ",") + (u ? "." + u : "") : l;
}
var mT = pT, gT = ji, hT = Rm, vT = hT(gT), bT = vT, xT = Eg, xf = il;
function yT(e, t) {
  var n = xf(e), s = xf(t);
  return xT(n, s);
}
var vd = yT, yf = Lc, Cf = Wr, wf = vd;
function CT(e, t) {
  var n = Cf(e), s = Cf(t), i = Math.pow(10, Math.max(yf(n), yf(s)));
  return (wf(e, i) + wf(t, i)) / i;
}
var Og = CT, wT = Og, Ef = il;
function ET(e, t) {
  return wT(Ef(e), Ef(t));
}
var ST = ET, Sf = Lc, Df = Wr, Of = il, DT = hd;
function OT(e, t) {
  var n = Of(e), s = Of(t), i = Df(n), l = Df(s), a = Sf(i), c = Sf(l), m = Math.pow(10, Math.max(a, c)), u = a >= c ? a : c;
  return parseFloat(DT((n * m - s * m) / m, u));
}
var TT = OT, Tf = Lc, Mf = Wr, MT = vd;
function IT(e, t) {
  var n = Mf(e), s = Mf(t), i = Tf(n), l = Tf(s), a = l - i, c = a < 0, m = Math.pow(10, c ? Math.abs(a) : a);
  return MT(n.replace(".", "") / s.replace(".", ""), c ? 1 / m : m);
}
var Tg = IT, VT = Tg, If = il;
function PT(e, t) {
  return VT(If(e), If(t));
}
var kT = PT, gu = Og, $T = fs, RT = Gn, NT = xo, FT = Hi;
function LT(e, t, n) {
  var s = 0;
  return NT(e && e.length > 2 && RT(e) ? e.sort() : e, t ? $T(t) ? function() {
    s = gu(s, t.apply(n, arguments));
  } : function(i) {
    s = gu(s, FT(i, t));
  } : function(i) {
    s = gu(s, i);
  }), s;
}
var Mg = LT, AT = Tg, BT = ag, _T = Mg;
function WT(e, t, n) {
  return AT(_T(e, t, n), BT(e));
}
var zT = WT, HT = "first", Gi = HT, jT = "last", Ac = jT;
function qT(e) {
  return e.getFullYear();
}
var Ki = qT, UT = 864e5, Yi = UT;
function GT(e) {
  return e.getMonth();
}
var Bc = GT, KT = _r, YT = ys;
function XT(e) {
  return KT(e) && !isNaN(YT(e));
}
var Cs = XT, Vf = Gi, ZT = Ac, JT = Yi, QT = Ki, Pf = ys, kf = Bc, eM = ps, tM = Cs, nM = Ks;
function Ig(e, t, n) {
  var s = t && !isNaN(t) ? t : 0;
  if (e = eM(e), tM(e)) {
    if (n === Vf)
      return new Date(QT(e), kf(e) + s, 1);
    if (n === ZT)
      return new Date(Pf(Ig(e, s + 1, Vf)) - 1);
    if (nM(n) && e.setDate(n), s) {
      var i = e.getDate();
      if (e.setMonth(kf(e) + s), i !== e.getDate())
        return e.setDate(1), new Date(Pf(e) - JT);
    }
  }
  return e;
}
var Xi = Ig, oM = Gi, $f = Ac, Rf = Ki, sM = Xi, rM = ps, lM = Cs;
function iM(e, t, n) {
  var s;
  if (e = rM(e), lM(e) && (t && (s = t && !isNaN(t) ? t : 0, e.setFullYear(Rf(e) + s)), n || !isNaN(n))) {
    if (n === oM)
      return new Date(Rf(e), 0, 1);
    if (n === $f)
      return e.setMonth(11), sM(e, 0, $f);
    e.setMonth(n);
  }
  return e;
}
var _c = iM, aM = Xi, cM = ps, uM = Cs;
function dM(e) {
  var t = e.getMonth();
  return t < 3 ? 1 : t < 6 ? 2 : t < 9 ? 3 : 4;
}
function fM(e, t, n) {
  var s, i = t && !isNaN(t) ? t * 3 : 0;
  return e = cM(e), uM(e) ? (s = (dM(e) - 1) * 3, e.setMonth(s), aM(e, i, n)) : e;
}
var pM = fM, Nf = Gi, mM = Ac, gM = ji, hM = Ki, vM = Bc, bM = ys, xM = ps, yM = Cs;
function Vg(e, t, n) {
  if (e = xM(e), yM(e) && !isNaN(t)) {
    if (e.setDate(e.getDate() + gM(t)), n === Nf)
      return new Date(hM(e), vM(e), e.getDate());
    if (n === mM)
      return new Date(bM(Vg(e, 1, Nf)) - 1);
  }
  return e;
}
var Pg = Vg;
function CM(e) {
  return e.toUpperCase();
}
var kg = CM, wM = Yi, EM = wM * 7, $g = EM, SM = pr, hu = Yi, DM = $g, OM = ys, TM = ps, MM = Cs, Ff = Ks;
function IM(e, t, n, s) {
  if (e = TM(e), MM(e)) {
    var i = Ff(n), l = Ff(s), a = OM(e);
    if (i || l) {
      var c = l ? s : SM.firstDayOfWeek, m = e.getDay(), u = i ? n : m;
      if (m !== u) {
        var d = 0;
        c > m ? d = -(7 - c + m) : c < m && (d = c - m), u > c ? a += ((u === 0 ? 7 : u) - c + d) * hu : u < c ? a += (7 - c + u + d) * hu : a += d * hu;
      }
    }
    return t && !isNaN(t) && (a += t * DM), new Date(a);
  }
  return e;
}
var Rg = IM, VM = pr, PM = $g, kM = Ks, $M = Cs, RM = Rg, Lf = ys;
function NM(e) {
  return function(t, n) {
    var s = kM(n) ? n : VM.firstDayOfWeek, i = RM(t, 0, s, s);
    if ($M(i)) {
      var l = new Date(i.getFullYear(), i.getMonth(), i.getDate()), a = e(i), c = a.getDay();
      return c > s && a.setDate(7 - c + s + 1), c < s && a.setDate(s - c + 1), Math.floor((Lf(l) - Lf(a)) / PM + 1);
    }
    return NaN;
  };
}
var Ng = NM, FM = Ng, LM = FM(function(e) {
  return new Date(e.getFullYear(), 0, 1);
}), Fg = LM, AM = Ki, BM = Bc;
function _M(e) {
  return new Date(AM(e), BM(e), e.getDate());
}
var WM = _M, zM = ys, HM = WM;
function jM(e) {
  return zM(HM(e));
}
var qM = jM, UM = Yi, GM = Gi, Af = qM, KM = _c, YM = ps, XM = Cs;
function ZM(e) {
  return e = YM(e), XM(e) ? Math.floor((Af(e) - Af(KM(e, 0, GM))) / UM) + 1 : NaN;
}
var Lg = ZM, JM = es, QM = Gs, eI = Ui;
function tI(e, t, n) {
  var s = JM(e);
  return t = t >> 0, n = QM(n) ? " " : "" + n, s.padStart ? s.padStart(t, n) : t > s.length ? (t -= s.length, t > n.length && (n += eI(n, t / n.length)), n.slice(0, t) + s) : s;
}
var Ag = tI, di = pr, nI = kg, oI = Ki, Bf = Bc, sI = ps, rI = Fg, lI = Lg, iI = Rs, aI = Cs, cI = fs, Bs = Ag;
function Sr(e, t, n, s) {
  var i = t[n];
  return i ? cI(i) ? i(s, n, e) : i[s] : s;
}
var uI = /\[([^\]]+)]|y{2,4}|M{1,2}|d{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|Z{1,2}|W{1,2}|D{1,3}|[aAeEq]/g;
function dI(e, t, n) {
  if (e) {
    if (e = sI(e), aI(e)) {
      var s = t || di.parseDateFormat || di.formatString, i = e.getHours(), l = i < 12 ? "am" : "pm", a = iI({}, di.parseDateRules || di.formatStringMatchs, n ? n.formats : null), c = function(g, b) {
        return ("" + oI(e)).substr(4 - b);
      }, m = function(g, b) {
        return Bs(Bf(e) + 1, b, "0");
      }, u = function(g, b) {
        return Bs(e.getDate(), b, "0");
      }, d = function(g, b) {
        return Bs(i, b, "0");
      }, p = function(g, b) {
        return Bs(i <= 12 ? i : i - 12, b, "0");
      }, w = function(g, b) {
        return Bs(e.getMinutes(), b, "0");
      }, v = function(g, b) {
        return Bs(e.getSeconds(), b, "0");
      }, D = function(g, b) {
        return Bs(e.getMilliseconds(), b, "0");
      }, S = function(g, b) {
        var E = e.getTimezoneOffset() / 60 * -1;
        return Sr(e, a, g, (E >= 0 ? "+" : "-") + Bs(E, 2, "0") + (b === 1 ? ":" : "") + "00");
      }, x = function(g, b) {
        return Bs(Sr(e, a, g, rI(e, (n ? n.firstDay : null) || di.firstDayOfWeek)), b, "0");
      }, h = function(g, b) {
        return Bs(Sr(e, a, g, lI(e)), b, "0");
      }, O = {
        yyyy: c,
        yy: c,
        MM: m,
        M: m,
        dd: u,
        d: u,
        HH: d,
        H: d,
        hh: p,
        h: p,
        mm: w,
        m: w,
        ss: v,
        s: v,
        SSS: D,
        S: D,
        ZZ: S,
        Z: S,
        WW: x,
        W: x,
        DDD: h,
        D: h,
        a: function(g) {
          return Sr(e, a, g, l);
        },
        A: function(g) {
          return Sr(e, a, g, nI(l));
        },
        e: function(g) {
          return Sr(e, a, g, e.getDay());
        },
        E: function(g) {
          return Sr(e, a, g, e.getDay());
        },
        q: function(g) {
          return Sr(e, a, g, Math.floor((Bf(e) + 3) / 3));
        }
      };
      return s.replace(uI, function(g, b) {
        return b || (O[g] ? O[g](g, g.length) : g);
      });
    }
    return "Invalid Date";
  }
  return "";
}
var Bg = dI, fI = ys, pI = Fc, mI = Date.now || function() {
  return fI(pI());
}, _g = mI, gI = ys, hI = _g, vI = ps, bI = _r, xI = function(e, t) {
  if (e) {
    var n = vI(e, t);
    return bI(n) ? gI(n) : n;
  }
  return hI();
}, yI = xI, _f = Bg;
function CI(e, t, n) {
  return e && t ? (e = _f(e, n), e !== "Invalid Date" && e === _f(t, n)) : !1;
}
var wI = CI, EI = Ng, SI = EI(function(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1);
}), DI = SI, OI = _c, TI = ps, MI = Cs, II = rg;
function VI(e, t) {
  return e = TI(e), MI(e) ? II(OI(e, t)) ? 366 : 365 : NaN;
}
var PI = VI, kI = Yi, $I = Gi, RI = Ac, Wf = ys, zf = Xi, NI = ps, FI = Cs;
function LI(e, t) {
  return e = NI(e), FI(e) ? Math.floor((Wf(zf(e, t, RI)) - Wf(zf(e, t, $I))) / kI) + 1 : NaN;
}
var AI = LI, Hf = ys, BI = Fc, jf = ps, qf = Cs, Uf = [
  ["yyyy", 31536e6],
  ["MM", 2592e6],
  ["dd", 864e5],
  ["HH", 36e5],
  ["mm", 6e4],
  ["ss", 1e3],
  ["S", 0]
];
function _I(e, t) {
  var n, s, i, l, a, c, m = { done: !1, time: 0 };
  if (e = jf(e), t = t ? jf(t) : BI(), qf(e) && qf(t) && (n = Hf(e), s = Hf(t), n < s))
    for (l = m.time = s - n, m.done = !0, c = 0, a = Uf.length; c < a; c++)
      i = Uf[c], l >= i[1] ? c === a - 1 ? m[i[0]] = l || 0 : (m[i[0]] = Math.floor(l / i[1]), l -= m[i[0]] * i[1]) : m[i[0]] = 0;
  return m;
}
var WI = _I, zI = es, HI = Gs, jI = Ui;
function qI(e, t, n) {
  var s = zI(e);
  return t = t >> 0, n = HI(n) ? " " : "" + n, s.padEnd ? s.padEnd(t, n) : t > s.length ? (t -= s.length, t > n.length && (n += jI(n, t / n.length)), s + n.slice(0, t)) : s;
}
var UI = qI, GI = es, KI = Ui;
function YI(e, t) {
  return KI(GI(e), t);
}
var XI = YI, ZI = es;
function JI(e) {
  return e && e.trimRight ? e.trimRight() : ZI(e).replace(/[\s\uFEFF\xA0]+$/g, "");
}
var Wg = JI, QI = es;
function eV(e) {
  return e && e.trimLeft ? e.trimLeft() : QI(e).replace(/^[\s\uFEFF\xA0]+/g, "");
}
var zg = eV, tV = Wg, nV = zg;
function oV(e) {
  return e && e.trim ? e.trim() : tV(nV(e));
}
var Hg = oV, sV = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
}, jg = sV, rV = es, lV = mr;
function iV(e) {
  var t = new RegExp("(?:" + lV(e).join("|") + ")", "g");
  return function(n) {
    return rV(n).replace(t, function(s) {
      return e[s];
    });
  };
}
var qg = iV, aV = jg, cV = qg, uV = cV(aV), dV = uV, Gf = jg, fV = qg, pV = xo, Ug = {};
pV(Gf, function(e, t) {
  Ug[Gf[t]] = t;
});
var mV = fV(Ug), gV = mV;
function hV(e, t, n) {
  return e.substring(t, n);
}
var Gg = hV;
function vV(e) {
  return e.toLowerCase();
}
var Kg = vV, bV = es, Dr = Gg, fi = kg, xV = Kg, vu = {};
function yV(e) {
  if (e = bV(e), vu[e])
    return vu[e];
  var t = e.length, n = e.replace(/([-]+)/g, function(s, i, l) {
    return l && l + i.length < t ? "-" : "";
  });
  return t = n.length, n = n.replace(/([A-Z]+)/g, function(s, i, l) {
    var a = i.length;
    return i = xV(i), l ? a > 2 && l + a < t ? fi(Dr(i, 0, 1)) + Dr(i, 1, a - 1) + fi(Dr(i, a - 1, a)) : fi(Dr(i, 0, 1)) + Dr(i, 1, a) : a > 1 && l + a < t ? Dr(i, 0, a - 1) + fi(Dr(i, a - 1, a)) : i;
  }).replace(/(-[a-zA-Z])/g, function(s, i) {
    return fi(Dr(i, 1, i.length));
  }), vu[e] = n, n;
}
var CV = yV, wV = es, ml = Gg, Or = Kg, bu = {};
function EV(e) {
  if (e = wV(e), bu[e])
    return bu[e];
  if (/^[A-Z]+$/.test(e))
    return Or(e);
  var t = e.replace(/^([a-z])([A-Z]+)([a-z]+)$/, function(n, s, i, l) {
    var a = i.length;
    return a > 1 ? s + "-" + Or(ml(i, 0, a - 1)) + "-" + Or(ml(i, a - 1, a)) + l : Or(s + "-" + i + l);
  }).replace(/^([A-Z]+)([a-z]+)?$/, function(n, s, i) {
    var l = s.length;
    return Or(ml(s, 0, l - 1) + "-" + ml(s, l - 1, l) + (i || ""));
  }).replace(/([a-z]?)([A-Z]+)([a-z]?)/g, function(n, s, i, l, a) {
    var c = i.length;
    return c > 1 && (s && (s += "-"), l) ? (s || "") + Or(ml(i, 0, c - 1)) + "-" + Or(ml(i, c - 1, c)) + l : (s || "") + (a ? "-" : "") + Or(i) + (l || "");
  });
  return t = t.replace(/([-]+)/g, function(n, s, i) {
    return i && i + s.length < t.length ? "-" : "";
  }), bu[e] = t, t;
}
var SV = EV, DV = es;
function OV(e, t, n) {
  var s = DV(e);
  return (arguments.length === 1 ? s : s.substring(n)).indexOf(t) === 0;
}
var TV = OV, MV = es;
function IV(e, t, n) {
  var s = MV(e), i = arguments.length;
  return i > 1 && (i > 2 ? s.substring(0, n).indexOf(t) === n - 1 : s.indexOf(t) === s.length - 1);
}
var VV = IV, PV = pr, kV = es, $V = Hg, RV = Hi;
function NV(e, t, n) {
  return kV(e).replace((n || PV).tmplRE || /\{{2}([.\w[\]\s]+)\}{2}/g, function(s, i) {
    return RV(t, $V(i));
  });
}
var Yg = NV, FV = Yg;
function LV(e, t) {
  return FV(e, t, { tmplRE: /\{([.\w[\]\s]+)\}/g });
}
var AV = LV;
function BV() {
}
var _V = BV, Kf = al;
function WV(e, t) {
  var n = Kf(arguments, 2);
  return function() {
    return e.apply(t, Kf(arguments).concat(n));
  };
}
var zV = WV, Yf = al;
function HV(e, t) {
  var n = !1, s = null, i = Yf(arguments, 2);
  return function() {
    return n || (s = e.apply(t, Yf(arguments).concat(i)), n = !0), s;
  };
}
var jV = HV, qV = al;
function UV(e, t, n) {
  var s = 0, i = [];
  return function() {
    var l = arguments;
    s++, s <= e && i.push(l[0]), s >= e && t.apply(n, [i].concat(qV(l)));
  };
}
var GV = UV, KV = al;
function YV(e, t, n) {
  var s = 0, i = [];
  return n = n || this, function() {
    var l = arguments;
    s++, s < e && (i.push(l[0]), t.apply(n, [i].concat(KV(l))));
  };
}
var XV = YV;
function ZV(e, t, n) {
  var s = null, i = null, l = n || {}, a = !1, c = null, m = "leading" in l ? l.leading : !0, u = "trailing" in l ? l.trailing : !1, d = function() {
    s = null, i = null;
  }, p = function() {
    a = !0, e.apply(i, s), c = setTimeout(w, t), d();
  }, w = function() {
    c = null, !a && u === !0 && p();
  }, v = function() {
    var S = c !== null;
    return S && clearTimeout(c), d(), c = null, a = !1, S;
  }, D = function() {
    s = arguments, i = this, a = !1, c === null && (m === !0 ? p() : u === !0 && (c = setTimeout(w, t)));
  };
  return D.cancel = v, D;
}
var JV = ZV;
function QV(e, t, n) {
  var s = null, i = null, l = n || {}, a = !1, c = null, m = typeof n == "boolean", u = "leading" in l ? l.leading : m, d = "trailing" in l ? l.trailing : !m, p = function() {
    s = null, i = null;
  }, w = function() {
    a = !0, e.apply(i, s), p();
  }, v = function() {
    u === !0 && (c = null), !a && d === !0 && w();
  }, D = function() {
    var x = c !== null;
    return x && clearTimeout(c), p(), c = null, a = !1, x;
  }, S = function() {
    a = !1, s = arguments, i = this, c === null ? u === !0 && w() : clearTimeout(c), c = setTimeout(v, t);
  };
  return S.cancel = D, S;
}
var eP = QV, tP = al;
function nP(e, t) {
  var n = tP(arguments, 2), s = this;
  return setTimeout(function() {
    e.apply(s, n);
  }, t);
}
var oP = nP, sP = decodeURIComponent, Xg = sP, Xf = Xg, rP = Qo, lP = hr;
function iP(e) {
  var t, n = {};
  return e && lP(e) && rP(e.split("&"), function(s) {
    t = s.split("="), n[Xf(t[0])] = Xf(t[1] || "");
  }), n;
}
var Zg = iP, aP = encodeURIComponent, Jg = aP, Oc = Jg, Qg = xo, eh = Gn, th = gr, cP = Gs, nh = Yl;
function oh(e, t, n) {
  var s, i = [];
  return Qg(e, function(l, a) {
    s = eh(l), nh(l) || s ? i = i.concat(oh(l, t + "[" + a + "]", s)) : i.push(Oc(t + "[" + (n ? "" : a) + "]") + "=" + Oc(th(l) ? "" : l));
  }), i;
}
function uP(e) {
  var t, n = [];
  return Qg(e, function(s, i) {
    cP(s) || (t = eh(s), nh(s) || t ? n = n.concat(oh(s, i, t)) : n.push(Oc(i) + "=" + Oc(th(s) ? "" : s)));
  }), n.join("&").replace(/%20/g, "+");
}
var dP = uP, fP = Ns, pP = typeof location === fP ? 0 : location, Wc = pP, fa = Wc;
function mP() {
  return fa ? fa.origin || fa.protocol + "//" + fa.host : "";
}
var sh = mP, Zf = Wc, gP = Zg, hP = sh;
function Jf(e) {
  return gP(e.split("?")[1] || "");
}
function vP(e) {
  var t, n, s, i, l = "" + e;
  return l.indexOf("//") === 0 ? l = (Zf ? Zf.protocol : "") + l : l.indexOf("/") === 0 && (l = hP() + l), s = l.replace(/#.*/, "").match(/(\?.*)/), i = {
    href: l,
    hash: "",
    host: "",
    hostname: "",
    protocol: "",
    port: "",
    search: s && s[1] && s[1].length > 1 ? s[1] : ""
  }, i.path = l.replace(/^([a-z0-9.+-]*:)\/\//, function(a, c) {
    return i.protocol = c, "";
  }).replace(/^([a-z0-9.+-]*)(:\d+)?\/?/, function(a, c, m) {
    return n = m || "", i.port = n.replace(":", ""), i.hostname = c, i.host = c + n, "/";
  }).replace(/(#.*)/, function(a, c) {
    return i.hash = c.length > 1 ? c : "", "";
  }), t = i.hash.match(/#((.*)\?|(.*))/), i.pathname = i.path.replace(/(\?|#.*).*/, ""), i.origin = i.protocol + "//" + i.host, i.hashKey = t && (t[2] || t[1]) || "", i.hashQuery = Jf(i.hash), i.searchQuery = Jf(i.search), i;
}
var rh = vP, Qf = Wc, bP = sh, xP = ig;
function yP() {
  if (Qf) {
    var e = Qf.pathname, t = xP(e, "/") + 1;
    return bP() + (t === e.length ? e : e.substring(0, t));
  }
  return "";
}
var CP = yP, ep = Wc, wP = rh;
function EP() {
  return ep ? wP(ep.href) : {};
}
var SP = EP, lh = pr, xu = fd, tp = Xg, np = Jg, DP = Gn, op = Rc, ih = _r, OP = Gs, TP = zi, MP = mr, Tc = Rs, yu = Qo, IP = Fc, pa = ys, VP = _c, PP = Xi, kP = Pg;
function sp(e, t) {
  var n = parseFloat(t), s = IP(), i = pa(s);
  switch (e) {
    case "y":
      return pa(VP(s, n));
    case "M":
      return pa(PP(s, n));
    case "d":
      return pa(kP(s, n));
    case "h":
    case "H":
      return i + n * 60 * 60 * 1e3;
    case "m":
      return i + n * 60 * 1e3;
    case "s":
      return i + n * 1e3;
  }
  return i;
}
function Cu(e) {
  return (ih(e) ? e : new Date(e)).toUTCString();
}
function Lr(e, t, n) {
  if (xu) {
    var s, i, l, a, c, m, u = [], d = arguments;
    return DP(e) ? u = e : d.length > 1 ? u = [Tc({ name: e, value: t }, n)] : op(e) && (u = [e]), u.length > 0 ? (yu(u, function(p) {
      s = Tc({}, lh.cookies, p), l = [], s.name && (i = s.expires, l.push(np(s.name) + "=" + np(op(s.value) ? JSON.stringify(s.value) : s.value)), i && (isNaN(i) ? i = i.replace(/^([0-9]+)(y|M|d|H|h|m|s)$/, function(w, v, D) {
        return Cu(sp(D, v));
      }) : /^[0-9]{11,13}$/.test(i) || ih(i) ? i = Cu(i) : i = Cu(sp("d", i)), s.expires = i), yu(["expires", "path", "domain", "secure"], function(w) {
        OP(s[w]) || l.push(s[w] && w === "secure" ? w : w + "=" + s[w]);
      })), xu.cookie = l.join("; ");
    }), !0) : (a = {}, c = xu.cookie, c && yu(c.split("; "), function(p) {
      m = p.indexOf("="), a[tp(p.substring(0, m))] = tp(p.substring(m + 1) || "");
    }), d.length === 1 ? a[e] : a);
  }
  return !1;
}
function $P(e) {
  return TP(ah(), e);
}
function rp(e) {
  return Lr(e);
}
function lp(e, t, n) {
  return Lr(e, t, n), Lr;
}
function ip(e, t) {
  Lr(e, "", Tc({ expires: -1 }, lh.cookies, t));
}
function ah() {
  return MP(Lr());
}
function RP() {
  return Lr();
}
Tc(Lr, {
  has: $P,
  set: lp,
  setItem: lp,
  get: rp,
  getItem: rp,
  remove: ip,
  removeItem: ip,
  keys: ah,
  getJSON: RP
});
var NP = Lr, FP = Ns, wu = fd, Eu = mg, LP = Rs, AP = Qo;
function ap(e) {
  try {
    var t = "__xe_t";
    return e.setItem(t, 1), e.removeItem(t), !0;
  } catch {
    return !1;
  }
}
function ma(e) {
  return navigator.userAgent.indexOf(e) > -1;
}
function BP() {
  var e, t, n, s = !1, i = !1, l = !1, a = {
    isNode: !1,
    isMobile: s,
    isPC: !1,
    isDoc: !!wu
  };
  if (!Eu && typeof process !== FP)
    a.isNode = !0;
  else {
    n = ma("Edge"), t = ma("Chrome"), s = /(Android|webOS|iPhone|iPad|iPod|SymbianOS|BlackBerry|Windows Phone)/.test(navigator.userAgent), a.isDoc && (e = wu.body || wu.documentElement, AP(["webkit", "khtml", "moz", "ms", "o"], function(c) {
      a["-" + c] = !!e[c + "MatchesSelector"];
    }));
    try {
      i = ap(Eu.localStorage);
    } catch {
    }
    try {
      l = ap(Eu.sessionStorage);
    } catch {
    }
    LP(a, {
      edge: n,
      firefox: ma("Firefox"),
      msie: !n && a["-ms"],
      safari: !t && !n && ma("Safari"),
      isMobile: s,
      isPC: !s,
      isLocalStorage: i,
      isSessionStorage: l
    });
  }
  return a;
}
var _P = BP, ch = px, cp = Rs, WP = Wi, zP = Sm, HP = Dx, jP = Ix, qP = Xl, UP = Om, GP = Tm, KP = Mm, YP = Qo, XP = id, ZP = Im, JP = Zx, QP = ad, ek = My, tk = ud, nk = $m, ok = Ly, sk = al, rk = jy, lk = Gy, ik = zi, ak = Xy, ck = eC, uk = oC, dk = lC, fk = cC, pk = SC, mk = Am, gk = MC, hk = PC, vk = Nm, bk = FC, xk = hw, yk = Cw, Ck = Dw, wk = Km, Ek = kw, Sk = Nw, Dk = _w, Ok = Zm, Tk = Jm, Mk = $s, Ik = Gn, Vk = gr, Pk = Gw, kk = Gs, $k = fs, Rk = Rc, Nk = hr, Fk = Yl, Lk = rg, Ak = _r, Bk = Br, _k = xo, Wk = xE, zk = EE, Hk = PE, jk = ig, qk = mr, Uk = Zl, Gk = ld, Kk = ag, Yk = zm, Xk = jm, Zk = Hm, Jk = WE, Qk = YE, e$ = cg, t$ = ug, n$ = Ks, o$ = dd, s$ = dg, r$ = oS, l$ = fg, i$ = pg, a$ = uS, c$ = mS, u$ = xS, d$ = SS, f$ = MS, p$ = kS, m$ = FS, g$ = _S, h$ = jS, v$ = dD, b$ = xg, x$ = gD, y$ = ED, C$ = OD, w$ = pd, E$ = ID, S$ = $D, D$ = FD, O$ = BD, T$ = GD, M$ = XD, I$ = QD, V$ = nO, P$ = lO, k$ = Hi, $$ = dO, R$ = Cg, N$ = wO, F$ = SO, L$ = VO, A$ = km, B$ = Lm, _$ = $O, W$ = mT, z$ = gd, H$ = Sg, j$ = Dg, q$ = hd, U$ = bT, G$ = il, K$ = Wr, Y$ = ST, X$ = TT, Z$ = vd, J$ = kT, Q$ = Mg, eR = zT, tR = _c, nR = pM, oR = Xi, sR = Pg, rR = ps, lR = Bg, iR = _g, aR = yI, cR = Cs, uR = wI, dR = Rg, fR = Lg, pR = Fg, mR = DI, gR = PI, hR = AI, vR = WI, bR = UI, xR = Ag, yR = XI, CR = Hg, wR = Wg, ER = zg, SR = dV, DR = gV, OR = CV, TR = SV, MR = TV, IR = VV, VR = Yg, PR = AV, up = es, kR = _V, $R = Kl, RR = zV, NR = jV, FR = GV, LR = XV, AR = JV, BR = eP, _R = oP, WR = Zg, zR = dP, HR = rh, jR = CP, qR = SP, UR = NP, GR = _P;
cp(ch, {
  // object
  assign: cp,
  objectEach: WP,
  lastObjectEach: zP,
  objectMap: HP,
  merge: jP,
  // array
  uniq: ZP,
  union: JP,
  sortBy: ek,
  orderBy: tk,
  shuffle: nk,
  sample: ok,
  some: UP,
  every: GP,
  slice: sk,
  filter: rk,
  find: ak,
  findLast: ck,
  findKey: lk,
  includes: ik,
  arrayIndexOf: Ok,
  arrayLastIndexOf: Tk,
  map: qP,
  reduce: uk,
  copyWithin: dk,
  chunk: fk,
  zip: pk,
  unzip: mk,
  zipObject: gk,
  flatten: hk,
  toArray: QP,
  includeArrays: KP,
  pluck: vk,
  invoke: bk,
  arrayEach: YP,
  lastArrayEach: XP,
  toArrayTree: xk,
  toTreeArray: yk,
  findTree: Ck,
  eachTree: wk,
  mapTree: Ek,
  filterTree: Sk,
  searchTree: Dk,
  // base
  hasOwnProp: Mk,
  eqNull: Bk,
  isNaN: Pk,
  isFinite: Jk,
  isUndefined: kk,
  isArray: Ik,
  isFloat: Qk,
  isInteger: e$,
  isFunction: $k,
  isBoolean: t$,
  isString: Nk,
  isNumber: n$,
  isRegExp: o$,
  isObject: Rk,
  isPlainObject: Fk,
  isDate: Ak,
  isError: s$,
  isTypeError: r$,
  isEmpty: l$,
  isNull: Vk,
  isSymbol: i$,
  isArguments: a$,
  isElement: c$,
  isDocument: u$,
  isWindow: d$,
  isFormData: f$,
  isMap: p$,
  isWeakMap: m$,
  isSet: g$,
  isWeakSet: h$,
  isLeapYear: Lk,
  isMatch: v$,
  isEqual: b$,
  isEqualWith: x$,
  getType: y$,
  uniqueId: C$,
  getSize: Kk,
  indexOf: Hk,
  lastIndexOf: jk,
  findIndexOf: w$,
  findLastIndexOf: E$,
  toStringJSON: S$,
  toJSONString: D$,
  keys: qk,
  values: Uk,
  entries: O$,
  pick: T$,
  omit: M$,
  first: I$,
  last: V$,
  each: _k,
  forOf: Wk,
  lastForOf: zk,
  lastEach: Yk,
  has: P$,
  get: k$,
  set: $$,
  groupBy: R$,
  countBy: N$,
  clone: Gk,
  clear: Zk,
  remove: Xk,
  range: F$,
  destructuring: L$,
  // number
  random: A$,
  min: _$,
  max: B$,
  commafy: W$,
  round: z$,
  ceil: H$,
  floor: j$,
  toFixed: q$,
  toNumber: G$,
  toNumberString: K$,
  toInteger: U$,
  add: Y$,
  subtract: X$,
  multiply: Z$,
  divide: J$,
  sum: Q$,
  mean: eR,
  // date
  now: iR,
  timestamp: aR,
  isValidDate: cR,
  isDateSame: uR,
  toStringDate: rR,
  toDateString: lR,
  getWhatYear: tR,
  getWhatQuarter: nR,
  getWhatMonth: oR,
  getWhatWeek: dR,
  getWhatDay: sR,
  getYearDay: fR,
  getYearWeek: pR,
  getMonthWeek: mR,
  getDayOfYear: gR,
  getDayOfMonth: hR,
  getDateDiff: vR,
  // string
  trim: CR,
  trimLeft: ER,
  trimRight: wR,
  escape: SR,
  unescape: DR,
  camelCase: OR,
  kebabCase: TR,
  repeat: yR,
  padStart: xR,
  padEnd: bR,
  startsWith: MR,
  endsWith: IR,
  template: VR,
  toFormatString: PR,
  toString: up,
  toValueString: up,
  // function
  noop: kR,
  property: $R,
  bind: RR,
  once: NR,
  after: FR,
  before: LR,
  throttle: AR,
  debounce: BR,
  delay: _R,
  // url
  unserialize: WR,
  serialize: zR,
  parseUrl: HR,
  // web
  getBaseURL: jR,
  locat: qR,
  browse: GR,
  cookie: UR
});
var KR = ch;
const r = /* @__PURE__ */ Ib(KR);
var kl = null, Su = null, Tr = null, dp = "z-index-manage", Gr = null, fp = "z-index-style", uh = "m", dh = "s", Li = {
  m: 1e3,
  s: 1e3
};
function bd() {
  return kl || typeof document < "u" && (kl = document), kl;
}
function fh() {
  return kl && !Su && (Su = kl.body || kl.getElementsByTagName("body")[0]), Su;
}
function YR() {
  var e = 0, t = bd();
  if (t) {
    var n = fh();
    if (n)
      for (var s = n.getElementsByTagName("*"), i = 0; i < s.length; i++) {
        var l = s[i];
        if (l && l.style && l.nodeType === 1) {
          var a = l.style.zIndex;
          a && /^\d+$/.test(a) && (e = Math.max(e, Number(a)));
        }
      }
  }
  return e;
}
function XR() {
  if (!Gr) {
    var e = bd();
    e && (Gr = e.getElementById(fp), Gr || (Gr = e.createElement("style"), Gr.id = fp, e.getElementsByTagName("head")[0].appendChild(Gr)));
  }
  return Gr;
}
function ph() {
  var e = XR();
  if (e) {
    var t = "--dom-", n = "-z-index";
    e.innerHTML = ":root{" + t + "main" + n + ":" + zc() + ";" + t + "sub" + n + ":" + Cd() + "}";
  }
}
function mh() {
  if (!Tr) {
    var e = bd();
    if (e && (Tr = e.getElementById(dp), !Tr)) {
      var t = fh();
      t && (Tr = e.createElement("div"), Tr.id = dp, Tr.style.display = "none", t.appendChild(Tr), xd(Li.m), yd(Li.s));
    }
  }
  return Tr;
}
function gh(e) {
  return function(t) {
    if (t) {
      t = Number(t), Li[e] = t;
      var n = mh();
      n && (n.dataset ? n.dataset[e] = t + "" : n.setAttribute("data-" + e, t + ""));
    }
    return ph(), Li[e];
  };
}
var xd = gh(uh);
function hh(e, t) {
  return function(s) {
    var i, l = mh();
    if (l) {
      var a = l.dataset ? l.dataset[e] : l.getAttribute("data-" + e);
      a && (i = Number(a));
    }
    return i || (i = Li[e]), s ? Number(s) < i ? t() : s : i;
  };
}
var zc = hh(uh, vh);
function vh() {
  return xd(zc() + 1);
}
var yd = gh(dh), bh = hh(dh, xh);
function Cd() {
  return zc() + bh();
}
function xh() {
  return yd(bh() + 1), Cd();
}
var Zi = {
  setCurrent: xd,
  getCurrent: zc,
  getNext: vh,
  setSubCurrent: yd,
  getSubCurrent: Cd,
  getSubNext: xh,
  getMax: YR
};
ph();
const jl = {
  size: "",
  version: 1,
  zIndex: 999,
  resizeInterval: 500
}, yh = {
  theme: ""
};
function Hc(e) {
  const t = !e || e === "default" ? "light" : e;
  if (yh.theme = t, typeof document < "u") {
    const n = document.documentElement;
    n && n.setAttribute("data-vxe-ui-theme", t);
  }
  return ll;
}
function ZR() {
  return yh.theme;
}
function jc(e) {
  return e && (e.zIndex && Zi.setCurrent(e.zIndex), e.theme && Hc(e.theme), r.merge(jl, e)), ll;
}
function oe(e, t) {
  return arguments.length ? r.get(jl, e, t) : jl;
}
const JR = {}, Xu = {};
function Ch(e) {
  return e && Object.assign(Xu, e), ll;
}
function ht(e) {
  return arguments.length ? r.get(Xu, e) : Xu;
}
const Yt = {
  F2: "F2",
  ESCAPE: "Escape",
  ENTER: "Enter",
  TAB: "Tab",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  SPACEBAR: " ",
  CONTEXT_MENU: "ContextMenu",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  R: "R",
  P: "P",
  Z: "Z",
  X: "X",
  C: "C",
  V: "V",
  M: "M"
}, Zu = r.browse(), pp = {
  " ": "Spacebar",
  Apps: Yt.CONTEXT_MENU,
  Del: Yt.DELETE,
  Up: Yt.ARROW_UP,
  Down: Yt.ARROW_DOWN,
  Left: Yt.ARROW_LEFT,
  Right: Yt.ARROW_RIGHT
}, wh = Zu.firefox ? "DOMMouseScroll" : "mousewheel", Ju = [];
function tr(e) {
  const t = e.type === wh;
  Ju.forEach(({ type: n, cb: s }) => {
    e.cancelBubble || (n === e.type || t && n === "mousewheel") && s(e);
  });
}
class QR {
  constructor(t, n, s) {
    Object.defineProperty(this, "$event", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.$event = t, Object.assign(this, n, s);
  }
  stopPropagation() {
    const t = this.$event;
    t && t.stopPropagation();
  }
  preventDefault() {
    const t = this.$event;
    t && t.preventDefault();
  }
}
const Zt = (e, t, n) => new QR(e, t, n), ut = {
  on(e, t, n) {
    Ju.push({ comp: e, type: t, cb: n });
  },
  off(e, t) {
    r.remove(Ju, (n) => n.comp === e && n.type === t);
  },
  hasKey(e, t) {
    const { key: n } = e;
    return t = t.toLowerCase(), n ? t === n.toLowerCase() || !!(pp[n] && pp[n].toLowerCase() === t) : !1;
  }
};
Zu.isDoc && (Zu.msie || (window.addEventListener("copy", tr, !1), window.addEventListener("cut", tr, !1), window.addEventListener("paste", tr, !1)), document.addEventListener("keydown", tr, !1), document.addEventListener("contextmenu", tr, !1), window.addEventListener("mousedown", tr, !1), window.addEventListener("blur", tr, !1), window.addEventListener("resize", tr, !1), window.addEventListener(wh, r.throttle(tr, 100, { leading: !0, trailing: !1 }), { passive: !0, capture: !1 }));
let mp;
const Xr = [], eN = 500;
function tN() {
  Xr.length && (Xr.forEach((e) => {
    e.tarList.forEach((t) => {
      const { target: n, width: s, heighe: i } = t, l = n.clientWidth, a = n.clientHeight;
      (l && s !== l || a && i !== a) && (t.width = l, t.heighe = a, setTimeout(e.callback));
    });
  }), Eh());
}
function Eh() {
  clearTimeout(mp), mp = setTimeout(tN, jl.resizeInterval || eN);
}
class nN {
  constructor(t) {
    Object.defineProperty(this, "tarList", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "callback", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.callback = t;
  }
  observe(t) {
    if (t) {
      const { tarList: n } = this;
      n.some((s) => s.target === t) || n.push({
        target: t,
        width: t.clientWidth,
        heighe: t.clientHeight
      }), Xr.length || Eh(), Xr.some((s) => s === this) || Xr.push(this);
    }
  }
  unobserve(t) {
    r.remove(Xr, (n) => n.tarList.some((s) => s.target === t));
  }
  disconnect() {
    r.remove(Xr, (t) => t === this);
  }
}
const Sh = {
  create(e) {
    return window.ResizeObserver ? new window.ResizeObserver(e) : new nN(e);
  }
}, Ji = Rt({
  language: "",
  langMaps: {}
});
let gp = !1;
function Pe(e, t) {
  const { langMaps: n, language: s } = Ji, { i18n: i } = jl;
  return i ? `${i(e, t) || ""}` : (gp || (n[s] || console.error(`[vxe core] 语言包未安装。Language not installed. https://${ll.uiVersion ? "vxeui.com" : "vxetable.cn"}/#/start/i18n`), gp = !0), r.toFormatString(r.get(n[s], e, e), t));
}
function Dh(e) {
  return Ji.language = e || "zh-CN", ll;
}
function Oh(e, t) {
  return Ji.langMaps[e] = Object.assign({}, t), ll;
}
function oN(e) {
  const { langMaps: t } = Ji;
  return !!t[e];
}
function sN() {
  const { language: e } = Ji;
  return e;
}
function Du(e, t) {
  return function(n, s) {
    const i = `[vxe ${t || ""}] ${Pe(n, s)}`;
    return console[e](i), i;
  };
}
const hp = "4.0.20", bs = {
  create: Du,
  warn: Du("warn", `v${hp}`),
  err: Du("error", `v${hp}`)
}, pi = {}, Cn = {
  mixin(e) {
    return r.each(e, (t, n) => Cn.add(n, t)), Cn;
  },
  get(e) {
    return pi[e] || null;
  },
  add(e, t) {
    if (e && t) {
      const n = pi[e];
      n ? (process.env.NODE_ENV === "development" && r.each(t, (s, i) => {
        !r.eqNull(n[i]) && n[i] !== s && bs.warn("vxe.error.coverProp", [`Renderer.${e}`, i]);
      }), Object.assign(n, t)) : pi[e] = t;
    }
    return Cn;
  },
  forEach(e) {
    return r.objectEach(pi, e), Cn;
  },
  delete(e) {
    return delete pi[e], Cn;
  }
};
class Th {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  mixin(t) {
    return r.each(t, (n, s) => {
      this.add(s, n);
    }), this;
  }
  has(t) {
    return !!this.get(t);
  }
  get(t) {
    return this.store[t];
  }
  add(t, n) {
    const s = this.store[t];
    if (process.env.NODE_ENV === "development") {
      const i = r.keys(s);
      r.each(n, (l, a) => {
        i.includes(a) && bs.warn("vxe.error.coverProp", [t, a]);
      });
    }
    return this.store[t] = s ? r.merge(s, n) : n, this;
  }
  delete(t) {
    delete this.store[t];
  }
  forEach(t) {
    r.objectEach(this.store, t);
  }
}
const wd = new Th();
process.env.NODE_ENV === "development" && Object.assign(wd, { _name: "Validators" });
class rN {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  mixin(t) {
    return r.each(t, (n, s) => {
      this.add(s, n);
    }), this;
  }
  has(t) {
    return !!this.get(t);
  }
  get(t) {
    return this.store[t];
  }
  add(t, n) {
    const s = this.store[t];
    if (r.isFunction(n) && (process.env.NODE_ENV === "development" && bs.warn("vxe.error.delProp", ["menus -> callback", "menuMethod"]), n = {
      menuMethod: n
    }), process.env.NODE_ENV === "development") {
      const i = r.keys(s);
      r.each(n, (l, a) => {
        i.includes(a) && bs.warn("vxe.error.coverProp", [t, a]);
      });
    }
    return this.store[t] = s ? r.merge(s, n) : n, this;
  }
  delete(t) {
    delete this.store[t];
  }
  forEach(t) {
    r.objectEach(this.store, t);
  }
}
const Mh = new rN();
process.env.NODE_ENV === "development" && Object.assign(Mh, { _name: "Menus" });
class lN {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  mixin(t) {
    return r.each(t, (n, s) => {
      this.add(s, n);
    }), this;
  }
  has(t) {
    return !!this.get(t);
  }
  get(t) {
    return this.store[t];
  }
  add(t, n) {
    const s = this.store[t];
    if (r.isFunction(n) && (process.env.NODE_ENV === "development" && bs.warn("vxe.error.delProp", ["formats -> callback", "cellFormatMethod"]), n = {
      cellFormatMethod: n
    }), process.env.NODE_ENV === "development") {
      const i = r.keys(s);
      r.each(n, (l, a) => {
        i.includes(a) && bs.warn("vxe.error.coverProp", [t, a]);
      });
    }
    return this.store[t] = s ? r.merge(s, n) : n, this;
  }
  delete(t) {
    delete this.store[t];
  }
  forEach(t) {
    r.objectEach(this.store, t);
  }
}
const Ih = new lN();
process.env.NODE_ENV === "development" && Object.assign(Ih, { _name: "Formats" });
class iN {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  mixin(t) {
    return r.each(t, (n, s) => {
      this.add(s, n);
    }), this;
  }
  has(t) {
    return !!this.get(t);
  }
  get(t) {
    return this.store[t];
  }
  add(t, n) {
    const s = this.store[t];
    if (r.isFunction(n) && (process.env.NODE_ENV === "development" && bs.warn("vxe.error.delProp", ["commands -> callback", "commandMethod"]), n = {
      commandMethod: n
    }), process.env.NODE_ENV === "development") {
      const i = r.keys(s);
      r.each(n, (l, a) => {
        i.includes(a) && bs.warn("vxe.error.coverProp", [t, a]);
      });
    }
    return this.store[t] = s ? r.merge(s, n) : n, this;
  }
  delete(t) {
    delete this.store[t];
  }
  forEach(t) {
    r.objectEach(this.store, t);
  }
}
const Vh = new iN();
process.env.NODE_ENV === "development" && Object.assign(Vh, { _name: "Commands" });
const mi = {}, Ia = {
  mixin(e) {
    return r.each(e, (t, n) => {
      Ia.add(n, t);
    }), Ia;
  },
  get(e) {
    return mi[e] || [];
  },
  add(e, t) {
    r.isFunction(t) && (t = {
      tableInterceptorMethod: t
    });
    const n = t.tableInterceptorMethod;
    if (n) {
      let s = mi[e];
      s || (s = mi[e] = []), process.env.NODE_ENV === "development" && s.indexOf(n) > -1 && bs.warn("vxe.error.coverProp", ["Interceptor", e]), s.push(n);
    }
    return Ia;
  },
  delete(e, t) {
    const n = mi[e];
    if (n) {
      r.isFunction(t) && (t = {
        tableInterceptorMethod: t
      });
      const s = t ? t.tableInterceptorMethod : null;
      s ? r.remove(n, (i) => i === s) : delete mi[e];
    }
  }
};
let Hs;
const ga = {
  text: "",
  html: ""
};
function aN(e) {
  if (!Hs) {
    Hs = document.createElement("textarea"), Hs.id = "$VxeCopy";
    const t = Hs.style;
    t.width = "48px", t.height = "24px", t.position = "fixed", t.zIndex = "0", t.left = "-500px", t.top = "-500px", document.body.appendChild(Hs);
  }
  Hs.value = e;
}
const cN = {
  getStore() {
    return ga;
  },
  setStore(e) {
    Object.assign(ga, e || {});
  },
  /**
   * 复制内容到剪贴板
   *
   * @param {String} content Text 内容
   */
  copy(e) {
    let t = !1;
    try {
      const n = r.toValueString(e);
      aN(n), Hs.select(), Hs.setSelectionRange(0, Hs.value.length), t = document.execCommand("copy"), Hs.blur(), ga.text = n, ga.html = "";
    } catch {
    }
    return t;
  }
};
function Va(e, t) {
  let n = !0, s = !1;
  const i = t || jl.permissionMethod;
  if (e && i) {
    n = !1, s = !0;
    let a = !1, c = !1;
    const m = String(e).split("|");
    for (let u = 0; u < m.length; u++) {
      const d = m[u];
      let p = !0, w = !1;
      const v = i({ code: d });
      if (r.isBoolean(v) ? p = v : v && (p = !!v.visible, w = !!v.disabled), !w && !c && (c = !0, s = w), p && !a && (a = !0, n = p), a && c)
        break;
    }
  }
  return {
    code: e,
    visible: n,
    disabled: s
  };
}
const Ai = {
  getCheckInfo(e) {
    return Va(e);
  },
  checkVisible(e) {
    return Va(e).visible;
  },
  checkDisable(e) {
    return Va(e).disabled;
  }
}, uN = new Th();
function dn(e) {
  const t = mt("xeSizeInfo", null), n = _(() => e.size || (t ? t.value : null));
  return bn("xeSizeInfo", n), { computeSize: n };
}
function Qi(e) {
  return {
    computePermissionInfo: _(() => Va(e.permissionCode, e.permissionMethod))
  };
}
const dN = {
  useSize: dn,
  usePermission: Qi
}, vp = [];
function fN(e, t) {
  return e && e.install && vp.indexOf(e) === -1 && (e.install(Ce, t), vp.push(e)), Ce;
}
const Ph = {};
function pN(e) {
  return Ph[e] || null;
}
function mN(e) {
  e && e.name && (Ph[e.name] = e);
}
function Yn() {
  return Ve();
}
const Ce = Object.assign(ll, {
  renderEmptyElement: Yn,
  setTheme: Hc,
  getTheme: ZR,
  setConfig: jc,
  getConfig: oe,
  setIcon: Ch,
  getIcon: ht,
  setLanguage: Dh,
  hasLanguage: oN,
  getLanguage: sN,
  setI18n: Oh,
  getI18n: Pe,
  globalEvents: ut,
  GLOBAL_EVENT_KEYS: Yt,
  createEvent: Zt,
  globalResize: Sh,
  renderer: Cn,
  validators: wd,
  menus: Mh,
  formats: Ih,
  commands: Vh,
  interceptor: Ia,
  clipboard: cN,
  log: bs,
  permission: Ai,
  globalStore: JR,
  hooks: uN,
  component: mN,
  getComponent: pN,
  useFns: dN,
  use: fN
});
Hc();
function fn(e) {
  return e && e.enabled !== !1;
}
function kh(e) {
  return e == null || e === "";
}
function $h(e) {
  const t = e.name, n = r.lastIndexOf(t, "."), s = t.substring(n + 1, t.length).toLowerCase();
  return { filename: t.substring(0, n), type: s };
}
function Rh() {
  return Zi.getNext();
}
function Nh() {
  return Zi.getCurrent();
}
function Tl(e) {
  return e && e.children && e.children.length > 0;
}
function fr(e, t) {
  if (e) {
    const n = Ce.getConfig().translate;
    return r.toValueString(n ? n("" + e, t) : e);
  }
  return "";
}
function po(e, t) {
  return "" + (kh(e) ? t ? Ce.getConfig().emptyCell : "" : e);
}
function cr(e) {
  return e === "" || r.eqNull(e);
}
const Fh = "4.9.19";
Ce.version = Fh;
Ce.tableVersion = Fh;
Ce.setConfig({
  emptyCell: "　",
  table: {
    fit: !0,
    showHeader: !0,
    animat: !0,
    delayHover: 250,
    autoResize: !0,
    padding: !0,
    minHeight: 144,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '暂无数据',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 行数据的唯一主键字段名
    // },
    resizeConfig: {
      // refreshDelay: 250
    },
    resizableConfig: {
      dragMode: "auto",
      showDragTip: !0
    },
    radioConfig: {
      // trigger: 'default'
      strict: !0
    },
    rowDragConfig: {
      showIcon: !0
    },
    columnDragConfig: {
      showIcon: !0
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: !0
    },
    tooltipConfig: {
      enterable: !0
    },
    validConfig: {
      showMessage: !0,
      autoClear: !0,
      autoPos: !0,
      message: "inline",
      msgMode: "single",
      theme: "beautify"
    },
    columnConfig: {
      maxFixedSize: 4
    },
    // menuConfig: {
    //   visibleMethod () {}
    // },
    customConfig: {
      // enabled: false,
      storage: !0,
      allowVisible: !0,
      allowResizable: !0,
      allowFixed: !0,
      allowSort: !0,
      showFooter: !0,
      placement: "top-right",
      //  storage: false,
      //  checkMethod () {},
      modalOptions: {
        showMaximize: !0,
        mask: !0,
        lockView: !0,
        resize: !0,
        escClosable: !0
      },
      drawerOptions: {
        mask: !0,
        lockView: !0,
        escClosable: !0,
        resize: !0
      }
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: !0,
      iconLayout: "vertical"
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      showIcon: !0
    },
    treeConfig: {
      rowField: "id",
      parentField: "parentId",
      childrenField: "children",
      hasChildField: "hasChild",
      mapChildrenField: "_X_ROW_CHILD",
      indent: 20,
      showIcon: !0
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: !0
    },
    editConfig: {
      // mode: 'cell',
      showIcon: !0,
      showAsterisk: !0,
      autoFocus: !0
    },
    importConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    exportConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    printConfig: {},
    mouseConfig: {
      extension: !0
    },
    keyboardConfig: {
      isEsc: !0
    },
    areaConfig: {
      autoClear: !0,
      selectCellByHeader: !0,
      selectCellByBody: !0
    },
    clipConfig: {
      isCopy: !0,
      isCut: !0,
      isPaste: !0
    },
    fnrConfig: {
      isFind: !0,
      isReplace: !0
    },
    scrollX: {
      // enabled: false,
      gt: 60
      // oSize: 0
    },
    scrollY: {
      // enabled: false,
      gt: 100
      // oSize: 0
    }
  },
  // export: {
  //   types: {}
  // },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: !0
    },
    pagerConfig: {
      enabled: !0
      // perfect: false
    },
    toolbarConfig: {
      enabled: !0
      // perfect: false
    },
    proxyConfig: {
      enabled: !0,
      autoLoad: !0,
      showResponseMsg: !0,
      showActiveMsg: !0,
      props: {
        list: null,
        result: "result",
        total: "page.total",
        message: "message"
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  }
});
const Tn = "vxe-table-icon-";
Ce.setIcon({
  // table
  TABLE_SORT_ASC: Tn + "caret-up",
  TABLE_SORT_DESC: Tn + "caret-down",
  TABLE_FILTER_NONE: Tn + "funnel",
  TABLE_FILTER_MATCH: Tn + "funnel",
  TABLE_EDIT: Tn + "edit",
  TABLE_TITLE_PREFIX: Tn + "question-circle-fill",
  TABLE_TITLE_SUFFIX: Tn + "question-circle-fill",
  TABLE_TREE_LOADED: Tn + "spinner roll",
  TABLE_TREE_OPEN: Tn + "caret-right rotate90",
  TABLE_TREE_CLOSE: Tn + "caret-right",
  TABLE_EXPAND_LOADED: Tn + "spinner roll",
  TABLE_EXPAND_OPEN: Tn + "arrow-right rotate90",
  TABLE_EXPAND_CLOSE: Tn + "arrow-right",
  TABLE_CHECKBOX_CHECKED: Tn + "checkbox-checked-fill",
  TABLE_CHECKBOX_UNCHECKED: Tn + "checkbox-unchecked",
  TABLE_CHECKBOX_INDETERMINATE: Tn + "checkbox-indeterminate-fill",
  TABLE_RADIO_CHECKED: Tn + "radio-checked-fill",
  TABLE_RADIO_UNCHECKED: Tn + "radio-unchecked",
  TABLE_CUSTOM_SORT: Tn + "drag-handle",
  TABLE_MENU_OPTIONS: Tn + "arrow-right",
  TABLE_DRAG_ROW: Tn + "drag-handle",
  TABLE_DRAG_COLUMN: Tn + "drag-handle",
  TABLE_DRAG_STATUS_ROW: Tn + "sort",
  TABLE_DRAG_STATUS_COLUMN: Tn + "swap",
  TABLE_DRAG_DISABLED: Tn + "no-drop",
  // toolbar
  TOOLBAR_TOOLS_REFRESH: Tn + "repeat",
  TOOLBAR_TOOLS_REFRESH_LOADING: Tn + "repeat roll",
  TOOLBAR_TOOLS_IMPORT: Tn + "upload",
  TOOLBAR_TOOLS_EXPORT: Tn + "download",
  TOOLBAR_TOOLS_PRINT: Tn + "print",
  TOOLBAR_TOOLS_FULLSCREEN: Tn + "fullscreen",
  TOOLBAR_TOOLS_MINIMIZE: Tn + "minimize",
  TOOLBAR_TOOLS_CUSTOM: Tn + "custom-column",
  TOOLBAR_TOOLS_FIXED_LEFT: Tn + "fixed-left",
  TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE: Tn + "fixed-left-fill",
  TOOLBAR_TOOLS_FIXED_RIGHT: Tn + "fixed-right",
  TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE: Tn + "fixed-right-fill"
});
Ce.setTheme;
Ce.getTheme;
Ce.setConfig;
Ce.getConfig;
Ce.setIcon;
Ce.getIcon;
Ce.setLanguage;
Ce.setI18n;
Ce.getI18n;
Ce.globalEvents;
Ce.globalResize;
Ce.renderer;
Ce.validators;
Ce.menus;
Ce.formats;
Ce.commands;
Ce.interceptor;
Ce.clipboard;
Ce.log;
Ce.hooks;
Ce.use;
const gN = (e) => Ce.setConfig(e);
Ce.setup = gN;
const hN = (e) => Ce.setConfig(e);
Ce.config = hN;
const vN = (e, t) => Ce.getI18n(e, t);
Ce.t = vN;
const bN = (e, t) => fr(e, t);
Ce._t = bN;
const { log: Lh } = Ce, Ah = "table v4.9.19", rn = Lh.create("warn", Ah), Ut = Lh.create("error", Ah), { getI18n: xN, formats: bp } = Ce;
class Qu {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor(t, n, { renderHeader: s, renderCell: i, renderFooter: l, renderData: a } = {}) {
    const c = t.xegrid, m = n.formatter, u = r.isBoolean(n.visible) ? n.visible : !0, { props: d } = t;
    if (process.env.NODE_ENV === "development") {
      const p = ["seq", "checkbox", "radio", "expand", "html"];
      if (n.type && p.indexOf(n.type) === -1 && rn("vxe.error.errProp", [`type=${n.type}`, p.join(", ")]), (r.isBoolean(n.cellRender) || n.cellRender && !r.isObject(n.cellRender)) && rn("vxe.error.errProp", [`column.cell-render=${n.cellRender}`, "column.cell-render={}"]), (r.isBoolean(n.editRender) || n.editRender && !r.isObject(n.editRender)) && rn("vxe.error.errProp", [`column.edit-render=${n.editRender}`, "column.edit-render={}"]), n.cellRender && n.editRender && rn("vxe.error.errConflicts", ["column.cell-render", "column.edit-render"]), n.type === "expand") {
        const { treeConfig: w } = d, { computeTreeOpts: v } = t.getComputeMaps(), D = v.value;
        w && (D.showLine || D.line) && Ut("vxe.error.errConflicts", ["tree-config.showLine", "column.type=expand"]);
      }
      if (m) {
        if (r.isString(m)) {
          const w = bp.get(m) || r[m];
          (!w || !r.isFunction(w.tableCellFormatMethod || w.cellFormatMethod)) && Ut("vxe.error.notFormats", [m]);
        } else if (r.isArray(m)) {
          const w = bp.get(m[0]) || r[m[0]];
          (!w || !r.isFunction(w.tableCellFormatMethod || w.cellFormatMethod)) && Ut("vxe.error.notFormats", [m[0]]);
        }
      }
    }
    if (Object.assign(this, {
      // 基本属性
      type: n.type,
      property: n.field,
      field: n.field,
      title: n.title,
      width: n.width,
      minWidth: n.minWidth,
      maxWidth: n.maxWidth,
      resizable: n.resizable,
      fixed: n.fixed,
      align: n.align,
      headerAlign: n.headerAlign,
      footerAlign: n.footerAlign,
      showOverflow: n.showOverflow,
      showHeaderOverflow: n.showHeaderOverflow,
      showFooterOverflow: n.showFooterOverflow,
      className: n.className,
      headerClassName: n.headerClassName,
      footerClassName: n.footerClassName,
      formatter: m,
      footerFormatter: n.footerFormatter,
      sortable: n.sortable,
      sortBy: n.sortBy,
      sortType: n.sortType,
      filters: zh(n.filters),
      filterMultiple: r.isBoolean(n.filterMultiple) ? n.filterMultiple : !0,
      filterMethod: n.filterMethod,
      filterResetMethod: n.filterResetMethod,
      filterRecoverMethod: n.filterRecoverMethod,
      filterRender: n.filterRender,
      treeNode: n.treeNode,
      dragSort: n.dragSort,
      cellType: n.cellType,
      cellRender: n.cellRender,
      editRender: n.editRender,
      contentRender: n.contentRender,
      headerExportMethod: n.headerExportMethod,
      exportMethod: n.exportMethod,
      footerExportMethod: n.footerExportMethod,
      titleHelp: n.titleHelp,
      titlePrefix: n.titlePrefix,
      titleSuffix: n.titleSuffix,
      // 自定义参数
      params: n.params,
      // 渲染属性
      id: n.colId || r.uniqueId("col_"),
      parentId: null,
      visible: u,
      // 内部属性（一旦被使用，将导致不可升级版本）
      halfVisible: !1,
      defaultVisible: u,
      defaultFixed: n.fixed,
      checked: !1,
      halfChecked: !1,
      disabled: !1,
      // 分组层级
      level: 1,
      // 跨行
      rowSpan: 1,
      // 跨列
      colSpan: 1,
      // 数据排序
      order: null,
      sortTime: 0,
      // 列排序
      sortNumber: 0,
      renderSortNumber: 0,
      renderFixed: "",
      renderVisible: !1,
      renderWidth: 0,
      renderHeight: 0,
      renderResizeWidth: 0,
      renderAutoWidth: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: s || n.renderHeader,
      renderCell: i || n.renderCell,
      renderFooter: l || n.renderFooter,
      renderData: a,
      // 单元格插槽，只对 grid 有效
      slots: n.slots
    }), c) {
      const { computeProxyOpts: p } = c.getComputeMaps(), w = p.value;
      w.beforeColumn && w.beforeColumn({ $grid: c, column: this });
    }
  }
  getTitle() {
    return fr(this.title || (this.type === "seq" ? xN("vxe.table.seqTitle") : ""));
  }
  getKey() {
    const { type: t } = this;
    return this.field || (t ? `type=${t}` : null);
  }
  update(t, n) {
    t !== "filters" && (t === "field" && (this.property = n), this[t] = n);
  }
}
const Ou = {}, Ml = r.browse();
function Vr(e, t) {
  return e ? r.isFunction(e) ? e(t) : e : "";
}
function Bh(e) {
  return Ou[e] || (Ou[e] = new RegExp(`(?:^|\\s)${e}(?!\\S)`, "g")), Ou[e];
}
function _h(e, t, n) {
  if (e) {
    const s = e.parentNode;
    if (n.top += e.offsetTop, n.left += e.offsetLeft, s && s !== document.documentElement && s !== document.body && (n.top -= s.scrollTop, n.left -= s.scrollLeft), !(t && (e === t || e.offsetParent === t)) && e.offsetParent)
      return _h(e.offsetParent, t, n);
  }
  return n;
}
function ed(e) {
  return e && /^\d+(px)?$/.test(e);
}
function Ci(e) {
  return e && /^\d+%$/.test(e);
}
function sl(e, t) {
  return e && e.className && e.className.match && e.className.match(Bh(t));
}
function jo(e, t) {
  e && sl(e, t) && (e.className = e.className.replace(Bh(t), ""));
}
function Ms(e, t) {
  e && !sl(e, t) && (jo(e, t), e.className = `${e.className} ${t}`);
}
function qc() {
  const e = document.documentElement, t = document.body;
  return {
    scrollTop: e.scrollTop || t.scrollTop,
    scrollLeft: e.scrollLeft || t.scrollLeft,
    visibleHeight: e.clientHeight || t.clientHeight,
    visibleWidth: e.clientWidth || t.clientWidth
  };
}
function gi(e) {
  return e ? e.offsetHeight : 0;
}
function td(e) {
  if (e) {
    const t = getComputedStyle(e), n = r.toNumber(t.paddingTop), s = r.toNumber(t.paddingBottom);
    return n + s;
  }
  return 0;
}
function no(e, t) {
  e && (e.scrollTop = t);
}
function fo(e, t) {
  e && (e.scrollLeft = t);
}
function Ed(e, t) {
  const n = t.type === "html" ? e.innerText : e.textContent;
  e.getAttribute("title") !== n && e.setAttribute("title", n);
}
function kn(e, t, n, s) {
  let i, l = e.target.shadowRoot && e.composed && e.composedPath()[0] || e.target;
  for (; l && l.nodeType && l !== document; ) {
    if (n && sl(l, n) && (!s || s(l)))
      i = l;
    else if (l === t)
      return { flag: n ? !!i : !0, container: t, targetElem: i };
    l = l.parentNode;
  }
  return { flag: !1 };
}
function yN(e, t) {
  return _h(e, t, { left: 0, top: 0 });
}
function Pa(e) {
  const t = e.getBoundingClientRect(), n = t.top, s = t.left, { scrollTop: i, scrollLeft: l, visibleHeight: a, visibleWidth: c } = qc();
  return { boundingTop: n, top: i + n, boundingLeft: s, left: l + s, visibleHeight: a, visibleWidth: c };
}
const xp = "scrollIntoViewIfNeeded", yp = "scrollIntoView";
function CN(e) {
  e && (e[xp] ? e[xp]() : e[yp] && e[yp]());
}
function wN(e, t) {
  e && e.dispatchEvent(new Event(t));
}
function Tu(e) {
  return e && e.nodeType === 1;
}
const Wh = (e, t) => {
  const n = [];
  return e.forEach((s) => {
    s.parentId = t ? t.id : null, s.visible && (s.children && s.children.length && s.children.some((i) => i.visible) ? (n.push(s), n.push(...Wh(s.children, s))) : n.push(s));
  }), n;
}, EN = (e) => {
  let t = 1;
  const n = (l, a) => {
    if (a && (l.level = a.level + 1, t < l.level && (t = l.level)), l.children && l.children.length && l.children.some((c) => c.visible)) {
      let c = 0;
      l.children.forEach((m) => {
        m.visible && (n(m, l), c += m.colSpan);
      }), l.colSpan = c;
    } else
      l.colSpan = 1;
  };
  e.forEach((l) => {
    l.level = 1, n(l);
  });
  const s = [];
  for (let l = 0; l < t; l++)
    s.push([]);
  return Wh(e).forEach((l) => {
    l.children && l.children.length && l.children.some((a) => a.visible) ? l.rowSpan = 1 : l.rowSpan = t - l.level + 1, s[l.level - 1].push(l);
  }), s;
};
function Mu(e, t, n) {
  const { internalData: s } = e;
  return e.clearScroll().then(() => {
    if (t || n)
      return s.lastScrollLeft = 0, s.lastScrollTop = 0, e.scrollTo(t, n);
  });
}
function Iu() {
  return r.uniqueId("row_");
}
function ir(e) {
  const { props: t } = e, { computeRowOpts: n } = e.getComputeMaps(), { rowId: s } = t, i = n.value;
  return s || i.keyField || "_X_ROW_KEY";
}
function yt(e, t) {
  const n = r.get(t, ir(e));
  return r.eqNull(n) ? "" : encodeURIComponent(n);
}
const io = (e, t) => t ? r.isString(t) ? e.getColumnByField(t) : t : null;
function ha(e) {
  if (e) {
    const t = getComputedStyle(e), n = r.toNumber(t.paddingLeft), s = r.toNumber(t.paddingRight);
    return n + s;
  }
  return 0;
}
function gl(e) {
  if (e) {
    const t = getComputedStyle(e), n = r.toNumber(t.marginLeft), s = r.toNumber(t.marginRight);
    return e.offsetWidth + n + s;
  }
  return 0;
}
function nr(e, t) {
  return e.querySelector(".vxe-cell" + t);
}
function zh(e) {
  return e && r.isArray(e) ? e.map(({ label: t, value: n, data: s, resetValue: i, checked: l }) => ({ label: t, value: n, data: s, resetValue: i, checked: !!l, _checked: !!l })) : e;
}
function SN(e) {
  return e.map((t, n) => n % 2 === 0 ? Number(t) + 1 : ".").join("");
}
function Do(e, t) {
  return r.get(e, t.field);
}
function js(e, t, n) {
  return r.set(e, t.field, n);
}
function Ho(e) {
  if (e) {
    const t = e.value;
    if (t)
      return t.$el || t;
  }
  return null;
}
function DN(e) {
  const { $table: t, column: n, cell: s } = e, { props: i } = t, { computeResizableOpts: l } = t.getComputeMaps(), a = l.value, { minWidth: c } = a;
  if (c) {
    const g = r.isFunction(c) ? c(e) : c;
    if (g !== "auto")
      return Math.max(1, r.toNumber(g));
  }
  const { showHeaderOverflow: m } = i, { showHeaderOverflow: u, minWidth: d } = n, p = r.isUndefined(u) || r.isNull(u) ? m : u, S = p === "title" || (p === !0 || p === "tooltip") || p === "ellipsis", x = r.floor((r.toNumber(getComputedStyle(s).fontSize) || 14) * 1.6), h = ha(s) + ha(nr(s, ""));
  let O = x + h;
  if (S) {
    const g = ha(nr(s, ">.vxe-cell--drag-handle")), b = ha(nr(s, ">.vxe-cell--checkbox")), E = gl(nr(s, ">.vxe-cell--required-icon")), C = gl(nr(s, ">.vxe-cell--edit-icon")), V = gl(nr(s, ">.vxe-cell-title-prefix-icon")), Q = gl(nr(s, ">.vxe-cell-title-suffix-icon")), Z = gl(nr(s, ">.vxe-cell--sort")), G = gl(nr(s, ">.vxe-cell--filter"));
    O += g + b + E + C + V + Q + G + Z;
  }
  if (d) {
    const { refTableBody: g } = t.getRefMaps(), b = g.value, E = b ? b.$el : null;
    if (E) {
      if (Ci(d)) {
        const V = (E.clientWidth - 1) / 100;
        return Math.max(O, Math.floor(r.toInteger(d) * V));
      } else if (ed(d))
        return Math.max(O, r.toInteger(d));
    }
  }
  return O;
}
function ka(e) {
  return e && (e.constructor === Qu || e instanceof Qu);
}
function ON(e, t, n) {
  return ka(t) ? t : Rt(new Qu(e, t, n));
}
function Hh(e, t, n) {
  Object.keys(t).forEach((s) => {
    lt(() => t[s], (i) => {
      n.update(s, i), e && (s === "filters" ? (e.setFilter(n, i), e.handleUpdateDataQueue()) : ["visible", "fixed", "width", "minWidth", "maxWidth"].includes(s) && e.handleRefreshColumnQueue());
    });
  });
}
function jh(e, t, n, s) {
  const { reactData: i } = e, { staticColumns: l } = i, a = t.parentNode, c = s ? s.columnConfig : null, m = c ? c.children : l;
  a && m && (m.splice(r.arrayIndexOf(a.children, t), 0, n), i.staticColumns = l.slice(0));
}
function qh(e, t) {
  const { reactData: n } = e, { staticColumns: s } = n, i = r.findTree(s, (l) => l.id === t.id, { children: "children" });
  i && i.items.splice(i.index, 1), n.staticColumns = s.slice(0);
}
function Cp(e, t) {
  const { internalData: n } = e, { fullColumnIdData: s } = n;
  if (!t)
    return null;
  let i = t.parentId;
  for (; s[i]; ) {
    const l = s[i].column;
    if (i = l.parentId, !i)
      return l;
  }
  return t;
}
function Uh(e, t, n) {
  for (let s = 0; s < e.length; s++) {
    const { row: i, col: l, rowspan: a, colspan: c } = e[s];
    if (l > -1 && i > -1 && a && c) {
      if (i === t && l === n)
        return { rowspan: a, colspan: c };
      if (t >= i && t < i + a && n >= l && n < l + c)
        return { rowspan: 0, colspan: 0 };
    }
  }
}
function TN(e) {
  const { props: t, internalData: n } = e;
  return n.initStatus = !1, e.clearSort(), e.clearCurrentRow(), e.clearCurrentColumn(), e.clearRadioRow(), e.clearRadioReserve(), e.clearCheckboxRow(), e.clearCheckboxReserve(), e.clearRowExpand(), e.clearTreeExpand(), e.clearTreeExpandReserve(), e.clearPendingRow(), e.clearFilter && e.clearFilter(), e.clearSelected && (t.keyboardConfig || t.mouseConfig) && e.clearSelected(), e.clearCellAreas && t.mouseConfig && (e.clearCellAreas(), e.clearCopyCellArea()), e.clearScroll();
}
function MN(e) {
  return e.clearFilter && e.clearFilter(), TN(e);
}
function wp(e, t) {
  const { reactData: n, internalData: s } = e, i = e.props, { showOverflow: l } = i, { refTableBody: a } = e.getRefMaps(), { columnStore: c, scrollYLoad: m } = n, { afterFullData: u, scrollYStore: d, fullAllDataRowIdData: p } = s, w = a.value, { leftList: v, rightList: D } = c, S = w ? w.$el : null, x = yt(e, t);
  let h = 0;
  v.forEach((g) => {
    h += g.renderWidth;
  });
  let O = 0;
  if (D.forEach((g) => {
    O += g.renderWidth;
  }), S) {
    const g = S.clientHeight, b = S.scrollTop, E = S.querySelector(`[rowid="${x}"]`);
    if (E) {
      const C = E.offsetParent, V = E.offsetTop + (C ? C.offsetTop : 0), Q = E.clientHeight;
      if (V < b || V > b + g)
        return e.scrollTo(null, V);
      if (V + Q >= g + b)
        return e.scrollTo(null, b + Q);
    } else if (m) {
      if (l)
        return e.scrollTo(null, (e.findRowIndexOf(u, t) - 1) * d.rowHeight);
      let C = 0;
      const V = p[x], Q = V ? V.height : 0;
      for (let Z = 0; Z < u.length; Z++) {
        const G = u[Z], ue = yt(e, G);
        if (G === t || ue === x)
          break;
        const Y = p[ue];
        C += Y ? Y.height : 0;
      }
      return C < b ? e.scrollTo(null, C - h - 1) : e.scrollTo(null, C + Q - (g - O - 1));
    }
  }
  return Promise.resolve();
}
function Ep(e, t, n) {
  const { reactData: s, internalData: i } = e, { refTableBody: l } = e.getRefMaps(), { columnStore: a, scrollXLoad: c } = s, { visibleColumn: m } = i, { leftList: u, rightList: d } = a, p = l.value, w = p ? p.$el : null;
  if (t.fixed)
    return Promise.resolve();
  let v = 0;
  u.forEach((S) => {
    v += S.renderWidth;
  });
  let D = 0;
  if (d.forEach((S) => {
    D += S.renderWidth;
  }), w) {
    const S = w.clientWidth, x = w.scrollLeft;
    let h = null;
    if (n) {
      const O = yt(e, n);
      h = w.querySelector(`[rowid="${O}"] .${t.id}`);
    }
    if (h || (h = w.querySelector(`.${t.id}`)), h) {
      const O = h.offsetParent, g = h.offsetLeft + (O ? O.offsetLeft : 0), b = h.clientWidth;
      if (g < x + v)
        return e.scrollTo(g - v - 1);
      if (g + b - x > S - D)
        return e.scrollTo(g + b - (S - D - 1));
    } else if (c) {
      let O = 0;
      const g = t.renderWidth;
      for (let b = 0; b < m.length; b++) {
        const E = m[b];
        if (E === t || E.id === t.id)
          break;
        O += E.renderWidth;
      }
      return O < x ? e.scrollTo(O - v - 1) : e.scrollTo(O + g - (S - D - 1));
    }
  }
  return Promise.resolve();
}
function $l(e) {
  return "on" + e.substring(0, 1).toLocaleUpperCase() + e.substring(1);
}
function Gh(e) {
  switch (e.name) {
    case "input":
    case "textarea":
      return "input";
    case "select":
      return "change";
  }
  return "update:modelValue";
}
function Kh(e) {
  switch (e.name) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeNumberInput":
    case "VxeTextarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function cs(e) {
  return r.isArray(e) ? e : [e];
}
const { getI18n: va, getIcon: Jn, renderer: wi, formats: Sp, renderEmptyElement: Zr } = Ce;
function IN(e) {
  const { $table: t, column: n } = e, s = n.titlePrefix || n.titleHelp;
  return s ? o("i", {
    class: ["vxe-cell-title-prefix-icon", s.icon || Jn().TABLE_TITLE_PREFIX],
    onMouseenter(i) {
      t.triggerHeaderTitleEvent(i, s, e);
    },
    onMouseleave(i) {
      t.handleTargetLeaveEvent(i);
    }
  }) : Zr(t);
}
function VN(e) {
  const { $table: t, column: n } = e, s = n.titleSuffix;
  return s ? o("i", {
    class: ["vxe-cell-title-suffix-icon", s.icon || Jn().TABLE_TITLE_SUFFIX],
    onMouseenter(i) {
      t.triggerHeaderTitleEvent(i, s, e);
    },
    onMouseleave(i) {
      t.handleTargetLeaveEvent(i);
    }
  }) : Zr(t);
}
function Dp(e) {
  const { $table: t } = e, n = t.props, { dragConfig: s } = n, { computeRowDragOpts: i } = t.getComputeMaps(), l = i.value, { icon: a, disabledMethod: c } = l, m = c || (s ? s.rowDisabledMethod : null), u = m && m(e);
  return o("span", {
    key: "dg",
    class: ["vxe-cell--drag-handle", {
      "is--disabled": u
    }],
    onMousedown(d) {
      u || t.handleCellDragMousedownEvent(d, e);
    },
    onMouseup: t.handleCellDragMouseupEvent
  }, [
    o("i", {
      class: a || (s ? s.rowIcon : "") || Jn().TABLE_DRAG_ROW
    })
  ]);
}
function Io(e, t) {
  const { $table: n, column: s, level: i } = e, { dragSort: l } = s, a = n.props, { treeConfig: c, dragConfig: m } = a, { computeRowOpts: u, computeRowDragOpts: d } = n.getComputeMaps(), p = u.value, w = d.value, { showIcon: v, isCrossDrag: D, visibleMethod: S } = w, x = S || (m ? m.rowVisibleMethod : null), h = r.isArray(t) ? t : [t];
  return l && p.drag && (v || m && m.showRowIcon) && (!x || x(e)) && (c ? (D || !i) && h.unshift(Dp(e)) : h.unshift(Dp(e))), h;
}
function PN(e) {
  const { $table: t, column: n } = e, { computeColumnOpts: s, computeColumnDragOpts: i } = t.getComputeMaps(), l = s.value, a = i.value, { showIcon: c, icon: m, visibleMethod: u, disabledMethod: d } = a, p = d && d(e);
  return l.drag && c && (!u || u(e)) && !(n.fixed || n.parentId) ? o("span", {
    key: "dg",
    class: ["vxe-cell--drag-handle", {
      "is--disabled": p
    }],
    onMousedown(w) {
      p || t.handleHeaderCellDragMousedownEvent(w, e);
    },
    onMouseup: t.handleHeaderCellDragMouseupEvent
  }, [
    o("i", {
      class: m || Jn().TABLE_DRAG_COLUMN
    })
  ]) : Zr(t);
}
function _s(e, t) {
  return [
    IN(e),
    PN(e),
    ...r.isArray(t) ? t : [t],
    VN(e)
  ];
}
function Mr(e, t) {
  const { $table: n, column: s } = e, { props: i, reactData: l } = n, { computeTooltipOpts: a } = n.getComputeMaps(), { showHeaderOverflow: c } = i, { type: m, showHeaderOverflow: u } = s, p = a.value.showAll, w = r.isUndefined(u) || r.isNull(u) ? c : u, v = w === "title", D = w === !0 || w === "tooltip", S = {};
  return (v || D || p) && (S.onMouseenter = (x) => {
    l._isResize || (v ? Ed(x.currentTarget, s) : (D || p) && n.triggerHeaderTooltipEvent(x, e));
  }), (D || p) && (S.onMouseleave = (x) => {
    l._isResize || (D || p) && n.handleTargetLeaveEvent(x);
  }), [
    m === "html" && r.isString(t) ? o("span", Object.assign({ class: "vxe-cell--title", innerHTML: t }, S)) : o("span", Object.assign({ class: "vxe-cell--title" }, S), cs(t))
  ];
}
function Op(e, t) {
  if (r.isFunction(e))
    return e(t);
  const n = r.isArray(e), s = n ? Sp.get(e[0]) : Sp.get(e), i = s ? s.tableFooterCellFormatMethod : null;
  return i ? n ? i(t, ...e.slice(1)) : i(t) : "";
}
function kN(e) {
  const { $table: t, column: n, _columnIndex: s, items: i, row: l } = e, { slots: a, editRender: c, cellRender: m, footerFormatter: u } = n, d = c || m, p = a ? a.footer : null;
  if (p)
    return t.callSlot(p, e);
  if (d) {
    const v = wi.get(d.name);
    if (v) {
      const D = v.renderTableFooter || v.renderFooter;
      if (D)
        return cs(D(d, e));
    }
  }
  let w = "";
  return r.isArray(i) ? (w = i[s], [
    u ? Op(u, {
      itemValue: w,
      column: n,
      row: l,
      items: i,
      _columnIndex: s
    }) : po(w, 1)
  ]) : (w = r.get(l, n.field), [
    u ? Op(u, {
      itemValue: w,
      column: n,
      row: l,
      items: i,
      _columnIndex: s
    }) : po(w, 1)
  ]);
}
function Tp(e) {
  const { $table: t, row: n, column: s } = e;
  return po(t.getCellLabel(n, s), 1);
}
const sn = {
  createColumn(e, t) {
    const { type: n, sortable: s, filters: i, editRender: l, treeNode: a } = t, { props: c } = e, { editConfig: m } = c, { computeEditOpts: u, computeCheckboxOpts: d } = e.getComputeMaps(), p = d.value, w = u.value, v = {
      renderHeader: sn.renderDefaultHeader,
      renderCell: a ? sn.renderTreeCell : sn.renderDefaultCell,
      renderFooter: sn.renderDefaultFooter
    };
    switch (n) {
      case "seq":
        v.renderHeader = sn.renderSeqHeader, v.renderCell = a ? sn.renderTreeIndexCell : sn.renderSeqCell;
        break;
      case "radio":
        v.renderHeader = sn.renderRadioHeader, v.renderCell = a ? sn.renderTreeRadioCell : sn.renderRadioCell;
        break;
      case "checkbox":
        v.renderHeader = sn.renderCheckboxHeader, v.renderCell = p.checkField ? a ? sn.renderTreeSelectionCellByProp : sn.renderCheckboxCellByProp : a ? sn.renderTreeSelectionCell : sn.renderCheckboxCell;
        break;
      case "expand":
        v.renderCell = sn.renderExpandCell, v.renderData = sn.renderExpandData;
        break;
      case "html":
        v.renderCell = a ? sn.renderTreeHTMLCell : sn.renderHTMLCell, i && s ? v.renderHeader = sn.renderSortAndFilterHeader : s ? v.renderHeader = sn.renderSortHeader : i && (v.renderHeader = sn.renderFilterHeader);
        break;
      default:
        m && l ? (v.renderHeader = sn.renderEditHeader, v.renderCell = w.mode === "cell" ? a ? sn.renderTreeCellEdit : sn.renderCellEdit : a ? sn.renderTreeRowEdit : sn.renderRowEdit) : i && s ? v.renderHeader = sn.renderSortAndFilterHeader : s ? v.renderHeader = sn.renderSortHeader : i && (v.renderHeader = sn.renderFilterHeader);
    }
    return ON(e, t, v);
  },
  /**
   * 列头标题
   */
  renderHeaderTitle(e) {
    const { $table: t, column: n } = e, { slots: s, editRender: i, cellRender: l } = n, a = i || l, c = s ? s.header : null;
    if (c)
      return Mr(e, t.callSlot(c, e));
    if (a) {
      const m = wi.get(a.name);
      if (m) {
        const u = m.renderTableHeader || m.renderHeader;
        if (u)
          return Mr(e, cs(u(a, e)));
      }
    }
    return Mr(e, po(n.getTitle(), 1));
  },
  renderDefaultHeader(e) {
    return _s(e, sn.renderHeaderTitle(e));
  },
  renderDefaultCell(e) {
    const { $table: t, row: n, column: s } = e, { slots: i, editRender: l, cellRender: a } = s, c = l || a, m = i ? i.default : null;
    if (m)
      return Io(e, t.callSlot(m, e));
    if (c) {
      const p = wi.get(c.name);
      if (p) {
        const w = p.renderTableCell || p.renderCell, v = p.renderTableDefault || p.renderDefault, D = l ? w : v;
        if (D)
          return Io(e, cs(D(c, Object.assign({ $type: l ? "edit" : "cell" }, e))));
      }
    }
    const u = t.getCellLabel(n, s), d = l ? l.placeholder : "";
    return Io(e, [
      o("span", {
        class: "vxe-cell--label"
      }, [
        // 如果设置占位符
        l && cr(u) ? o("span", {
          class: "vxe-cell--placeholder"
        }, po(fr(d), 1)) : o("span", po(u, 1))
      ])
    ]);
  },
  renderTreeCell(e) {
    return sn.renderTreeIcon(e, sn.renderDefaultCell(e));
  },
  renderDefaultFooter(e) {
    return [
      o("span", {
        class: "vxe-cell--item"
      }, kN(e))
    ];
  },
  /**
   * 树节点
   */
  renderTreeIcon(e, t) {
    const { $table: n, isHidden: s } = e, { reactData: i, internalData: l } = n, { computeTreeOpts: a } = n.getComputeMaps(), { treeExpandedMaps: c, treeExpandLazyLoadedMaps: m } = i, { fullAllDataRowIdData: u } = l, d = a.value, { row: p, column: w, level: v } = e, { slots: D } = w, { indent: S, lazy: x, trigger: h, iconLoaded: O, showIcon: g, iconOpen: b, iconClose: E } = d, C = d.children || d.childrenField, V = d.hasChild || d.hasChildField, Q = p[C], Z = Q && Q.length, G = D ? D.icon : null;
    let ue = !1, Y = !1, K = !1, L = !1;
    const ye = {};
    if (G)
      return n.callSlot(G, e);
    if (!s) {
      const se = yt(n, p);
      if (Y = !!c[se], x) {
        const P = u[se];
        K = !!m[se], ue = p[V], L = !!P.treeLoaded;
      }
    }
    return (!h || h === "default") && (ye.onClick = (se) => {
      n.triggerTreeExpandEvent(se, e);
    }), [
      o("div", {
        class: ["vxe-cell--tree-node", {
          "is--active": Y
        }],
        style: {
          paddingLeft: `${v * S}px`
        }
      }, [
        g && (x ? L ? Z : ue : Z) ? [
          o("div", Object.assign({ class: "vxe-tree--btn-wrapper" }, ye), [
            o("i", {
              class: ["vxe-tree--node-btn", K ? O || Jn().TABLE_TREE_LOADED : Y ? b || Jn().TABLE_TREE_OPEN : E || Jn().TABLE_TREE_CLOSE]
            })
          ])
        ] : null,
        o("div", {
          class: "vxe-tree-cell"
        }, t)
      ])
    ];
  },
  /**
   * 序号
   */
  renderSeqHeader(e) {
    const { $table: t, column: n } = e, { slots: s } = n, i = s ? s.header : null;
    return _s(e, Mr(e, i ? t.callSlot(i, e) : po(n.getTitle(), 1)));
  },
  renderSeqCell(e) {
    const { $table: t, column: n } = e, { props: s } = t, { treeConfig: i } = s, { computeSeqOpts: l } = t.getComputeMaps(), a = l.value, { slots: c } = n, m = c ? c.default : null;
    if (m)
      return Io(e, t.callSlot(m, e));
    const { seq: u } = e, d = a.seqMethod;
    return Io(e, [
      o("span", `${po(d ? d(e) : i ? u : (a.startIndex || 0) + u, 1)}`)
    ]);
  },
  renderTreeIndexCell(e) {
    return sn.renderTreeIcon(e, sn.renderSeqCell(e));
  },
  /**
   * 单选
   */
  renderRadioHeader(e) {
    const { $table: t, column: n } = e, { slots: s } = n, i = s ? s.header : null, l = s ? s.title : null;
    return _s(e, Mr(e, i ? t.callSlot(i, e) : [
      o("span", {
        class: "vxe-radio--label"
      }, l ? t.callSlot(l, e) : po(n.getTitle(), 1))
    ]));
  },
  renderRadioCell(e) {
    const { $table: t, column: n, isHidden: s } = e, { reactData: i } = t, { computeRadioOpts: l } = t.getComputeMaps(), { selectRadioRow: a } = i, c = l.value, { slots: m } = n, { labelField: u, checkMethod: d, visibleMethod: p } = c, { row: w } = e, v = m ? m.default : null, D = m ? m.radio : null, S = t.eqRow(w, a), x = !p || p({ row: w });
    let h = !!d, O;
    s || (O = {
      onClick(E) {
        !h && x && t.triggerRadioRowEvent(E, e);
      }
    }, d && (h = !d({ row: w })));
    const g = Object.assign(Object.assign({}, e), { checked: S, disabled: h, visible: x });
    if (D)
      return Io(e, t.callSlot(D, g));
    const b = [];
    return x && b.push(o("span", {
      class: ["vxe-radio--icon", S ? Jn().TABLE_RADIO_CHECKED : Jn().TABLE_RADIO_UNCHECKED]
    })), (v || u) && b.push(o("span", {
      class: "vxe-radio--label"
    }, v ? t.callSlot(v, g) : r.get(w, u))), Io(e, [
      o("span", Object.assign({ class: ["vxe-cell--radio", {
        "is--checked": S,
        "is--disabled": h
      }] }, O), b)
    ]);
  },
  renderTreeRadioCell(e) {
    return sn.renderTreeIcon(e, sn.renderRadioCell(e));
  },
  /**
   * 多选
   */
  renderCheckboxHeader(e) {
    const { $table: t, column: n, isHidden: s } = e, { reactData: i } = t, { computeIsAllCheckboxDisabled: l, computeCheckboxOpts: a } = t.getComputeMaps(), { isAllSelected: c, isIndeterminate: m } = i, u = l.value, { slots: d } = n, p = d ? d.header : null, w = d ? d.title : null, v = a.value, D = n.getTitle();
    let S;
    s || (S = {
      onClick(h) {
        u || t.triggerCheckAllEvent(h, !c);
      }
    });
    const x = Object.assign(Object.assign({}, e), { checked: c, disabled: u, indeterminate: m });
    return p ? _s(e, Mr(x, t.callSlot(p, x))) : (v.checkStrictly ? !v.showHeader : v.showHeader === !1) ? _s(e, Mr(x, [
      o("span", {
        class: "vxe-checkbox--label"
      }, w ? t.callSlot(w, x) : D)
    ])) : _s(e, Mr(x, [
      o("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": c,
        "is--disabled": u,
        "is--indeterminate": m
      }], title: va("vxe.table.allTitle") }, S), [
        o("span", {
          class: ["vxe-checkbox--icon", m ? Jn().TABLE_CHECKBOX_INDETERMINATE : c ? Jn().TABLE_CHECKBOX_CHECKED : Jn().TABLE_CHECKBOX_UNCHECKED]
        })
      ].concat(w || D ? [
        o("span", {
          class: "vxe-checkbox--label"
        }, w ? t.callSlot(w, x) : D)
      ] : []))
    ]));
  },
  renderCheckboxCell(e) {
    const { $table: t, row: n, column: s, isHidden: i } = e, { props: l, reactData: a } = t, { treeConfig: c } = l, { selectCheckboxMaps: m, treeIndeterminateMaps: u } = a, { computeCheckboxOpts: d } = t.getComputeMaps(), p = d.value, { labelField: w, checkMethod: v, visibleMethod: D } = p, { slots: S } = s, x = S ? S.default : null, h = S ? S.checkbox : null;
    let O = !1, g = !1;
    const b = !D || D({ row: n });
    let E = !!v, C;
    if (!i) {
      const Z = yt(t, n);
      g = !!m[Z], C = {
        onClick(G) {
          !E && b && t.triggerCheckRowEvent(G, e, !g);
        }
      }, v && (E = !v({ row: n })), c && (O = !!u[Z]);
    }
    const V = Object.assign(Object.assign({}, e), { checked: g, disabled: E, visible: b, indeterminate: O });
    if (h)
      return Io(e, t.callSlot(h, V));
    const Q = [];
    return b && Q.push(o("span", {
      class: ["vxe-checkbox--icon", O ? Jn().TABLE_CHECKBOX_INDETERMINATE : g ? Jn().TABLE_CHECKBOX_CHECKED : Jn().TABLE_CHECKBOX_UNCHECKED]
    })), (x || w) && Q.push(o("span", {
      class: "vxe-checkbox--label"
    }, x ? t.callSlot(x, V) : r.get(n, w))), Io(e, [
      o("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": g,
        "is--disabled": E,
        "is--indeterminate": O,
        "is--hidden": !b
      }] }, C), Q)
    ]);
  },
  renderTreeSelectionCell(e) {
    return sn.renderTreeIcon(e, sn.renderCheckboxCell(e));
  },
  renderCheckboxCellByProp(e) {
    const { $table: t, row: n, column: s, isHidden: i } = e, { props: l, reactData: a } = t, { treeConfig: c } = l, { treeIndeterminateMaps: m } = a, { computeCheckboxOpts: u } = t.getComputeMaps(), d = u.value, { labelField: p, checkField: w, checkMethod: v, visibleMethod: D } = d, S = d.indeterminateField || d.halfField, { slots: x } = s, h = x ? x.default : null, O = x ? x.checkbox : null;
    let g = !1, b = !1;
    const E = !D || D({ row: n });
    let C = !!v, V;
    if (!i) {
      const G = yt(t, n);
      b = r.get(n, w), V = {
        onClick(ue) {
          !C && E && t.triggerCheckRowEvent(ue, e, !b);
        }
      }, v && (C = !v({ row: n })), c && (g = !!m[G]);
    }
    const Q = Object.assign(Object.assign({}, e), { checked: b, disabled: C, visible: E, indeterminate: g });
    if (O)
      return Io(e, t.callSlot(O, Q));
    const Z = [];
    return E && (Z.push(o("span", {
      class: ["vxe-checkbox--icon", g ? Jn().TABLE_CHECKBOX_INDETERMINATE : b ? Jn().TABLE_CHECKBOX_CHECKED : Jn().TABLE_CHECKBOX_UNCHECKED]
    })), (h || p) && Z.push(o("span", {
      class: "vxe-checkbox--label"
    }, h ? t.callSlot(h, Q) : r.get(n, p)))), Io(e, [
      o("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": b,
        "is--disabled": C,
        "is--indeterminate": S && !b ? n[S] : g,
        "is--hidden": !E
      }] }, V), Z)
    ]);
  },
  renderTreeSelectionCellByProp(e) {
    return sn.renderTreeIcon(e, sn.renderCheckboxCellByProp(e));
  },
  /**
   * 展开行
   */
  renderExpandCell(e) {
    const { $table: t, isHidden: n, row: s, column: i } = e, { reactData: l } = t, { rowExpandedMaps: a, rowExpandLazyLoadedMaps: c } = l, { computeExpandOpts: m } = t.getComputeMaps(), u = m.value, { lazy: d, labelField: p, iconLoaded: w, showIcon: v, iconOpen: D, iconClose: S, visibleMethod: x } = u, { slots: h } = i, O = h ? h.default : null, g = h ? h.icon : null;
    let b = !1, E = !1;
    if (g)
      return Io(e, t.callSlot(g, e));
    if (!n) {
      const C = yt(t, s);
      b = !!a[C], d && (E = !!c[C]);
    }
    return Io(e, [
      v && (!x || x(e)) ? o("span", {
        class: ["vxe-table--expanded", {
          "is--active": b
        }],
        onClick(C) {
          t.triggerRowExpandEvent(C, e);
        }
      }, [
        o("i", {
          class: ["vxe-table--expand-btn", E ? w || Jn().TABLE_EXPAND_LOADED : b ? D || Jn().TABLE_EXPAND_OPEN : S || Jn().TABLE_EXPAND_CLOSE]
        })
      ]) : Zr(t),
      O || p ? o("span", {
        class: "vxe-table--expand-label"
      }, O ? t.callSlot(O, e) : r.get(s, p)) : Zr(t)
    ]);
  },
  renderExpandData(e) {
    const { $table: t, column: n } = e, { slots: s, contentRender: i } = n, l = s ? s.content : null;
    if (l)
      return t.callSlot(l, e);
    if (i) {
      const a = wi.get(i.name);
      if (a) {
        const c = a.renderTableExpand || a.renderExpand;
        if (c)
          return cs(c(i, e));
      }
    }
    return [];
  },
  /**
   * HTML 标签
   */
  renderHTMLCell(e) {
    const { $table: t, column: n } = e, { slots: s } = n, i = s ? s.default : null;
    return i ? Io(e, t.callSlot(i, e)) : Io(e, [
      o("span", {
        class: "vxe-cell--html",
        innerHTML: Tp(e)
      })
    ]);
  },
  renderTreeHTMLCell(e) {
    return sn.renderTreeIcon(e, sn.renderHTMLCell(e));
  },
  /**
   * 排序和筛选
   */
  renderSortAndFilterHeader(e) {
    return _s(e, sn.renderHeaderTitle(e).concat(sn.renderSortIcon(e).concat(sn.renderFilterIcon(e))));
  },
  /**
   * 排序
   */
  renderSortHeader(e) {
    return _s(e, sn.renderHeaderTitle(e).concat(sn.renderSortIcon(e)));
  },
  renderSortIcon(e) {
    const { $table: t, column: n } = e, { computeSortOpts: s } = t.getComputeMaps(), i = s.value, { showIcon: l, iconLayout: a, iconAsc: c, iconDesc: m } = i, { order: u } = n;
    return l ? [
      o("span", {
        class: ["vxe-cell--sort", `vxe-cell--sort-${a}-layout`]
      }, [
        o("i", {
          class: ["vxe-sort--asc-btn", c || Jn().TABLE_SORT_ASC, {
            "sort--active": u === "asc"
          }],
          title: va("vxe.table.sortAsc"),
          onClick(d) {
            d.stopPropagation(), t.triggerSortEvent(d, n, "asc");
          }
        }),
        o("i", {
          class: ["vxe-sort--desc-btn", m || Jn().TABLE_SORT_DESC, {
            "sort--active": u === "desc"
          }],
          title: va("vxe.table.sortDesc"),
          onClick(d) {
            d.stopPropagation(), t.triggerSortEvent(d, n, "desc");
          }
        })
      ])
    ] : [];
  },
  /**
   * 筛选
   */
  renderFilterHeader(e) {
    return _s(e, sn.renderHeaderTitle(e).concat(sn.renderFilterIcon(e)));
  },
  renderFilterIcon(e) {
    const { $table: t, column: n, hasFilter: s } = e, { reactData: i } = t, { filterStore: l } = i, { computeFilterOpts: a } = t.getComputeMaps(), c = a.value, { showIcon: m, iconNone: u, iconMatch: d } = c;
    return m ? [
      o("span", {
        class: ["vxe-cell--filter", {
          "is--active": l.visible && l.column === n
        }]
      }, [
        o("i", {
          class: ["vxe-filter--btn", s ? d || Jn().TABLE_FILTER_MATCH : u || Jn().TABLE_FILTER_NONE],
          title: va("vxe.table.filter"),
          onClick(p) {
            t.triggerFilterEvent && t.triggerFilterEvent(p, e.column, e);
          }
        })
      ])
    ] : [];
  },
  /**
   * 可编辑
   */
  renderEditHeader(e) {
    const { $table: t, column: n } = e, { props: s } = t, { computeEditOpts: i } = t.getComputeMaps(), { editConfig: l, editRules: a } = s, c = i.value, { sortable: m, filters: u, editRender: d } = n;
    let p = !1;
    if (a) {
      const v = r.get(a, n.field);
      v && (p = v.some((D) => D.required));
    }
    let w = [];
    return fn(l) && (w = [
      p && c.showAsterisk ? o("i", {
        class: "vxe-cell--required-icon"
      }) : Zr(t),
      fn(d) && c.showIcon ? o("i", {
        class: ["vxe-cell--edit-icon", c.icon || Jn().TABLE_EDIT]
      }) : Zr(t)
    ]), _s(e, w.concat(sn.renderHeaderTitle(e)).concat(m ? sn.renderSortIcon(e) : []).concat(u ? sn.renderFilterIcon(e) : []));
  },
  // 行格编辑模式
  renderRowEdit(e) {
    const { $table: t, column: n } = e, { reactData: s } = t, { editStore: i } = s, { actived: l } = i, { editRender: a } = n;
    return sn.runRenderer(e, fn(a) && l && l.row === e.row);
  },
  renderTreeRowEdit(e) {
    return sn.renderTreeIcon(e, sn.renderRowEdit(e));
  },
  // 单元格编辑模式
  renderCellEdit(e) {
    const { $table: t, column: n } = e, { reactData: s } = t, { editStore: i } = s, { actived: l } = i, { editRender: a } = n;
    return sn.runRenderer(e, fn(a) && l && l.row === e.row && l.column === e.column);
  },
  renderTreeCellEdit(e) {
    return sn.renderTreeIcon(e, sn.renderCellEdit(e));
  },
  runRenderer(e, t) {
    const { $table: n, column: s } = e, { slots: i, editRender: l, formatter: a } = s, c = i ? i.default : null, m = i ? i.edit : null, u = wi.get(l.name), d = u ? u.renderTableEdit || u.renderEdit : null, p = Object.assign({ $type: "", isEdit: t }, e);
    return t ? (p.$type = "edit", m ? n.callSlot(m, p) : d ? cs(d(l, p)) : []) : c ? Io(e, n.callSlot(c, p)) : a ? Io(e, [
      o("span", {
        class: "vxe-cell--label"
      }, Tp(p))
    ]) : sn.renderDefaultCell(p);
  }
}, Yh = {
  // 列唯一主键
  colId: [String, Number],
  // 渲染类型 index,radio,checkbox,expand,html
  type: String,
  // 列字段名
  field: String,
  // 列标题
  title: String,
  // 列宽度
  width: [Number, String],
  // 列最小宽度，把剩余宽度按比例分配
  minWidth: [Number, String],
  // 列最大宽度
  maxWidth: [Number, String],
  // 是否允许拖动列宽调整大小
  resizable: {
    type: Boolean,
    default: null
  },
  // 将列固定在左侧或者右侧
  fixed: String,
  // 列对其方式
  align: String,
  // 表头对齐方式
  headerAlign: String,
  // 表尾列的对齐方式
  footerAlign: String,
  // 当内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表头内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表尾内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 给单元格附加 className
  className: [String, Function],
  // 给表头单元格附加 className
  headerClassName: [String, Function],
  // 给表尾单元格附加 className
  footerClassName: [String, Function],
  // 格式化显示内容
  formatter: [Function, Array, String],
  // 格式化表尾显示内容
  footerFormatter: [Function, Array, String],
  // 是否允许排序
  sortable: Boolean,
  // 自定义排序的属性
  sortBy: [String, Function],
  // 排序的字段类型，比如字符串转数值等
  sortType: String,
  // 配置筛选条件数组
  filters: {
    type: Array,
    default: null
  },
  // 筛选是否允许多选
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  // 自定义筛选方法
  filterMethod: Function,
  // 筛选重置方法
  filterResetMethod: Function,
  // 筛选复原方法
  filterRecoverMethod: Function,
  // 筛选模板配置项
  filterRender: Object,
  // 设置为树节点
  treeNode: Boolean,
  // 指定为树节点
  dragSort: Boolean,
  // 是否可视
  visible: {
    type: Boolean,
    default: null
  },
  // 表头单元格数据导出方法
  headerExportMethod: Function,
  // 单元格数据导出方法
  exportMethod: Function,
  // 表尾单元格数据导出方法
  footerExportMethod: Function,
  // 已废弃，被 titlePrefix 替换
  titleHelp: Object,
  // 标题前缀图标配置项
  titlePrefix: Object,
  // 标题后缀图标配置项
  titleSuffix: Object,
  // 单元格值类型
  cellType: String,
  // 单元格渲染配置项
  cellRender: Object,
  // 单元格编辑渲染配置项
  editRender: Object,
  // 内容渲染配置项
  contentRender: Object,
  // 额外的参数
  params: Object
}, kr = pt({
  name: "VxeColumn",
  props: Yh,
  setup(e, { slots: t }) {
    const n = ke(), s = mt("$xeTable", null), i = mt("$xeColgroup", null);
    if (!s)
      return () => Ve();
    const l = sn.createColumn(s, e);
    l.slots = t;
    const a = () => o("div", {
      ref: n
    }), c = {
      columnConfig: l,
      renderVN: a
    };
    return Hh(s, e, l), wn(() => {
      const m = n.value;
      m && jh(s, m, l, i);
    }), $n(() => {
      qh(s, l);
    }), bn("$xeColumn", c), bn("$xeGrid", null), a;
  }
}), $N = Object.assign({}, kr, {
  install(e) {
    e.component(kr.name, kr), e.component("VxeTableColumn", kr);
  }
});
Ce.dynamicApp && (Ce.dynamicApp.component(kr.name, kr), Ce.dynamicApp.component("VxeTableColumn", kr));
Ce.component(kr);
const $r = pt({
  name: "VxeColgroup",
  props: Yh,
  setup(e, { slots: t }) {
    const n = ke(), s = mt("$xeTable", null), i = mt("$xeColgroup", null);
    if (!s)
      return () => Ve();
    const l = sn.createColumn(s, e), a = {};
    t.header && (a.header = t.header), l.slots = a, l.children = [], Hh(s, e, l), wn(() => {
      const u = n.value;
      u && jh(s, u, l, i);
    }), $n(() => {
      qh(s, l);
    });
    const c = () => o("div", {
      ref: n
    }, t.default ? t.default() : []);
    return bn("$xeColgroup", { columnConfig: l }), bn("$xeGrid", null), c;
  }
}), RN = Object.assign({}, $r, {
  install(e) {
    e.component($r.name, $r), e.component("VxeTableColgroup", $r);
  }
});
Ce.dynamicApp && (Ce.dynamicApp.component($r.name, $r), Ce.dynamicApp.component("VxeTableColgroup", $r));
Ce.component($r);
const { getI18n: NN, renderer: Mp, renderEmptyElement: Ip } = Ce, hl = "body", FN = {
  mini: 3,
  small: 2,
  medium: 1
}, Vp = pt({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = mt("$xeTable", {}), n = mt("xesize", null), { xID: s, props: i, context: l, reactData: a, internalData: c } = t, { refTableBody: m, refTableHeader: u, refTableFooter: d, refTableLeftBody: p, refTableRightBody: w, refScrollXHandleElem: v, refScrollYHandleElem: D } = t.getRefMaps(), { computeEditOpts: S, computeMouseOpts: x, computeAreaOpts: h, computeSYOpts: O, computeEmptyOpts: g, computeKeyboardOpts: b, computeTooltipOpts: E, computeRadioOpts: C, computeExpandOpts: V, computeTreeOpts: Q, computeCheckboxOpts: Z, computeCellOpts: G, computeValidOpts: ue, computeRowOpts: Y, computeColumnOpts: K } = t.getComputeMaps(), L = ke(), ye = ke(), se = ke(), P = ke(), M = ke(), I = ke(), B = ke(), H = () => {
      if (n) {
        const Ae = n.value;
        if (Ae)
          return FN[Ae] || 0;
      }
      return 0;
    }, ce = () => {
      const { delayHover: Ae } = i, { lastScrollTime: _e, _isResize: it } = a;
      return !!(it || _e && Date.now() < _e + Ae);
    }, A = (Ae, _e) => {
      let it = 1;
      if (!Ae)
        return it;
      const vt = Q.value, dt = vt.children || vt.childrenField, at = Ae[dt];
      if (at && t.isTreeExpandByRow(Ae))
        for (let Et = 0; Et < at.length; Et++)
          it += A(at[Et]);
      return it;
    }, j = (Ae, _e, it) => {
      let vt = 1;
      return it && (vt = A(_e[it - 1])), a.rowHeight * vt - (it ? 1 : 12 - H());
    }, fe = (Ae) => {
      const { row: _e, column: it } = Ae, { afterFullData: vt } = c, { treeConfig: dt } = i, at = Q.value, { slots: Et, treeNode: Qe } = it, { fullAllDataRowIdData: De } = c, Re = yt(t, _e), Be = De[Re];
      let ve = 0, Ne = 0, q = [];
      if (Be && (ve = Be.level, Ne = Be._index, q = Be.items), Et && Et.line)
        return t.callSlot(Et.line, Ae);
      const z = t.eqRow(vt[0], _e);
      return dt && Qe && (at.showLine || at.line) ? [
        o("div", {
          class: "vxe-tree--line-wrapper"
        }, [
          o("div", {
            class: "vxe-tree--line",
            style: {
              height: `${z ? 1 : j(Ae, q, Ne)}px`,
              left: `${ve * at.indent + (ve ? 2 - H() : 0) + 16}px`
            }
          })
        ])
      ] : [];
    }, pe = (Ae, _e, it, vt, dt, at, Et, Qe, De, Re, Be, ve) => {
      const { fullAllDataRowIdData: Ne } = c, { columnKey: q, height: z, showOverflow: R, cellClassName: le, cellStyle: F, align: re, spanMethod: N, mouseConfig: ee, editConfig: be, editRules: we, tooltipConfig: Te } = i, { tableData: ze, overflowX: st, currentColumn: ct, scrollXLoad: Ke, scrollYLoad: wt, mergeList: St, editStore: Dt, isAllOverflow: Wt, validErrorMaps: nn } = a, { afterFullData: zt } = c, At = G.value, Ee = ue.value, Ye = Z.value, rt = S.value, Ot = E.value, Jt = Y.value, Bt = O.value, Gt = K.value, Qt = x.value, U = h.value, { selectCellToRow: Lt } = U, { type: on, cellRender: en, editRender: hn, align: En, showOverflow: mn, className: gn, treeNode: Sn, slots: Fn } = De, { verticalAlign: co } = At, { actived: Uo } = Dt, { rHeight: Qn } = Bt, { height: ho } = Jt, Co = De.id, Oo = hn || en, Po = Oo ? Mp.get(Oo.name) : null, Ys = Po ? Po.tableCellClassName || Po.cellClassName : null, Fs = Po ? Po.tableCellStyle || Po.cellStyle : "", ms = Ot.showAll, xr = t.getColumnIndex(De), Es = t.getVTColumnIndex(De), oo = fn(hn);
      let Bo = it ? De.fixed !== it : De.fixed && st;
      const ko = r.isUndefined(mn) || r.isNull(mn) ? R : mn, _o = ko === "ellipsis", ts = ko === "title", Kn = ko === !0 || ko === "tooltip", $o = R || ts || Kn || _o;
      let Wo;
      const Go = {}, Xs = Ne[_e], yr = En || (Po ? Po.tableCellAlign : "") || re, ns = nn[`${_e}:${Co}`], zr = we && Ee.showMessage && (Ee.message === "default" ? z || ze.length > 1 : Ee.message === "inline"), mo = { colid: Co }, ae = {
        $table: t,
        $grid: t.xegrid,
        isEdit: !1,
        seq: Ae,
        rowid: _e,
        row: dt,
        rowIndex: at,
        $rowIndex: Et,
        _rowIndex: Qe,
        column: De,
        columnIndex: xr,
        $columnIndex: Re,
        _columnIndex: Es,
        fixed: it,
        type: hl,
        isHidden: Bo,
        level: vt,
        visibleData: zt,
        data: ze,
        items: ve
      };
      if ((ts || Kn || ms || Te) && (Go.onMouseenter = (ft) => {
        ce() || (ts ? Ed(ft.currentTarget, De) : (Kn || ms) && t.triggerBodyTooltipEvent(ft, ae), t.dispatchEvent("cell-mouseenter", Object.assign({ cell: ft.currentTarget }, ae), ft));
      }), (Kn || ms || Te) && (Go.onMouseleave = (ft) => {
        ce() || ((Kn || ms) && t.handleTargetLeaveEvent(ft), t.dispatchEvent("cell-mouseleave", Object.assign({ cell: ft.currentTarget }, ae), ft));
      }), (Ye.range || ee) && (Go.onMousedown = (ft) => {
        t.triggerCellMousedownEvent(ft, ae);
      }), Go.onClick = (ft) => {
        t.triggerCellClickEvent(ft, ae);
      }, Go.onDblclick = (ft) => {
        t.triggerCellDblclickEvent(ft, ae);
      }, St.length) {
        const ft = Uh(St, Qe, Es);
        if (ft) {
          const { rowspan: $t, colspan: Mt } = ft;
          if (!$t || !Mt)
            return null;
          $t > 1 && (mo.rowspan = $t), Mt > 1 && (mo.colspan = Mt);
        }
      } else if (N) {
        const { rowspan: ft = 1, colspan: $t = 1 } = N(ae) || {};
        if (!ft || !$t)
          return null;
        ft > 1 && (mo.rowspan = ft), $t > 1 && (mo.colspan = $t);
      }
      Bo && St && (mo.colspan > 1 || mo.rowspan > 1) && (Bo = !1), !Bo && be && (hn || en) && (rt.showStatus || rt.showUpdateStatus) && (Wo = t.isUpdateByRow(dt, De.field));
      const We = [];
      if (Bo && R && Wt)
        We.push(o("div", {
          class: ["vxe-cell", {
            "c--title": ts,
            "c--tooltip": Kn,
            "c--ellipsis": _o
          }],
          style: {
            maxHeight: $o && (Qn || ho) ? `${Qn || ho}px` : ""
          }
        }));
      else if (We.push(...fe(ae), o("div", {
        class: ["vxe-cell", {
          "c--title": ts,
          "c--tooltip": Kn,
          "c--ellipsis": _o
        }],
        style: {
          maxHeight: $o && (Qn || ho) ? `${Qn || ho}px` : ""
        },
        title: ts ? t.getCellLabel(dt, De) : null
      }, De.renderCell(ae))), zr && ns) {
        const ft = ns.rule, $t = Fn ? Fn.valid : null, Mt = Object.assign(Object.assign(Object.assign({}, ae), ns), { rule: ns });
        We.push(o("div", {
          class: ["vxe-cell--valid-error-tip", Vr(Ee.className, Mt)],
          style: ft && ft.maxWidth ? {
            width: `${ft.maxWidth}px`
          } : null
        }, [
          o("div", {
            class: `vxe-cell--valid-error-wrapper vxe-cell--valid-error-theme-${Ee.theme || "normal"}`
          }, [
            $t ? t.callSlot($t, Mt) : [
              o("span", {
                class: "vxe-cell--valid-error-msg"
              }, ns.content)
            ]
          ])
        ]));
      }
      let Ze = "";
      return $o && (Qn || ho) ? Ze = `${Qn || ho}px` : (Ke || wt) && ($o || (Ze = `${Xs.height || 24}px`)), ee && Qt.area && Lt && (!Re && Lt === !0 || Lt === De.field) && We.push(o("div", {
        class: "vxe-cell--area-status"
      })), o("td", Object.assign(Object.assign(Object.assign({ class: [
        "vxe-body--column",
        Co,
        {
          [`col--${yr}`]: yr,
          [`col--vertical-${co}`]: co,
          [`col--${on}`]: on,
          "col--last": Re === Be.length - 1,
          "col--tree-node": Sn,
          "col--edit": oo,
          "col--ellipsis": $o,
          "fixed--hidden": Bo,
          "col--dirty": Wo,
          "col--active": be && oo && Uo.row === dt && (Uo.column === De || rt.mode === "row"),
          "col--valid-error": !!ns,
          "col--current": ct === De
        },
        Vr(Ys, ae),
        Vr(gn, ae),
        Vr(le, ae)
      ], key: q || Gt.useKey || Jt.useKey || Gt.drag ? Co : Re }, mo), { style: Object.assign({
        height: Ze
      }, r.isFunction(Fs) ? Fs(ae) : Fs, r.isFunction(F) ? F(ae) : F) }), Go), We);
    }, ne = (Ae, _e, it) => {
      const { stripe: vt, rowKey: dt, highlightHoverRow: at, rowClassName: Et, rowStyle: Qe, showOverflow: De, editConfig: Re, treeConfig: Be } = i, { hasFixedColumn: ve, treeExpandedMaps: Ne, scrollYLoad: q, rowExpandedMaps: z, expandColumn: R, selectRadioRow: le, pendingRowMaps: F, pendingRowList: re, isDragColMove: N } = a, { fullAllDataRowIdData: ee } = c, be = Z.value, we = C.value, Te = Q.value, ze = S.value, st = Y.value, ct = K.value, { transform: Ke, seqMode: wt } = Te, St = Te.children || Te.childrenField, Dt = [];
      return _e.forEach((Wt, nn) => {
        const zt = {};
        let At = nn;
        At = t.getRowIndex(Wt), (st.isHover || at) && (zt.onMouseenter = (hn) => {
          ce() || t.triggerHoverEvent(hn, { row: Wt, rowIndex: At });
        }, zt.onMouseleave = () => {
          ce() || t.clearHoverRow();
        });
        const Ee = yt(t, Wt), Ye = ee[Ee];
        let rt = 0, Ot = -1, Jt = 0;
        Ye && (rt = Ye.level, Be && Ke && wt === "increasing" ? Ot = Ye._index + 1 : Ot = Ye.seq, Jt = Ye._index);
        const Bt = { $table: t, seq: Ot, rowid: Ee, fixed: Ae, type: hl, level: rt, row: Wt, rowIndex: At, $rowIndex: nn, _rowIndex: Jt }, Gt = R && !!z[Ee];
        let Qt = !1, U = [], Lt = !1;
        Re && (Lt = t.isInsertByRow(Wt)), Be && !q && !Ke && (U = Wt[St], Qt = U && U.length > 0 && !!Ne[Ee]), st.drag && (!Be || Ke) && (zt.onDragstart = t.handleRowDragDragstartEvent, zt.onDragend = t.handleRowDragDragendEvent, zt.onDragover = t.handleRowDragDragoverEvent);
        const on = [
          "vxe-body--row",
          Be ? `row--level-${rt}` : "",
          {
            "row--stripe": vt && (Jt + 1) % 2 === 0,
            "is--new": Lt,
            "is--expand-row": Gt,
            "is--expand-tree": Qt,
            "row--new": Lt && (ze.showStatus || ze.showInsertStatus),
            "row--radio": we.highlight && t.eqRow(le, Wt),
            "row--checked": be.highlight && t.isCheckedByCheckboxRow(Wt),
            "row--pending": re.length && !!F[Ee]
          },
          Vr(Et, Bt)
        ], en = it.map((hn, En) => pe(Ot, Ee, Ae, rt, Wt, At, nn, Jt, hn, En, it, _e));
        if (Dt.push(ct.drag ? o(Fr, Object.assign({ name: `vxe-header--col-list${N ? "" : "-disabled"}`, tag: "tr", class: on, rowid: Ee, style: Qe ? r.isFunction(Qe) ? Qe(Bt) : Qe : null, key: dt || st.useKey || st.drag || Be ? Ee : nn }, zt), {
          default: () => en
        }) : o("tr", Object.assign({ class: on, rowid: Ee, style: Qe ? r.isFunction(Qe) ? Qe(Bt) : Qe : null, key: dt || st.useKey || st.drag || Be ? Ee : nn }, zt), en)), Gt) {
          const hn = V.value, { height: En, padding: mn } = hn, gn = {};
          En && (gn.height = `${En}px`), Be && (gn.paddingLeft = `${rt * Te.indent + 30}px`);
          const { showOverflow: Sn } = R, Fn = r.isUndefined(Sn) || r.isNull(Sn) ? De : Sn, co = { $table: t, seq: Ot, column: R, fixed: Ae, type: hl, level: rt, row: Wt, rowIndex: At, $rowIndex: nn, _rowIndex: Jt };
          Dt.push(o("tr", Object.assign({ class: ["vxe-body--expanded-row", {
            "is--padding": mn
          }], key: `expand_${Ee}`, style: Qe ? r.isFunction(Qe) ? Qe(co) : Qe : null }, zt), [
            o("td", {
              class: {
                "vxe-body--expanded-column": 1,
                "fixed--hidden": Ae && !ve,
                "col--ellipsis": Fn
              },
              colspan: it.length
            }, [
              o("div", {
                class: {
                  "vxe-body--expanded-cell": 1,
                  "is--ellipsis": En
                },
                style: gn
              }, [
                R.renderData(co)
              ])
            ])
          ]));
        }
        Qt && Dt.push(...ne(Ae, U, it));
      }), Dt;
    }, $ = (Ae) => {
      const { fixedType: _e } = e, { lastScrollTop: it, lastScrollLeft: vt, inVirtualScroll: dt, inBodyScroll: at, bodyScrollType: Et, inFooterScroll: Qe } = c;
      if (dt || Qe || at && Et !== _e)
        return;
      const De = u.value, Re = m.value, Be = d.value, ve = p.value, Ne = w.value, q = L.value, z = De ? De.$el : null, R = Be ? Be.$el : null, le = Re.$el;
      if (!le)
        return;
      const F = ve ? ve.$el : null, re = Ne ? Ne.$el : null, N = v.value, ee = D.value, be = q.scrollTop, we = le.scrollLeft, Te = we !== vt, ze = be !== it;
      c.inBodyScroll = !0, c.bodyScrollType = _e, ze && (F && _e === "left" ? (no(le, be), no(re, be)) : re && _e === "right" ? (no(le, be), no(F, be)) : (no(F, be), no(re, be)), no(ee, be), t.triggerScrollYEvent(Ae)), Te && (fo(N, we), fo(z, we), fo(R, we), t.triggerScrollXEvent(Ae)), t.handleScrollEvent(Ae, ze, Te, be, we, {
        type: hl,
        fixed: _e
      });
    };
    let J, ge = 0, Oe = 0, Se = 0, de = !1;
    const Ie = (Ae, _e, it, vt, dt) => {
      const { elemStore: at } = c, { scrollXLoad: Et, scrollYLoad: Qe } = a, De = m.value, Re = p.value, Be = w.value, ve = Re ? Re.$el : null, Ne = Be ? Be.$el : null, q = De.$el, z = Ho(at["main-body-ySpace"]), R = Ho(at["main-body-xSpace"]), le = Qe && z ? z.clientHeight : q.clientHeight, F = Et && R ? R.clientWidth : q.clientWidth, re = de === _e ? Math.max(0, ge - Se) : 0;
      de = _e, ge = Math.abs(_e ? it - re : it + re), Oe = 0, Se = 0, clearTimeout(J);
      const N = () => {
        if (Se < ge) {
          const { fixedType: ee } = e;
          Oe = Math.max(5, Math.floor(Oe * 1.5)), Se = Se + Oe, Se > ge && (Oe = Oe - (Se - ge));
          const { scrollTop: be, clientHeight: we, scrollHeight: Te } = q, ze = be + Oe * (_e ? -1 : 1);
          q.scrollTop = ze, ve && (ve.scrollTop = ze), Ne && (Ne.scrollTop = ze), (_e ? ze < Te - we : ze >= 0) && (J = setTimeout(N, 10)), t.dispatchEvent("scroll", {
            type: hl,
            fixed: ee,
            scrollTop: q.scrollTop,
            scrollLeft: q.scrollLeft,
            scrollHeight: q.scrollHeight,
            scrollWidth: q.scrollWidth,
            bodyHeight: le,
            bodyWidth: F,
            isX: vt,
            isY: dt
          }, Ae);
        }
      };
      N();
    }, je = (Ae) => {
      const { deltaY: _e, deltaX: it } = Ae, { highlightHoverRow: vt } = i, { scrollYLoad: dt } = a, { lastScrollTop: at, lastScrollLeft: Et } = c, Qe = Y.value, De = m.value, Re = L.value, Be = De.$el, ve = _e, Ne = it, q = ve < 0;
      if (q ? Re.scrollTop <= 0 : Re.scrollTop >= Re.scrollHeight - Re.clientHeight)
        return;
      const z = Re.scrollTop + ve, R = Be.scrollLeft + Ne, le = R !== Et, F = z !== at;
      F && (Ae.preventDefault(), c.lastScrollTop = z, c.lastScrollLeft = R, a.lastScrollTime = Date.now(), (Qe.isHover || vt) && t.clearHoverRow(), Ie(Ae, q, ve, le, F), dt && t.triggerScrollYEvent(Ae));
    };
    return wn(() => {
      me(() => {
        const { fixedType: Ae } = e, { elemStore: _e } = c, it = `${Ae || "main"}-body-`;
        _e[`${it}wrapper`] = L, _e[`${it}table`] = ye, _e[`${it}colgroup`] = se, _e[`${it}list`] = P, _e[`${it}xSpace`] = M, _e[`${it}ySpace`] = I, _e[`${it}emptyBlock`] = B;
      });
    }), Us(() => {
      clearTimeout(J);
    }), $n(() => {
      const { fixedType: Ae } = e, { elemStore: _e } = c, it = `${Ae || "main"}-body-`;
      _e[`${it}wrapper`] = null, _e[`${it}table`] = null, _e[`${it}colgroup`] = null, _e[`${it}list`] = null, _e[`${it}xSpace`] = null, _e[`${it}ySpace`] = null, _e[`${it}emptyBlock`] = null;
    }), () => {
      let { fixedColumn: Ae, fixedType: _e, tableColumn: it } = e;
      const { keyboardConfig: vt, showOverflow: dt, spanMethod: at, mouseConfig: Et } = i, { tableData: Qe, mergeList: De, scrollYLoad: Re, isAllOverflow: Be, isDragRowMove: ve } = a, { visibleColumn: Ne } = c, { slots: q } = l, z = Y.value, R = O.value, le = g.value, F = b.value, re = x.value, N = K.value;
      _e && (!a.expandColumn && (Re || dt && Be) && !De.length && !at && !(vt && F.isMerge) ? it = Ae : it = Ne);
      let ee;
      const be = q ? q.empty : null;
      if (be)
        ee = t.callSlot(be, { $table: t, $grid: t.xegrid });
      else {
        const Te = le.name ? Mp.get(le.name) : null, ze = Te ? Te.renderTableEmpty || Te.renderTableEmptyView || Te.renderEmpty : null;
        ze ? ee = cs(ze(le, { $table: t })) : ee = i.emptyText || NN("vxe.table.emptyText");
      }
      const we = {
        onScroll: $
      };
      return R.mode === "wheel" && (we.onWheel = je), o("div", Object.assign({ ref: L, class: ["vxe-table--body-wrapper", _e ? `fixed-${_e}--wrapper` : "body--wrapper"], xid: s }, we), [
        _e ? Ve() : o("div", {
          ref: M,
          class: "vxe-body--x-space"
        }),
        o("div", {
          ref: I,
          class: "vxe-body--y-space"
        }),
        o("table", {
          ref: ye,
          class: "vxe-table--body",
          xid: s,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          o("colgroup", {
            ref: se
          }, it.map((Te, ze) => o("col", {
            name: Te.id,
            key: ze
          }))),
          /**
           * 内容
           */
          z.drag || N.drag ? o(Fr, {
            ref: P,
            name: `vxe-body--row-list${ve ? "" : "-disabled"}`,
            tag: "tbody"
          }, {
            default: () => ne(_e, Qe, it)
          }) : o("tbody", {
            ref: P
          }, ne(_e, Qe, it))
        ]),
        o("div", {
          class: "vxe-table--checkbox-range"
        }),
        Et && re.area ? o("div", {
          class: "vxe-table--cell-area"
        }, [
          o("span", {
            class: "vxe-table--cell-main-area"
          }, re.extension ? [
            o("span", {
              class: "vxe-table--cell-main-area-btn",
              onMousedown(Te) {
                t.triggerCellAreaExtendMousedownEvent && t.triggerCellAreaExtendMousedownEvent(Te, { $table: t, fixed: _e, type: hl });
              }
            })
          ] : []),
          o("span", {
            class: "vxe-table--cell-copy-area"
          }),
          o("span", {
            class: "vxe-table--cell-extend-area"
          }),
          o("span", {
            class: "vxe-table--cell-multi-area"
          }),
          o("span", {
            class: "vxe-table--cell-active-area"
          })
        ]) : Ip(t),
        _e ? Ip(t) : o("div", {
          class: "vxe-table--empty-block",
          ref: B
        }, [
          o("div", {
            class: "vxe-table--empty-content"
          }, ee)
        ])
      ]);
    };
  }
}), { renderer: LN } = Ce, Pp = "header", kp = pt({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = mt("$xeTable", {}), { xID: n, props: s, reactData: i, internalData: l } = t, { refElem: a, refTableBody: c, refLeftContainer: m, refRightContainer: u, refCellResizeBar: d, refCellResizeTip: p } = t.getRefMaps(), { computeColumnOpts: w, computeResizableOpts: v } = t.getComputeMaps(), D = ke([]), S = ke(), x = ke(), h = ke(), O = ke(), g = ke(), b = ke(), E = () => {
      const { isGroup: G } = i;
      D.value = G ? EN(e.tableGroupColumn) : [];
    }, C = (G, ue) => {
      const { column: Y } = ue, { fixedType: K } = e, { visibleColumn: L } = l, ye = v.value, se = c.value, P = a.value, M = m.value, I = u.value, B = d.value, H = p.value, { clientX: ce } = G, A = S.value, j = G.target, fe = ue.cell = j.parentNode;
      let pe = 0;
      const ne = se.$el, $ = yN(j, A), J = j.clientWidth, ge = Math.floor(J / 2), Oe = DN(ue) - ge;
      let Se = $.left - fe.clientWidth + J + Oe, de = $.left + ge;
      const Ie = document.onmousemove, je = document.onmouseup, Ue = K === "left", Ae = K === "right";
      let _e = 0;
      if (Ue || Ae) {
        const vt = Ue ? "nextElementSibling" : "previousElementSibling";
        let dt = fe[vt];
        for (; dt && !sl(dt, "fixed--hidden"); )
          sl(dt, "col--group") || (_e += dt.offsetWidth), dt = dt[vt];
        Ae && I && (de = I.offsetLeft + _e);
      }
      const it = function(vt) {
        vt.stopPropagation(), vt.preventDefault();
        const dt = vt.clientX - ce;
        let at = de + dt;
        const Et = K ? 0 : ne.scrollLeft;
        Ue ? at = Math.min(at, (I ? I.offsetLeft : ne.clientWidth) - _e - Oe) : Ae ? (Se = (M ? M.clientWidth : 0) + _e + Oe, at = Math.min(at, de + fe.clientWidth - Oe)) : Se = Math.max(ne.scrollLeft, Se), pe = Math.max(at, Se);
        const Qe = pe - Et;
        if (B.style.left = `${Qe}px`, ye.showDragTip && H) {
          const De = P.clientWidth, Re = A.getBoundingClientRect(), Be = B.clientWidth, ve = H.clientWidth, Ne = H.clientHeight;
          let q = -ve;
          Qe < ve + Be ? q = ve + Be - Qe : Qe > De && (q += De - Qe), H.style.left = `${q}px`, H.style.top = `${Math.min(P.clientHeight - Ne, Math.max(0, vt.clientY - Re.y - Ne / 2))}px`, H.textContent = `${Y.renderWidth + (Ae ? de - pe : pe - de)}px`;
        }
      };
      i._isResize = !0, Ms(P, "drag--resize"), B.style.display = "block", document.onmousemove = it, document.onmouseup = function(vt) {
        document.onmousemove = Ie, document.onmouseup = je;
        const dt = Y.renderWidth + (Ae ? de - pe : pe - de);
        Y.resizeWidth = dt, ye.dragMode === "fixed" && L.forEach((at) => {
          at.id !== Y.id && (at.resizeWidth || (at.resizeWidth = at.renderWidth));
        }), B.style.display = "none", i._isResize = !1, l._lastResizeTime = Date.now(), t.analyColumnWidth(), t.recalculate(!0).then(() => {
          t.saveCustomStore("update:visible"), t.updateCellAreas(), t.dispatchEvent("resizable-change", Object.assign(Object.assign({}, ue), { resizeWidth: dt }), vt), setTimeout(() => t.recalculate(!0), 300);
        }), jo(P, "drag--resize");
      }, it(G), t.closeMenu && t.closeMenu();
    }, V = (G, ue) => {
      const { fixedType: Y } = e, { resizable: K, border: L, columnKey: ye, headerCellClassName: se, headerCellStyle: P, showHeaderOverflow: M, headerAlign: I, align: B, mouseConfig: H } = s, { currentColumn: ce, scrollXLoad: A, overflowX: j, scrollbarWidth: fe } = i, pe = w.value;
      return G.map((ne, $) => {
        const { type: J, showHeaderOverflow: ge, headerAlign: Oe, align: Se, headerClassName: de, editRender: Ie, cellRender: je } = ne, Ue = ne.id, Ae = Ie || je, _e = Ae ? LN.get(Ae.name) : null, it = ne.children && ne.children.length, vt = Y ? ne.fixed !== Y && !it : !!ne.fixed && j, dt = r.eqNull(ge) ? M : ge, at = Oe || (_e ? _e.tableHeaderCellAlign : "") || I || Se || (_e ? _e.tableCellAlign : "") || B;
        let Et = dt === "ellipsis";
        const Qe = dt === "title", De = dt === !0 || dt === "tooltip";
        let Re = Qe || De || Et;
        const Be = ne.filters && ne.filters.some((R) => R.checked), ve = t.getColumnIndex(ne), Ne = t.getVTColumnIndex(ne), q = { $table: t, $grid: t.xegrid, $rowIndex: ue, column: ne, columnIndex: ve, $columnIndex: $, _columnIndex: Ne, fixed: Y, type: Pp, isHidden: vt, hasFilter: Be }, z = {
          onClick: (R) => t.triggerHeaderCellClickEvent(R, q),
          onDblclick: (R) => t.triggerHeaderCellDblclickEvent(R, q)
        };
        return A && !Re && (Et = Re = !0), H && (z.onMousedown = (R) => t.triggerHeaderCellMousedownEvent(R, q)), pe.drag && (z.onDragstart = t.handleHeaderCellDragDragstartEvent, z.onDragend = t.handleHeaderCellDragDragendEvent, z.onDragover = t.handleHeaderCellDragDragoverEvent), o("th", Object.assign(Object.assign({ class: [
          "vxe-header--column",
          Ue,
          {
            [`col--${at}`]: at,
            [`col--${J}`]: J,
            "col--last": $ === G.length - 1,
            "col--fixed": ne.fixed,
            "col--group": it,
            "col--ellipsis": Re,
            "fixed--hidden": vt,
            "is--sortable": ne.sortable,
            "col--filter": !!ne.filters,
            "is--filter-active": Be,
            "col--current": ce === ne
          },
          de ? r.isFunction(de) ? de(q) : de : "",
          se ? r.isFunction(se) ? se(q) : se : ""
        ], colid: Ue, colspan: ne.colSpan > 1 ? ne.colSpan : null, rowspan: ne.rowSpan > 1 ? ne.rowSpan : null, style: P ? r.isFunction(P) ? P(q) : P : null }, z), { key: ye || pe.useKey || pe.drag || it ? Ue : $ }), [
          o("div", {
            class: ["vxe-cell", {
              "c--title": Qe,
              "c--tooltip": De,
              "c--ellipsis": Et
            }]
          }, ne.renderHeader(q)),
          /**
           * 列宽拖动
           */
          !vt && !it && (r.isBoolean(ne.resizable) ? ne.resizable : pe.resizable || K) ? o("div", {
            class: ["vxe-resizable", {
              "is--line": !L || L === "none"
            }],
            onMousedown: (R) => C(R, q)
          }) : null
        ]);
      }).concat(fe ? [
        o("th", {
          key: `gr${ue}`,
          class: "vxe-header--gutter col--gutter"
        })
      ] : []);
    }, Q = (G) => {
      const { fixedType: ue } = e, { headerRowClassName: Y, headerRowStyle: K } = s, { isDragColMove: L } = i, ye = w.value;
      return G.map((se, P) => {
        const M = { $table: t, $rowIndex: P, fixed: ue, type: Pp };
        return ye.drag ? o(Fr, {
          name: `vxe-header--col-list${L ? "" : "-disabled"}`,
          tag: "tr",
          class: [
            "vxe-header--row",
            Y ? r.isFunction(Y) ? Y(M) : Y : ""
          ],
          style: K ? r.isFunction(K) ? K(M) : K : null
        }, {
          default: () => V(se, P)
        }) : o("tr", {
          class: [
            "vxe-header--row",
            Y ? r.isFunction(Y) ? Y(M) : Y : ""
          ],
          style: K ? r.isFunction(K) ? K(M) : K : null
        }, V(se, P));
      });
    }, Z = () => {
      const { fixedType: G, fixedColumn: ue, tableColumn: Y } = e, { showHeaderOverflow: K } = s, { isGroup: L, scrollXLoad: ye, scrollbarWidth: se } = i, { visibleColumn: P } = l;
      let M = D.value, I = Y;
      return L ? I = P : (G && (ye || K) && (I = ue), M = [I]), o("div", {
        ref: S,
        class: ["vxe-table--header-wrapper", G ? `fixed-${G}--wrapper` : "body--wrapper"],
        xid: n
      }, [
        G ? Ve() : o("div", {
          ref: g,
          class: "vxe-body--x-space"
        }),
        o("table", {
          ref: x,
          class: "vxe-table--header",
          xid: n,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          o("colgroup", {
            ref: h
          }, I.map((B, H) => o("col", {
            name: B.id,
            key: H
          })).concat(se ? [
            o("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 头部
           */
          o("thead", {
            ref: O
          }, Q(M))
        ]),
        /**
         * 其他
         */
        o("div", {
          ref: b,
          class: "vxe-table--header-border-line"
        })
      ]);
    };
    return lt(() => e.tableColumn, E), wn(() => {
      me(() => {
        const { fixedType: G } = e, { internalData: ue } = t, { elemStore: Y } = ue, K = `${G || "main"}-header-`;
        Y[`${K}wrapper`] = S, Y[`${K}table`] = x, Y[`${K}colgroup`] = h, Y[`${K}list`] = O, Y[`${K}xSpace`] = g, Y[`${K}repair`] = b, E();
      });
    }), $n(() => {
      const { fixedType: G } = e, { internalData: ue } = t, { elemStore: Y } = ue, K = `${G || "main"}-header-`;
      Y[`${K}wrapper`] = null, Y[`${K}table`] = null, Y[`${K}colgroup`] = null, Y[`${K}list`] = null, Y[`${K}xSpace`] = null, Y[`${K}repair`] = null;
    }), Z;
  }
}), { renderer: AN } = Ce, Vu = "footer";
function BN(e, t, n) {
  for (let s = 0; s < e.length; s++) {
    const { row: i, col: l, rowspan: a, colspan: c } = e[s];
    if (l > -1 && i > -1 && a && c) {
      if (i === t && l === n)
        return { rowspan: a, colspan: c };
      if (t >= i && t < i + a && n >= l && n < l + c)
        return { rowspan: 0, colspan: 0 };
    }
  }
}
const $p = pt({
  name: "VxeTableFooter",
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = mt("$xeTable", {}), { xID: n, props: s, reactData: i, internalData: l } = t, { refTableHeader: a, refTableBody: c, refScrollXHandleElem: m } = t.getRefMaps(), { computeTooltipOpts: u, computeColumnOpts: d } = t.getComputeMaps(), p = ke(), w = ke(), v = ke(), D = ke(), S = ke(), x = (b) => {
      const { inVirtualScroll: E, inBodyScroll: C } = l;
      if (E || C)
        return;
      const { fixedType: V } = e, Q = a.value, Z = c.value, G = Q ? Q.$el : null, ue = p.value;
      if (!ue)
        return;
      const Y = Z ? Z.$el : null;
      if (!Y)
        return;
      const K = m.value, L = ue.scrollLeft, ye = !0, se = !1, P = Y.scrollTop;
      l.inFooterScroll = !0, fo(K, L), fo(G, L), fo(Y, L), t.triggerScrollXEvent(b), t.handleScrollEvent(b, se, ye, P, L, {
        type: Vu,
        fixed: V
      });
    }, h = (b, E, C, V, Q) => {
      const { fixedType: Z } = e, { footerCellClassName: G, footerCellStyle: ue, footerAlign: Y, footerSpanMethod: K, align: L, columnKey: ye, showFooterOverflow: se } = s, { scrollXLoad: P, overflowX: M, scrollbarWidth: I, currentColumn: B, mergeFooterList: H } = i, ce = u.value, A = d.value;
      return b.map((j, fe) => {
        const { type: pe, showFooterOverflow: ne, footerAlign: $, align: J, footerClassName: ge, editRender: Oe, cellRender: Se } = j, de = Oe || Se, Ie = de ? AN.get(de.name) : null, je = ce.showAll, Ue = j.children && j.children.length, Ae = Z ? j.fixed !== Z && !Ue : j.fixed && M, _e = r.eqNull(ne) ? se : ne, it = $ || (Ie ? Ie.tableFooterCellAlign : "") || Y || J || (Ie ? Ie.tableCellAlign : "") || L;
        let vt = _e === "ellipsis";
        const dt = _e === "title", at = _e === !0 || _e === "tooltip";
        let Et = dt || at || vt;
        const Qe = { colid: j.id }, De = {}, Re = t.getColumnIndex(j), Be = t.getVTColumnIndex(j), ve = Be, Ne = {
          $table: t,
          $grid: t.xegrid,
          row: C,
          rowIndex: Q,
          _rowIndex: Q,
          $rowIndex: V,
          column: j,
          columnIndex: Re,
          $columnIndex: fe,
          _columnIndex: Be,
          itemIndex: ve,
          items: C,
          fixed: Z,
          type: Vu,
          data: E
        };
        if (P && !Et && (vt = Et = !0), (dt || at || je) && (De.onMouseenter = (q) => {
          dt ? Ed(q.currentTarget, j) : (at || je) && t.triggerFooterTooltipEvent(q, Ne);
        }), (at || je) && (De.onMouseleave = (q) => {
          (at || je) && t.handleTargetLeaveEvent(q);
        }), De.onClick = (q) => {
          t.dispatchEvent("footer-cell-click", Object.assign({ cell: q.currentTarget }, Ne), q);
        }, De.onDblclick = (q) => {
          t.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: q.currentTarget }, Ne), q);
        }, H.length) {
          const q = BN(H, Q, Be);
          if (q) {
            const { rowspan: z, colspan: R } = q;
            if (!z || !R)
              return null;
            z > 1 && (Qe.rowspan = z), R > 1 && (Qe.colspan = R);
          }
        } else if (K) {
          const { rowspan: q = 1, colspan: z = 1 } = K(Ne) || {};
          if (!q || !z)
            return null;
          q > 1 && (Qe.rowspan = q), z > 1 && (Qe.colspan = z);
        }
        return o("td", Object.assign(Object.assign(Object.assign(Object.assign({ class: ["vxe-footer--column", j.id, {
          [`col--${it}`]: it,
          [`col--${pe}`]: pe,
          "col--last": fe === b.length - 1,
          "fixed--hidden": Ae,
          "col--ellipsis": Et,
          "col--current": B === j
        }, Vr(ge, Ne), Vr(G, Ne)] }, Qe), { style: ue ? r.isFunction(ue) ? ue(Ne) : ue : null }), De), { key: ye || A.useKey || A.drag ? j.id : fe }), [
          o("div", {
            class: ["vxe-cell", {
              "c--title": dt,
              "c--tooltip": at,
              "c--ellipsis": vt
            }]
          }, j.renderFooter(Ne))
        ]);
      }).concat(I ? [
        o("td", {
          key: `gr${V}`,
          class: "vxe-footer--gutter col--gutter"
        })
      ] : []);
    }, O = (b) => {
      const { fixedType: E, tableColumn: C } = e, { footerRowClassName: V, footerRowStyle: Q } = s, { isDragColMove: Z } = i, G = d.value;
      return b.map((ue, Y) => {
        const K = Y, L = { $table: t, row: ue, _rowIndex: K, $rowIndex: Y, fixed: E, type: Vu };
        return G.drag ? o(Fr, {
          name: `vxe-header--col-list${Z ? "" : "-disabled"}`,
          tag: "tr",
          class: [
            "vxe-footer--row",
            V ? r.isFunction(V) ? V(L) : V : ""
          ],
          style: Q ? r.isFunction(Q) ? Q(L) : Q : null
        }, {
          default: () => h(C, b, ue, Y, K)
        }) : o("tr", {
          class: [
            "vxe-footer--row",
            V ? r.isFunction(V) ? V(L) : V : ""
          ],
          style: Q ? r.isFunction(Q) ? Q(L) : Q : null
        }, h(C, b, ue, Y, K));
      });
    }, g = () => {
      let { fixedType: b, fixedColumn: E, tableColumn: C, footerTableData: V } = e;
      const { footerSpanMethod: Q, showFooterOverflow: Z } = s, { visibleColumn: G } = l, { scrollXLoad: ue, scrollbarWidth: Y, mergeFooterList: K } = i;
      b && (!i.expandColumn && (ue || Z) && (!K.length || !Q) ? C = E : C = G);
      const L = {};
      return b || (L.onScroll = x), o("div", Object.assign({ ref: p, class: ["vxe-table--footer-wrapper", b ? `fixed-${b}--wrapper` : "body--wrapper"], xid: n }, L), [
        b ? Ve() : o("div", {
          ref: S,
          class: "vxe-body--x-space"
        }),
        o("table", {
          ref: w,
          class: "vxe-table--footer",
          xid: n,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          o("colgroup", {
            ref: v
          }, C.map((ye, se) => o("col", {
            name: ye.id,
            key: se
          })).concat(Y ? [
            o("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 底部
           */
          o("tfoot", {
            ref: D
          }, O(V))
        ])
      ]);
    };
    return wn(() => {
      me(() => {
        const { fixedType: b } = e, { elemStore: E } = l, C = `${b || "main"}-footer-`;
        E[`${C}wrapper`] = p, E[`${C}table`] = w, E[`${C}colgroup`] = v, E[`${C}list`] = D, E[`${C}xSpace`] = S;
      });
    }), $n(() => {
      const { fixedType: b } = e, { elemStore: E } = l, C = `${b || "main"}-footer-`;
      E[`${C}wrapper`] = null, E[`${C}table`] = null, E[`${C}colgroup`] = null, E[`${C}list`] = null, E[`${C}xSpace`] = null;
    }), g;
  }
}), { getConfig: Zn } = Ce, Sd = {
  /** 基本属性 */
  id: [String, Function],
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: {
    type: [Number, String],
    default: () => Zn().table.minHeight
  },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: {
    type: Boolean,
    default: () => Zn().table.resizable
  },
  // 是否带有斑马纹
  stripe: {
    type: Boolean,
    default: () => Zn().table.stripe
  },
  // 是否带有边框
  border: {
    type: [Boolean, String],
    default: () => Zn().table.border
  },
  // 单元格是否有边距
  padding: {
    type: Boolean,
    default: () => Zn().table.padding
  },
  // 是否圆角边框
  round: {
    type: Boolean,
    default: () => Zn().table.round
  },
  // 表格的尺寸
  size: {
    type: String,
    default: () => Zn().table.size || Zn().size
  },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: {
    type: Boolean,
    default: () => Zn().table.fit
  },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: {
    type: String,
    default: () => Zn().table.align
  },
  // 所有的表头列的对齐方式
  headerAlign: {
    type: String,
    default: () => Zn().table.headerAlign
  },
  // 所有的表尾列的对齐方式
  footerAlign: {
    type: String,
    default: () => Zn().table.footerAlign
  },
  // 是否显示表头
  showHeader: {
    type: Boolean,
    default: () => Zn().table.showHeader
  },
  // （即将废弃）是否要高亮当前选中行
  highlightCurrentRow: {
    type: Boolean,
    default: () => Zn().table.highlightCurrentRow
  },
  // （即将废弃）鼠标移到行是否要高亮显示
  highlightHoverRow: {
    type: Boolean,
    default: () => Zn().table.highlightHoverRow
  },
  // （即将废弃）是否要高亮当前选中列
  highlightCurrentColumn: {
    type: Boolean,
    default: () => Zn().table.highlightCurrentColumn
  },
  // （即将废弃）鼠标移到列是否要高亮显示
  highlightHoverColumn: {
    type: Boolean,
    default: () => Zn().table.highlightHoverColumn
  },
  // （即将废弃）激活单元格编辑时是否高亮显示
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 合并指定单元格
  mergeCells: Array,
  // 合并指定的表尾
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: () => Zn().table.showOverflow
  },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => Zn().table.showHeaderOverflow
  },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => Zn().table.showFooterOverflow
  },
  /** 高级属性 */
  // （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
  columnKey: Boolean,
  // （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
  rowKey: Boolean,
  // （即将废弃）rowId 已废弃，被 row-config.keyField 替换
  rowId: {
    type: String,
    default: () => Zn().table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => Zn().table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => Zn().table.keepSource
  },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: {
    type: Boolean,
    default: () => Zn().table.autoResize
  },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置信息
  columnConfig: Object,
  // 单元格配置信息
  cellConfig: Object,
  // 行配置信息
  rowConfig: Object,
  // 已废弃，被 rowDragConfig 替换
  dragConfig: Object,
  // 行拖拽排序配置项
  rowDragConfig: Object,
  // 列拖拽排序配置项
  columnDragConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 导出配置项
  exportConfig: Object,
  // 导入配置项
  importConfig: Object,
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: Object,
  // 快捷菜单配置项
  menuConfig: Object,
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制粘/贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: Object,
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: Object,
  // 自定义列配置项
  customConfig: Object,
  // 横向虚拟滚动配置项
  scrollX: Object,
  // 纵向虚拟滚动配置项
  scrollY: Object,
  // （即将废弃）优化相关
  animat: {
    type: Boolean,
    default: () => Zn().table.animat
  },
  // （可能会被废弃的参数，不要使用）
  delayHover: {
    type: Number,
    default: () => Zn().table.delayHover
  },
  // 额外的参数
  params: Object
}, Dd = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "current-change",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "checkbox-range-select",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "cell-delete-value",
  "cell-backspace-value",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "resizable-change",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "row-dragstart",
  "row-dragover",
  "row-dragend",
  "column-dragstart",
  "column-dragover",
  "column-dragend",
  "enter-append-row",
  "edit-actived",
  "edit-activated",
  "edit-disabled",
  "valid-error",
  "scroll",
  "scroll-boundary",
  "custom",
  "change-fnr",
  "open-fnr",
  "show-fnr",
  "hide-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-selection",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-invalid",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-selection-all-start",
  "cell-area-selection-all-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
], { getI18n: Ln, getIcon: So, renderEmptyElement: ba } = Ce, _N = pt({
  name: "TableCustomPanel",
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(e) {
    const t = Ce.getComponent("VxeModal"), n = Ce.getComponent("VxeDrawer"), s = Ce.getComponent("VxeButton"), i = Ce.getComponent("VxeNumberInput"), l = Ce.getComponent("VxeTooltip"), a = Ce.getComponent("VxeRadioGroup"), c = mt("$xeTable", {}), { props: m, reactData: u } = c, { computeCustomOpts: d, computeColumnOpts: p, computeIsMaxFixedColumn: w, computeResizableOpts: v } = c.getComputeMaps(), D = ke(), S = ke(), x = ke(), h = ke();
    let O;
    const g = (A) => {
      const { customStore: j } = e;
      j.activeWrapper = !0, c.customOpenEvent(A);
    }, b = (A) => {
      const { customStore: j } = e;
      j.activeWrapper = !1, setTimeout(() => {
        !j.activeBtn && !j.activeWrapper && c.customCloseEvent(A);
      }, 300);
    }, E = ({ $event: A }) => {
      c.saveCustom(), c.closeCustom(), c.emitCustomEvent("confirm", A);
    }, C = ({ $event: A }) => {
      c.closeCustom(), c.emitCustomEvent("close", A);
    }, V = ({ $event: A }) => {
      c.cancelCustom(), c.closeCustom(), c.emitCustomEvent("cancel", A);
    }, Q = (A) => {
      c.resetCustom(!0), c.closeCustom(), c.emitCustomEvent("reset", A);
    }, Z = ({ $event: A }) => {
      Ce.modal ? Ce.modal.confirm({
        content: Ln("vxe.custom.cstmConfirmRestore"),
        className: "vxe-table--ignore-clear",
        escClosable: !0
      }).then((j) => {
        j === "confirm" && Q(A);
      }) : Q(A);
    }, G = (A) => {
      const { customColumnList: j } = u, fe = r.findTree(j, (pe) => pe === A);
      if (fe && fe.parent) {
        const { parent: pe } = fe;
        pe.children && pe.children.length && (pe.renderVisible = pe.children.every((ne) => ne.renderVisible), pe.halfVisible = !pe.renderVisible && pe.children.some((ne) => ne.renderVisible || ne.halfVisible), G(pe));
      }
    }, ue = (A) => {
      const j = !A.renderVisible;
      d.value.immediate ? (r.eachTree([A], (pe) => {
        pe.visible = j, pe.renderVisible = j, pe.halfVisible = !1;
      }), c.handleCustom(), c.saveCustomStore("update:visible")) : r.eachTree([A], (pe) => {
        pe.renderVisible = j, pe.halfVisible = !1;
      }), G(A), c.checkCustomStatus();
    }, Y = (A, j) => {
      const fe = w.value;
      d.value.immediate ? (A.renderFixed === j ? r.eachTree([A], (ne) => {
        ne.fixed = "", ne.renderFixed = "";
      }) : (!fe || A.renderFixed) && r.eachTree([A], (ne) => {
        ne.fixed = j, ne.renderFixed = j;
      }), c.handleCustom(), c.saveCustomStore("update:fixed")) : A.renderFixed === j ? r.eachTree([A], (ne) => {
        ne.renderFixed = "";
      }) : (!fe || A.renderFixed) && r.eachTree([A], (ne) => {
        ne.renderFixed = j;
      });
    }, K = () => {
      c.toggleCustomAllCheckbox();
    }, L = (A) => {
      const pe = A.currentTarget.parentNode.parentNode, ne = pe.getAttribute("colid"), $ = c.getColumnById(ne);
      pe.draggable = !0, h.value = $, Ms(pe, "active--drag-origin"), I(A);
    }, ye = (A) => {
      const pe = A.currentTarget.parentNode.parentNode, ne = x.value;
      pe.draggable = !1, h.value = null, jo(pe, "active--drag-origin"), ne && (ne.style.display = "");
    }, se = (A) => {
      const j = new Image();
      A.dataTransfer && A.dataTransfer.setDragImage(j, 0, 0);
    }, P = (A) => {
      const { customColumnList: j } = u, fe = d.value, pe = A.currentTarget, ne = x.value;
      if (O) {
        if (O !== pe) {
          const $ = O.getAttribute("drag-pos"), J = pe.getAttribute("colid"), ge = c.getColumnById(J);
          if (!ge)
            return;
          const Oe = r.findIndexOf(j, (je) => je.id === ge.id), Se = O.getAttribute("colid"), de = c.getColumnById(Se);
          if (!de)
            return;
          j.splice(Oe, 1);
          const Ie = r.findIndexOf(j, (je) => je.id === de.id);
          j.splice(Ie + ($ === "bottom" ? 1 : 0), 0, ge);
        }
        O.draggable = !1, O.removeAttribute("drag-pos"), jo(O, "active--drag-target");
      }
      h.value = null, pe.draggable = !1, pe.removeAttribute("drag-pos"), ne && (ne.style.display = ""), jo(pe, "active--drag-target"), jo(pe, "active--drag-origin"), fe.immediate && (r.eachTree(j, ($, J, ge, Oe, Se) => {
        if (!Se) {
          const de = J + 1;
          $.renderSortNumber = de;
        }
      }), c.handleCustom(), c.saveCustomStore("update:sort"));
    }, M = (A) => {
      const j = A.currentTarget;
      O !== j && jo(O, "active--drag-target");
      const fe = j.getAttribute("colid"), pe = c.getColumnById(fe);
      if (pe && pe.level === 1) {
        A.preventDefault();
        const $ = A.clientY - j.getBoundingClientRect().y < j.clientHeight / 2 ? "top" : "bottom";
        Ms(j, "active--drag-target"), j.setAttribute("drag-pos", $), O = j;
      }
      I(A);
    }, I = (A) => {
      const j = x.value, fe = S.value;
      if (fe && j) {
        const pe = fe.parentNode, ne = pe.getBoundingClientRect();
        j.style.display = "block", j.style.top = `${Math.min(pe.clientHeight - pe.scrollTop - j.clientHeight, A.clientY - ne.y)}px`, j.style.left = `${Math.min(pe.clientWidth - pe.scrollLeft - j.clientWidth - 16, A.clientX - ne.x)}px`;
      }
    }, B = () => {
      const { customStore: A } = e, { isCustomStatus: j, customColumnList: fe } = u, pe = d.value, { maxHeight: ne } = A, { checkMethod: $, visibleMethod: J, allowVisible: ge, allowSort: Oe, allowFixed: Se, trigger: de, placement: Ie } = pe, je = w.value, Ue = pe.slots || {}, Ae = Ue.header, _e = Ue.top, it = Ue.bottom, vt = Ue.default, dt = Ue.footer, at = [], Et = {}, Qe = A.isAll, De = A.isIndeterminate, Re = h.value;
      de === "hover" && (Et.onMouseenter = g, Et.onMouseleave = b);
      const Be = {
        $table: c,
        $grid: c.xegrid,
        columns: fe,
        isAllChecked: Qe,
        isAllIndeterminate: De,
        isCustomStatus: j
      };
      return r.eachTree(fe, (ve, Ne, q, z, R) => {
        if (J ? J({ column: ve }) : !0) {
          const F = ve.renderVisible, re = ve.halfVisible, N = ve.children && ve.children.length, ee = po(ve.getTitle(), 1), be = $ ? !$({ column: ve }) : !1, we = !F;
          at.push(o("li", {
            key: ve.id,
            colid: ve.id,
            class: ["vxe-table-custom--option", `level--${ve.level}`, {
              "is--hidden": be || we,
              "is--group": N
            }],
            onDragstart: se,
            onDragend: P,
            onDragover: M
          }, [
            ge ? o("div", {
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": F,
                "is--indeterminate": re,
                "is--disabled": be
              }],
              title: Ln("vxe.custom.setting.colVisible"),
              onClick: () => {
                be || ue(ve);
              }
            }, [
              o("span", {
                class: ["vxe-checkbox--icon", re ? So().TABLE_CHECKBOX_INDETERMINATE : F ? So().TABLE_CHECKBOX_CHECKED : So().TABLE_CHECKBOX_UNCHECKED]
              })
            ]) : Ve(),
            Oe && ve.level === 1 ? o("div", {
              class: "vxe-table-custom--sort-option"
            }, [
              o("span", Object.assign({ class: ["vxe-table-custom--sort-btn", {
                "is--disabled": be || we
              }], title: Ln("vxe.custom.setting.sortHelpTip") }, be || we ? {} : {
                onMousedown: L,
                onMouseup: ye
              }), [
                o("i", {
                  class: So().TABLE_CUSTOM_SORT
                })
              ])
            ]) : Ve(),
            ve.type === "html" ? o("div", {
              key: "1",
              class: "vxe-table-custom--checkbox-label",
              innerHTML: ee
            }) : o("div", {
              key: "0",
              class: "vxe-table-custom--checkbox-label"
            }, ee),
            !R && Se ? o("div", {
              class: "vxe-table-custom--fixed-option"
            }, [
              s ? o(s, {
                mode: "text",
                icon: ve.renderFixed === "left" ? So().TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE : So().TOOLBAR_TOOLS_FIXED_LEFT,
                status: ve.renderFixed === "left" ? "primary" : "",
                disabled: be || we || je && !ve.renderFixed,
                title: Ln(ve.renderFixed === "left" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedLeft"),
                onClick: () => {
                  Y(ve, "left");
                }
              }) : Ve(),
              s ? o(s, {
                mode: "text",
                icon: ve.renderFixed === "right" ? So().TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE : So().TOOLBAR_TOOLS_FIXED_RIGHT,
                status: ve.renderFixed === "right" ? "primary" : "",
                disabled: be || we || je && !ve.renderFixed,
                title: Ln(ve.renderFixed === "right" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedRight"),
                onClick: () => {
                  Y(ve, "right");
                }
              }) : Ve()
            ]) : Ve()
          ]));
        }
      }), o("div", {
        ref: D,
        key: "simple",
        class: ["vxe-table-custom-wrapper", `placement--${Ie}`, {
          "is--active": A.visible
        }],
        style: ne && !["left", "right"].includes(Ie) ? {
          maxHeight: `${ne}px`
        } : {}
      }, A.visible ? [
        o("div", {
          class: "vxe-table-custom--header"
        }, Ae ? c.callSlot(Ae, Be) : [
          o("ul", {
            class: "vxe-table-custom--panel-list"
          }, [
            o("li", {
              class: "vxe-table-custom--option"
            }, [
              ge ? o("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": Qe,
                  "is--indeterminate": De
                }],
                title: Ln("vxe.table.allTitle"),
                onClick: K
              }, [
                o("span", {
                  class: ["vxe-checkbox--icon", De ? So().TABLE_CHECKBOX_INDETERMINATE : Qe ? So().TABLE_CHECKBOX_CHECKED : So().TABLE_CHECKBOX_UNCHECKED]
                }),
                o("span", {
                  class: "vxe-checkbox--label"
                }, Ln("vxe.toolbar.customAll"))
              ]) : o("span", {
                class: "vxe-checkbox--label"
              }, Ln("vxe.table.customTitle"))
            ])
          ])
        ]),
        o("div", {
          ref: S,
          class: "vxe-table-custom--body"
        }, [
          _e ? o("div", {
            class: "vxe-table-custom--panel-top"
          }, c.callSlot(_e, Be)) : ba(c),
          vt ? o("div", {
            class: "vxe-table-custom--panel-body"
          }, c.callSlot(vt, Be)) : o(Fr, Object.assign({ class: "vxe-table-custom--panel-list", name: "vxe-table-custom--list", tag: "ul" }, Et), {
            default: () => at
          }),
          it ? o("div", {
            class: "vxe-table-custom--panel-bottom"
          }, c.callSlot(it, Be)) : ba(c),
          o("div", {
            ref: x,
            class: "vxe-table-custom-popup--drag-hint"
          }, Ln("vxe.custom.cstmDragTarget", [Re && Re.type !== "html" ? Re.getTitle() : ""]))
        ]),
        pe.showFooter ? o("div", {
          class: "vxe-table-custom--footer"
        }, dt ? c.callSlot(dt, Be) : [
          o("div", {
            class: "vxe-table-custom--footer-buttons"
          }, [
            s ? o(s, {
              mode: "text",
              content: pe.resetButtonText || Ln("vxe.table.customRestore"),
              disabled: !j,
              onClick: Z
            }) : Ve(),
            pe.immediate ? s ? o(s, {
              mode: "text",
              content: pe.closeButtonText || Ln("vxe.table.customClose"),
              onClick: C
            }) : Ve() : s ? o(s, {
              mode: "text",
              content: pe.cancelButtonText || Ln("vxe.table.customCancel"),
              onClick: V
            }) : Ve(),
            pe.immediate ? Ve() : s ? o(s, {
              mode: "text",
              status: "primary",
              content: pe.confirmButtonText || Ln("vxe.table.customConfirm"),
              onClick: E
            }) : Ve()
          ])
        ]) : null
      ] : []);
    }, H = () => {
      const { customStore: A } = e, { resizable: j } = m, { isCustomStatus: fe, customColumnList: pe } = u, ne = d.value, { mode: $, modalOptions: J, drawerOptions: ge, allowVisible: Oe, allowSort: Se, allowFixed: de, allowResizable: Ie, checkMethod: je, visibleMethod: Ue } = ne, Ae = p.value, { maxFixedSize: _e } = Ae, it = v.value, { minWidth: vt, maxWidth: dt } = it, at = Object.assign({}, J), Et = Object.assign({}, ge), Qe = w.value, De = ne.slots || {}, Re = De.header, Be = De.top, ve = De.bottom, Ne = De.default, q = De.footer, z = [], R = A.isAll, le = A.isIndeterminate, F = h.value, re = {
        $table: c,
        $grid: c.xegrid,
        columns: pe,
        isAllChecked: R,
        isAllIndeterminate: le,
        isCustomStatus: fe
      };
      r.eachTree(pe, (ee, be, we, Te, ze) => {
        if (Ue ? Ue({ column: ee }) : !0) {
          let ct = 0, Ke = 0;
          if (Ie) {
            const At = {
              $table: c,
              column: ee,
              columnIndex: be,
              $columnIndex: be,
              $rowIndex: -1
            };
            vt && (ct = r.toNumber(r.isFunction(vt) ? vt(At) : vt)), dt && (Ke = r.toNumber(r.isFunction(dt) ? dt(At) : dt));
          }
          const wt = ee.renderVisible, St = ee.halfVisible, Dt = po(ee.getTitle(), 1), Wt = ee.children && ee.children.length, nn = je ? !je({ column: ee }) : !1, zt = !wt;
          z.push(o("tr", {
            key: ee.id,
            colid: ee.id,
            class: [`vxe-table-custom-popup--row level--${ee.level}`, {
              "is--group": Wt
            }],
            onDragstart: se,
            onDragend: P,
            onDragover: M
          }, [
            Oe ? o("td", {
              class: "vxe-table-custom-popup--column-item col--visible"
            }, [
              o("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": wt,
                  "is--indeterminate": St,
                  "is--disabled": nn
                }],
                title: Ln("vxe.custom.setting.colVisible"),
                onClick: () => {
                  nn || ue(ee);
                }
              }, [
                o("span", {
                  class: ["vxe-checkbox--icon", St ? So().TABLE_CHECKBOX_INDETERMINATE : wt ? So().TABLE_CHECKBOX_CHECKED : So().TABLE_CHECKBOX_UNCHECKED]
                })
              ])
            ]) : Ve(),
            Se ? o("td", {
              class: "vxe-table-custom-popup--column-item col--sort"
            }, [
              ee.level === 1 ? o("span", Object.assign({ class: ["vxe-table-custom-popup--column-sort-btn", {
                "is--disabled": nn || zt
              }], title: Ln("vxe.custom.setting.sortHelpTip") }, nn || zt ? {} : {
                onMousedown: L,
                onMouseup: ye
              }), [
                o("i", {
                  class: So().TABLE_CUSTOM_SORT
                })
              ]) : o("span", "-")
            ]) : Ve(),
            o("td", {
              class: "vxe-table-custom-popup--column-item col--name"
            }, [
              ee.type === "html" ? o("div", {
                key: "1",
                class: "vxe-table-custom-popup--name",
                innerHTML: Dt
              }) : o("div", {
                key: "0",
                class: "vxe-table-custom-popup--name",
                title: Dt
              }, Dt)
            ]),
            Ie ? o("td", {
              class: "vxe-table-custom-popup--column-item col--resizable"
            }, [
              ee.children && ee.children.length || !(r.isBoolean(ee.resizable) ? ee.resizable : Ae.resizable || j) ? o("span", "-") : i ? o(i, {
                type: "integer",
                disabled: nn || zt,
                modelValue: ee.renderResizeWidth,
                min: ct || void 0,
                max: Ke || void 0,
                "onUpdate:modelValue"(At) {
                  ee.renderResizeWidth = Math.max(0, Number(At));
                }
              }) : Ve()
            ]) : Ve(),
            de ? o("td", {
              class: "vxe-table-custom-popup--column-item col--fixed"
            }, [
              ze ? o("span", "-") : a ? o(a, {
                modelValue: ee.renderFixed || "",
                type: "button",
                size: "mini",
                disabled: nn || zt,
                options: [
                  { label: Ln("vxe.custom.setting.fixedLeft"), value: "left", disabled: nn || zt || Qe },
                  { label: Ln("vxe.custom.setting.fixedUnset"), value: "", disabled: nn || zt },
                  { label: Ln("vxe.custom.setting.fixedRight"), value: "right", disabled: nn || zt || Qe }
                ],
                "onUpdate:modelValue"(At) {
                  ee.renderFixed = At;
                }
              }) : Ve()
            ]) : Ve()
          ]));
        }
      });
      const N = {
        default: () => Ne ? c.callSlot(Ne, re) : o("div", {
          ref: S,
          class: "vxe-table-custom-popup--body"
        }, [
          Be ? o("div", {
            class: "vxe-table-custom-popup--table-top"
          }, c.callSlot(Be, re)) : ba(c),
          o("div", {
            class: "vxe-table-custom-popup--table-wrapper"
          }, [
            o("table", {}, [
              o("colgroup", {}, [
                Oe ? o("col", {
                  class: "vxe-table-custom-popup--table-col-seq"
                }) : Ve(),
                Se ? o("col", {
                  class: "vxe-table-custom-popup--table-col-sort"
                }) : Ve(),
                o("col", {
                  class: "vxe-table-custom-popup--table-col-title"
                }),
                Ie ? o("col", {
                  class: "vxe-table-custom-popup--table-col-width"
                }) : Ve(),
                de ? o("col", {
                  class: "vxe-table-custom-popup--table-col-fixed"
                }) : Ve()
              ]),
              o("thead", {}, [
                o("tr", {}, [
                  Oe ? o("th", {}, [
                    o("div", {
                      class: ["vxe-table-custom--checkbox-option", {
                        "is--checked": R,
                        "is--indeterminate": le
                      }],
                      title: Ln("vxe.table.allTitle"),
                      onClick: K
                    }, [
                      o("span", {
                        class: ["vxe-checkbox--icon", le ? So().TABLE_CHECKBOX_INDETERMINATE : R ? So().TABLE_CHECKBOX_CHECKED : So().TABLE_CHECKBOX_UNCHECKED]
                      }),
                      o("span", {
                        class: "vxe-checkbox--label"
                      }, Ln("vxe.toolbar.customAll"))
                    ])
                  ]) : Ve(),
                  Se ? o("th", {}, [
                    o("span", {
                      class: "vxe-table-custom-popup--table-sort-help-title"
                    }, Ln("vxe.custom.setting.colSort")),
                    l ? o(l, {
                      enterable: !0,
                      content: Ln("vxe.custom.setting.sortHelpTip"),
                      popupClassName: "vxe-table--ignore-clear"
                    }, {
                      default: () => o("i", {
                        class: "vxe-table-custom-popup--table-sort-help-icon vxe-icon-question-circle-fill"
                      })
                    }) : Ve()
                  ]) : Ve(),
                  o("th", {}, Ln("vxe.custom.setting.colTitle")),
                  Ie ? o("th", {}, Ln("vxe.custom.setting.colResizable")) : Ve(),
                  de ? o("th", {}, Ln(`vxe.custom.setting.${_e ? "colFixedMax" : "colFixed"}`, [_e])) : Ve()
                ])
              ]),
              o(Fr, {
                class: "vxe-table-custom--panel-list",
                tag: "tbody",
                name: "vxe-table-custom--list"
              }, {
                default: () => z
              })
            ])
          ]),
          ve ? o("div", {
            class: "vxe-table-custom-popup--table-bottom"
          }, c.callSlot(ve, re)) : ba(c),
          o("div", {
            ref: x,
            class: "vxe-table-custom-popup--drag-hint"
          }, Ln("vxe.custom.cstmDragTarget", [F ? F.getTitle() : ""]))
        ]),
        footer: () => q ? c.callSlot(q, re) : o("div", {
          class: "vxe-table-custom-popup--footer"
        }, [
          s ? o(s, {
            content: ne.resetButtonText || Ln("vxe.custom.cstmRestore"),
            disabled: !fe,
            onClick: Z
          }) : Ve(),
          s ? o(s, {
            content: ne.resetButtonText || Ln("vxe.custom.cstmCancel"),
            onClick: V
          }) : Ve(),
          s ? o(s, {
            status: "primary",
            content: ne.confirmButtonText || Ln("vxe.custom.cstmConfirm"),
            onClick: E
          }) : Ve()
        ])
      };
      return Re && (N.header = () => c.callSlot(Re, re)), $ === "drawer" ? n ? o(n, {
        key: "drawer",
        className: ["vxe-table-custom-drawer-wrapper", "vxe-table--ignore-clear", Et.className || ""].join(" "),
        modelValue: A.visible,
        title: Et.title || Ln("vxe.custom.cstmTitle"),
        width: Et.width || Math.min(880, Math.floor(document.documentElement.clientWidth * 0.6)),
        position: Et.position,
        resize: !!Et.resize,
        escClosable: !!Et.escClosable,
        maskClosable: !!Et.maskClosable,
        destroyOnClose: !0,
        showFooter: !0,
        "onUpdate:modelValue"(ee) {
          A.visible = ee;
        }
      }, N) : Ve() : t ? o(t, {
        key: "modal",
        className: ["vxe-table-custom-modal-wrapper", "vxe-table--ignore-clear", at.className || ""].join(" "),
        modelValue: A.visible,
        title: at.title || Ln("vxe.custom.cstmTitle"),
        width: at.width || Math.min(880, document.documentElement.clientWidth),
        minWidth: at.minWidth || 700,
        height: at.height || Math.min(680, document.documentElement.clientHeight),
        minHeight: at.minHeight || 400,
        showZoom: at.showZoom,
        showMaximize: at.showMaximize,
        showMinimize: at.showMinimize,
        mask: at.mask,
        lockView: at.lockView,
        resize: at.resize,
        escClosable: !!at.escClosable,
        maskClosable: !!at.maskClosable,
        destroyOnClose: !0,
        showFooter: !0,
        "onUpdate:modelValue"(ee) {
          A.visible = ee;
        }
      }, N) : Ve();
    }, ce = () => {
      const A = d.value;
      return ["modal", "drawer", "popup"].includes(`${A.mode}`) ? H() : B();
    };
    return process.env.NODE_ENV === "development" && me(() => {
      const A = d.value, { mode: j } = A;
      t || Ut("vxe.error.reqComp", ["vxe-modal"]), !n && j === "drawer" && Ut("vxe.error.reqComp", ["vxe-drawer"]), s || Ut("vxe.error.reqComp", ["vxe-button"]), i || Ut("vxe.error.reqComp", ["vxe-number-input"]), l || Ut("vxe.error.reqComp", ["vxe-tooltip"]), a || Ut("vxe.error.reqComp", ["vxe-radio-group"]);
    }), ce;
  }
}), { getI18n: xa, getIcon: hi, renderer: Rp } = Ce, WN = pt({
  name: "VxeTableFilterPanel",
  props: {
    filterStore: Object
  },
  setup(e) {
    const t = mt("$xeTable", {}), { reactData: n, internalData: s, getComputeMaps: i } = t, { computeFilterOpts: l } = i(), a = _(() => {
      const { filterStore: O } = e;
      return O && O.options.some((g) => g.checked);
    }), c = (O, g) => {
      const { filterStore: b } = e;
      b.options.forEach((E) => {
        E._checked = g, E.checked = g;
      }), b.isAllSelected = g, b.isIndeterminate = !1;
    }, m = (O) => {
      t.handleFilterConfirmFilter(O);
    }, u = (O, g, b) => {
      t.handleFilterChangeRadioOption(O, g, b);
    }, d = (O) => {
      t.handleFilterResetFilter(O);
    }, p = (O, g, b) => {
      t.handleFilterChangeMultipleOption(O, g, b);
    }, w = (O, g, b) => {
      t.handleFilterChangeOption(O, g, b);
    }, v = (O, g) => {
      const { filterStore: b } = e;
      b.multiple ? c(O, g) : d(O);
    }, D = {
      changeRadioOption: u,
      changeMultipleOption: p,
      changeAllOption: v,
      changeOption: w,
      confirmFilter: m,
      resetFilter: d
    }, S = (O, g) => {
      const { filterStore: b } = e, { column: E, multiple: C, maxHeight: V } = b, Q = E ? E.slots : null, Z = Q ? Q.filter : null, G = Object.assign({}, s._currFilterParams, { $panel: D, $table: t }), ue = g ? g.renderTableFilter || g.renderFilter : null;
      if (Z)
        return [
          o("div", {
            class: "vxe-table--filter-template"
          }, t.callSlot(Z, G))
        ];
      if (ue)
        return [
          o("div", {
            class: "vxe-table--filter-template"
          }, cs(ue(O, G)))
        ];
      const Y = C ? b.isAllSelected : !b.options.some((L) => L._checked), K = C && b.isIndeterminate;
      return [
        o("ul", {
          class: "vxe-table--filter-header"
        }, [
          o("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": Y,
              "is--indeterminate": K
            }],
            title: xa(C ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: (L) => {
              v(L, !b.isAllSelected);
            }
          }, (C ? [
            o("span", {
              class: ["vxe-checkbox--icon", K ? hi().TABLE_CHECKBOX_INDETERMINATE : Y ? hi().TABLE_CHECKBOX_CHECKED : hi().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            o("span", {
              class: "vxe-checkbox--label"
            }, xa("vxe.table.allFilter"))
          ]))
        ]),
        o("ul", {
          class: "vxe-table--filter-body",
          style: V ? {
            maxHeight: `${V}px`
          } : {}
        }, b.options.map((L) => {
          const ye = L._checked;
          return o("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": L._checked
            }],
            title: L.label,
            onClick: (se) => {
              w(se, !L._checked, L);
            }
          }, (C ? [
            o("span", {
              class: ["vxe-checkbox--icon", ye ? hi().TABLE_CHECKBOX_CHECKED : hi().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            o("span", {
              class: "vxe-checkbox--label"
            }, po(L.label, 1))
          ]));
        }))
      ];
    }, x = () => {
      const { filterStore: O } = e, { column: g, multiple: b } = O, E = l.value, C = a.value, { filterRender: V } = g, Q = fn(V) ? Rp.get(V.name) : null, Z = !C && !O.isAllSelected && !O.isIndeterminate;
      return b && (!Q || !(Q.showTableFilterFooter === !1 || Q.showFilterFooter === !1 || Q.isFooter === !1)) ? [
        o("div", {
          class: "vxe-table--filter-footer"
        }, [
          o("button", {
            class: {
              "is--disabled": Z
            },
            disabled: Z,
            onClick: m
          }, E.confirmButtonText || xa("vxe.table.confirmFilter")),
          o("button", {
            onClick: d
          }, E.resetButtonText || xa("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    return () => {
      const { filterStore: O } = e, { initStore: g } = n, { column: b } = O, E = b ? b.filterRender : null, C = fn(E) ? Rp.get(E.name) : null, V = C ? C.tableFilterClassName || C.filterClassName : "", Q = Object.assign({}, s._currFilterParams, { $panel: D, $table: t });
      return o("div", {
        class: [
          "vxe-table--filter-wrapper",
          "filter--prevent-default",
          Vr(V, Q),
          {
            "is--animat": t.props.animat,
            "is--multiple": O.multiple,
            "is--active": O.visible
          }
        ],
        style: O.style
      }, g.filter && b ? S(E, C).concat(x()) : []);
    };
  }
}), { getI18n: Kr, getIcon: zN } = Ce, HN = pt({
  name: "VxeTableImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(e) {
    const t = Ce.getComponent("VxeModal"), n = Ce.getComponent("VxeButton"), s = Ce.getComponent("VxeSelect"), i = mt("$xeTable", {}), { computeImportOpts: l } = i.getComputeMaps(), a = Rt({
      loading: !1
    }), c = ke(), m = _(() => {
      const { storeData: h } = e;
      return `${h.filename}.${h.type}`;
    }), u = _(() => {
      const { storeData: h } = e;
      return h.file && h.type;
    }), d = _(() => {
      const { storeData: h } = e, { type: O, typeList: g } = h;
      if (O) {
        const b = r.find(g, (E) => O === E.value);
        return b ? b.label : "*.*";
      }
      return `*.${g.map((b) => b.value).join(", *.")}`;
    }), p = () => {
      const { storeData: h } = e;
      Object.assign(h, {
        filename: "",
        sheetName: "",
        type: ""
      });
    }, w = () => {
      const { storeData: h, defaultOptions: O } = e;
      i.readFile(O).then((g) => {
        const { file: b } = g;
        Object.assign(h, $h(b), { file: b });
      }).catch((g) => g);
    }, v = () => {
      me(() => {
        const h = c.value;
        h && h.focus();
      });
    }, D = () => {
      const { storeData: h } = e;
      h.visible = !1;
    }, S = () => {
      const { storeData: h, defaultOptions: O } = e, g = l.value;
      a.loading = !0, i.importByFile(h.file, Object.assign({}, g, O)).then(() => {
        a.loading = !1, h.visible = !1;
      }).catch(() => {
        a.loading = !1;
      });
    }, x = () => {
      const { defaultOptions: h, storeData: O } = e, g = m.value, b = u.value, E = d.value, C = h.slots || {}, V = C.top, Q = C.bottom, Z = C.default, G = C.footer;
      return t ? o(t, {
        id: "VXE_IMPORT_MODAL",
        modelValue: O.visible,
        title: Kr("vxe.import.impTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 540,
        minWidth: 360,
        minHeight: 240,
        mask: !0,
        lockView: !0,
        showFooter: !0,
        escClosable: !0,
        maskClosable: !0,
        showMaximize: !0,
        resize: !0,
        loading: a.loading,
        "onUpdate:modelValue"(ue) {
          O.visible = ue;
        },
        onShow: v
      }, {
        default: () => {
          const ue = {
            $table: i,
            $grid: i.xegrid,
            options: h,
            params: h.params
          };
          return o("div", {
            class: "vxe-table-export--panel"
          }, [
            V ? o("div", {
              class: "vxe-table-export--panel-top"
            }, i.callSlot(V, ue)) : Ve(),
            o("div", {
              class: "vxe-table-export--panel-body"
            }, Z ? i.callSlot(Z, ue) : [
              o("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                o("tbody", [
                  o("tr", [
                    o("td", Kr("vxe.import.impFile")),
                    o("td", [
                      b ? o("div", {
                        class: "vxe-table-export--selected--file",
                        title: g
                      }, [
                        o("span", g),
                        o("i", {
                          class: zN().INPUT_CLEAR,
                          onClick: p
                        })
                      ]) : o("button", {
                        ref: c,
                        class: "vxe-table-export--select--file",
                        onClick: w
                      }, Kr("vxe.import.impSelect"))
                    ])
                  ]),
                  o("tr", [
                    o("td", Kr("vxe.import.impType")),
                    o("td", E)
                  ]),
                  o("tr", [
                    o("td", Kr("vxe.import.impMode")),
                    o("td", [
                      s ? o(s, {
                        modelValue: h.mode,
                        options: O.modeList,
                        "onUpdate:modelValue"(Y) {
                          h.mode = Y;
                        }
                      }) : Ve()
                    ])
                  ])
                ])
              ])
            ]),
            Q ? o("div", {
              class: "vxe-table-export--panel-bottom"
            }, i.callSlot(Q, ue)) : Ve()
          ]);
        },
        footer() {
          const ue = {
            $table: i,
            $grid: i.xegrid,
            options: h,
            params: h.params
          };
          return o("div", {
            class: "vxe-table-export--panel-footer"
          }, G ? i.callSlot(G, ue) : [
            o("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              n ? o(n, {
                content: Kr("vxe.import.impCancel"),
                onClick: D
              }) : Ve(),
              n ? o(n, {
                status: "primary",
                disabled: !b || a.loading,
                content: Kr("vxe.import.impConfirm"),
                onClick: S
              }) : Ve()
            ])
          ]);
        }
      }) : Ve();
    };
    return process.env.NODE_ENV === "development" && me(() => {
      t || Ut("vxe.error.reqComp", ["vxe-modal"]), n || Ut("vxe.error.reqComp", ["vxe-button"]), s || Ut("vxe.error.reqComp", ["vxe-select"]);
    }), x;
  }
}), { getI18n: Un, getIcon: vl } = Ce, jN = pt({
  name: "VxeTableExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(e) {
    const t = Ce.getComponent("VxeModal"), n = Ce.getComponent("VxeButton"), s = Ce.getComponent("VxeSelect"), i = Ce.getComponent("VxeInput"), l = Ce.getComponent("VxeCheckbox"), a = mt("$xeTable", {}), { computeExportOpts: c, computePrintOpts: m } = a.getComputeMaps(), u = Rt({
      isAll: !1,
      isIndeterminate: !1,
      loading: !1
    }), d = ke(), p = ke(), w = ke(), v = _(() => {
      const { storeData: Y } = e;
      return Y.columns.every((K) => K.checked);
    }), D = _(() => {
      const { defaultOptions: Y } = e;
      return ["html", "xml", "xlsx", "pdf"].indexOf(Y.type) > -1;
    }), S = _(() => {
      const { storeData: Y, defaultOptions: K } = e;
      return !K.original && K.mode === "current" && (Y.isPrint || ["html", "xlsx"].indexOf(K.type) > -1);
    }), x = _(() => {
      const { defaultOptions: Y } = e;
      return !Y.original && ["xlsx"].indexOf(Y.type) > -1;
    }), h = (Y) => {
      const { storeData: K } = e, L = r.findTree(K.columns, (ye) => ye === Y);
      if (L && L.parent) {
        const { parent: ye } = L;
        ye.children && ye.children.length && (ye.checked = ye.children.every((se) => se.checked), ye.halfChecked = !ye.checked && ye.children.some((se) => se.checked || se.halfChecked), h(ye));
      }
    }, O = () => {
      const { storeData: Y } = e, K = Y.columns;
      u.isAll = K.every((L) => L.disabled || L.checked), u.isIndeterminate = !u.isAll && K.some((L) => !L.disabled && (L.checked || L.halfChecked));
    }, g = (Y) => {
      const K = !Y.checked;
      r.eachTree([Y], (L) => {
        L.checked = K, L.halfChecked = !1;
      }), h(Y), O();
    }, b = () => {
      const { storeData: Y } = e, K = !u.isAll;
      r.eachTree(Y.columns, (L) => {
        L.disabled || (L.checked = K, L.halfChecked = !1);
      }), u.isAll = K, O();
    }, E = () => {
      me(() => {
        const Y = p.value, K = w.value, L = d.value, ye = Y || K || L;
        ye && ye.focus();
      }), O();
    }, C = () => {
      const { storeData: Y, defaultOptions: K } = e, { hasMerge: L, columns: ye } = Y, se = v.value, P = S.value, M = r.searchTree(ye, (I) => I.checked, { children: "children", mapChildren: "childNodes", original: !0 });
      return Object.assign({}, K, {
        columns: M,
        isMerge: L && P && se ? K.isMerge : !1
      });
    }, V = () => {
      const { storeData: Y } = e, K = m.value;
      Y.visible = !1, a.print(Object.assign({}, K, C()));
    }, Q = () => {
      const { storeData: Y } = e, K = c.value;
      u.loading = !0, a.exportData(Object.assign({}, K, C())).then(() => {
        u.loading = !1, Y.visible = !1;
      }).catch(() => {
        u.loading = !1;
      });
    }, Z = () => {
      const { storeData: Y } = e;
      Y.visible = !1;
    }, G = () => {
      const { storeData: Y } = e;
      Y.isPrint ? V() : Q();
    }, ue = () => {
      const { defaultOptions: Y, storeData: K } = e, { isAll: L, isIndeterminate: ye } = u, { hasTree: se, hasMerge: P, isPrint: M, hasColgroup: I, columns: B } = K, { isHeader: H } = Y, ce = [], A = v.value, j = D.value, fe = S.value, pe = x.value, ne = Y.slots || {}, $ = ne.top, J = ne.bottom, ge = ne.default, Oe = ne.footer, Se = ne.parameter;
      return r.eachTree(B, (de) => {
        const Ie = po(de.getTitle(), 1), je = de.children && de.children.length, Ue = de.checked, Ae = de.halfChecked, _e = de.type === "html";
        ce.push(o("li", {
          key: de.id,
          class: ["vxe-table-export--panel-column-option", `level--${de.level}`, {
            "is--group": je,
            "is--checked": Ue,
            "is--indeterminate": Ae,
            "is--disabled": de.disabled
          }],
          title: _e ? "" : Ie,
          onClick: () => {
            de.disabled || g(de);
          }
        }, [
          o("span", {
            class: ["vxe-checkbox--icon", Ae ? vl().TABLE_CHECKBOX_INDETERMINATE : Ue ? vl().TABLE_CHECKBOX_CHECKED : vl().TABLE_CHECKBOX_UNCHECKED]
          }),
          _e ? o("span", {
            key: "1",
            class: "vxe-checkbox--label",
            innerHTML: Ie
          }) : o("span", {
            key: "0",
            class: "vxe-checkbox--label"
          }, Ie)
        ]));
      }), t ? o(t, {
        id: "VXE_EXPORT_MODAL",
        modelValue: K.visible,
        title: Un(M ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 660,
        minWidth: 500,
        minHeight: 400,
        mask: !0,
        lockView: !0,
        showFooter: !0,
        escClosable: !0,
        maskClosable: !0,
        showMaximize: !0,
        resize: !0,
        loading: u.loading,
        "onUpdate:modelValue"(de) {
          K.visible = de;
        },
        onShow: E
      }, {
        default: () => {
          const de = {
            $table: a,
            $grid: a.xegrid,
            options: Y,
            columns: B,
            params: Y.params
          };
          return o("div", {
            class: "vxe-table-export--panel"
          }, [
            $ ? o("div", {
              class: "vxe-table-export--panel-top"
            }, a.callSlot($, de)) : Ve(),
            o("div", {
              class: "vxe-table-export--panel-body"
            }, ge ? a.callSlot(ge, de) : [
              o("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                o("tbody", [
                  [
                    M ? Ve() : o("tr", [
                      o("td", Un("vxe.export.expName")),
                      o("td", [
                        i ? o(i, {
                          ref: p,
                          modelValue: Y.filename,
                          type: "text",
                          clearable: !0,
                          placeholder: Un("vxe.export.expNamePlaceholder"),
                          "onUpdate:modelValue"(Ie) {
                            Y.filename = Ie;
                          }
                        }) : Ve()
                      ])
                    ]),
                    M ? Ve() : o("tr", [
                      o("td", Un("vxe.export.expType")),
                      o("td", [
                        s ? o(s, {
                          modelValue: Y.type,
                          options: K.typeList,
                          "onUpdate:modelValue"(Ie) {
                            Y.type = Ie;
                          }
                        }) : Ve()
                      ])
                    ]),
                    M || j ? o("tr", [
                      o("td", Un("vxe.export.expSheetName")),
                      o("td", [
                        i ? o(i, {
                          ref: w,
                          modelValue: Y.sheetName,
                          type: "text",
                          clearable: !0,
                          placeholder: Un("vxe.export.expSheetNamePlaceholder"),
                          "onUpdate:modelValue"(Ie) {
                            Y.sheetName = Ie;
                          }
                        }) : Ve()
                      ])
                    ]) : Ve(),
                    o("tr", [
                      o("td", Un("vxe.export.expMode")),
                      o("td", [
                        s ? o(s, {
                          modelValue: Y.mode,
                          options: K.modeList.map((Ie) => ({
                            value: Ie.value,
                            label: Un(Ie.label)
                          })),
                          "onUpdate:modelValue"(Ie) {
                            Y.mode = Ie;
                          }
                        }) : Ve()
                      ])
                    ]),
                    o("tr", [
                      o("td", [Un("vxe.export.expColumn")]),
                      o("td", [
                        o("div", {
                          class: "vxe-table-export--panel-column"
                        }, [
                          o("ul", {
                            class: "vxe-table-export--panel-column-header"
                          }, [
                            o("li", {
                              class: ["vxe-table-export--panel-column-option", {
                                "is--checked": L,
                                "is--indeterminate": ye
                              }],
                              title: Un("vxe.table.allTitle"),
                              onClick: b
                            }, [
                              o("span", {
                                class: ["vxe-checkbox--icon", ye ? vl().TABLE_CHECKBOX_INDETERMINATE : L ? vl().TABLE_CHECKBOX_CHECKED : vl().TABLE_CHECKBOX_UNCHECKED]
                              }),
                              o("span", {
                                class: "vxe-checkbox--label"
                              }, Un("vxe.export.expCurrentColumn"))
                            ])
                          ]),
                          o("ul", {
                            class: "vxe-table-export--panel-column-body"
                          }, ce)
                        ])
                      ])
                    ]),
                    o("tr", [
                      o("td", Un("vxe.export.expOpts")),
                      Se ? o("td", [
                        o("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, a.callSlot(Se, de))
                      ]) : o("td", [
                        o("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          l ? o(l, {
                            modelValue: Y.isHeader,
                            title: Un("vxe.export.expHeaderTitle"),
                            content: Un("vxe.export.expOptHeader"),
                            "onUpdate:modelValue"(Ie) {
                              Y.isHeader = Ie;
                            }
                          }) : Ve(),
                          l ? o(l, {
                            modelValue: Y.isFooter,
                            disabled: !K.hasFooter,
                            title: Un("vxe.export.expFooterTitle"),
                            content: Un("vxe.export.expOptFooter"),
                            "onUpdate:modelValue"(Ie) {
                              Y.isFooter = Ie;
                            }
                          }) : Ve(),
                          l ? o(l, {
                            modelValue: Y.original,
                            title: Un("vxe.export.expOriginalTitle"),
                            content: Un("vxe.export.expOptOriginal"),
                            "onUpdate:modelValue"(Ie) {
                              Y.original = Ie;
                            }
                          }) : Ve()
                        ]),
                        o("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          l ? o(l, {
                            modelValue: H && I && fe ? Y.isColgroup : !1,
                            title: Un("vxe.export.expColgroupTitle"),
                            disabled: !H || !I || !fe,
                            content: Un("vxe.export.expOptColgroup"),
                            "onUpdate:modelValue"(Ie) {
                              Y.isColgroup = Ie;
                            }
                          }) : Ve(),
                          l ? o(l, {
                            modelValue: P && fe && A ? Y.isMerge : !1,
                            title: Un("vxe.export.expMergeTitle"),
                            disabled: !P || !fe || !A,
                            content: Un("vxe.export.expOptMerge"),
                            "onUpdate:modelValue"(Ie) {
                              Y.isMerge = Ie;
                            }
                          }) : Ve(),
                          M || !l ? Ve() : o(l, {
                            modelValue: pe ? Y.useStyle : !1,
                            disabled: !pe,
                            title: Un("vxe.export.expUseStyleTitle"),
                            content: Un("vxe.export.expOptUseStyle"),
                            "onUpdate:modelValue"(Ie) {
                              Y.useStyle = Ie;
                            }
                          }),
                          l ? o(l, {
                            modelValue: se ? Y.isAllExpand : !1,
                            disabled: !se,
                            title: Un("vxe.export.expAllExpandTitle"),
                            content: Un("vxe.export.expOptAllExpand"),
                            "onUpdate:modelValue"(Ie) {
                              Y.isAllExpand = Ie;
                            }
                          }) : Ve()
                        ])
                      ])
                    ])
                  ]
                ])
              ])
            ]),
            J ? o("div", {
              class: "vxe-table-export--panel-bottom"
            }, a.callSlot(J, de)) : Ve()
          ]);
        },
        footer() {
          const de = {
            $table: a,
            $grid: a.xegrid,
            options: Y,
            columns: B,
            params: Y.params
          };
          return o("div", {
            class: "vxe-table-export--panel-footer"
          }, Oe ? a.callSlot(Oe, de) : [
            o("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              n ? o(n, {
                content: Un("vxe.export.expCancel"),
                onClick: Z
              }) : Ve(),
              n ? o(n, {
                ref: d,
                status: "primary",
                content: Un(M ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
                onClick: G
              }) : Ve()
            ])
          ]);
        }
      }) : Ve();
    };
    return process.env.NODE_ENV === "development" && me(() => {
      t || Ut("vxe.error.reqComp", ["vxe-modal"]), n || Ut("vxe.error.reqComp", ["vxe-button"]), s || Ut("vxe.error.reqComp", ["vxe-select"]), i || Ut("vxe.error.reqComp", ["vxe-input"]), l || Ut("vxe.error.reqComp", ["vxe-checkbox"]);
    }), ue;
  }
}), { getIcon: qN } = Ce, UN = pt({
  name: "VxeTableMenuPanel",
  setup(e, t) {
    const n = r.uniqueId(), s = mt("$xeTable", {}), { reactData: i } = s, l = ke(), a = {
      refElem: l
    }, c = {
      xID: n,
      props: e,
      context: t,
      getRefMaps: () => a
    }, m = () => {
      const { ctxMenuStore: u } = i, { computeMenuOpts: d } = s.getComputeMaps(), p = d.value;
      return o(ks, {
        to: "body",
        disabled: !1
      }, [
        o("div", {
          ref: l,
          class: ["vxe-table--context-menu-wrapper", p.className, {
            "is--visible": u.visible
          }],
          style: u.style
        }, u.list.map((w, v) => w.every((D) => D.visible === !1) ? Ve() : o("ul", {
          class: "vxe-context-menu--option-wrapper",
          key: v
        }, w.map((D, S) => {
          const x = D.children && D.children.some((g) => g.visible !== !1), h = Object.assign({}, D.prefixConfig), O = Object.assign({}, D.suffixConfig);
          return D.visible === !1 ? null : o("li", {
            class: [D.className, {
              "link--disabled": D.disabled,
              "link--active": D === u.selected
            }],
            key: `${v}_${S}`
          }, [
            o("a", {
              class: "vxe-context-menu--link",
              onClick(g) {
                s.ctxMenuLinkEvent(g, D);
              },
              onMouseover(g) {
                s.ctxMenuMouseoverEvent(g, D);
              },
              onMouseout(g) {
                s.ctxMenuMouseoutEvent(g, D);
              }
            }, [
              o("div", {
                class: ["vxe-context-menu--link-prefix", h.className || ""]
              }, [
                o("i", {
                  class: h.icon || D.prefixIcon
                }),
                h.content ? o("span", {}, `${h.content}`) : Ve()
              ]),
              o("div", {
                class: "vxe-context-menu--link-content"
              }, fr(D.name)),
              o("div", {
                class: ["vxe-context-menu--link-suffix", O.className || ""]
              }, [
                o("i", {
                  class: O.icon || D.suffixIcon || (x ? qN().TABLE_MENU_OPTIONS : "")
                }),
                O.content ? o("span", `${O.content}`) : Ve()
              ])
            ]),
            x ? o("ul", {
              class: ["vxe-table--context-menu-clild-wrapper", {
                "is--show": D === u.selected && u.showChild
              }]
            }, D.children.map((g, b) => {
              const E = Object.assign({}, g.prefixConfig), C = Object.assign({}, g.suffixConfig);
              return g.visible === !1 ? null : o("li", {
                class: [g.className, {
                  "link--disabled": g.disabled,
                  "link--active": g === u.selectChild
                }],
                key: `${v}_${S}_${b}`
              }, [
                o("a", {
                  class: "vxe-context-menu--link",
                  onClick(V) {
                    s.ctxMenuLinkEvent(V, g);
                  },
                  onMouseover(V) {
                    s.ctxMenuMouseoverEvent(V, D, g);
                  },
                  onMouseout(V) {
                    s.ctxMenuMouseoutEvent(V, D);
                  }
                }, [
                  o("div", {
                    class: ["vxe-context-menu--link-prefix", E.className || ""]
                  }, [
                    o("i", {
                      class: E.icon || g.prefixIcon
                    }),
                    E.content ? o("span", `${E.content}`) : Ve()
                  ]),
                  o("div", {
                    class: "vxe-context-menu--link-content"
                  }, fr(g.name)),
                  o("div", {
                    class: ["vxe-context-menu--link-suffix", C.className || ""]
                  }, [
                    o("i", {
                      class: C.icon
                    }),
                    C.content ? o("span", `${C.content}`) : Ve()
                  ])
                ])
              ]);
            })) : null
          ]);
        }))))
      ]);
    };
    return c.renderVN = m, c;
  },
  render() {
    return this.renderVN();
  }
}), { getConfig: Mn, getIcon: Pu, getI18n: bl, renderer: Np, formats: Fp, createEvent: GN, globalResize: KN, interceptor: Lp, hooks: YN, globalEvents: An, GLOBAL_EVENT_KEYS: ls, useFns: XN, renderEmptyElement: Vo } = Ce, Ap = "VXE_CUSTOM_STORE", Rl = pt({
  name: "VxeTable",
  props: Sd,
  emits: Dd,
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = Ce.getComponent("VxeLoading"), a = Ce.getComponent("VxeTooltip"), c = mt("$xeTabs", null), { computeSize: m } = XN.useSize(e), u = Rt({
      isCalcColumn: !1,
      // 低性能的静态列
      staticColumns: [],
      // 渲染的列分组
      tableGroupColumn: [],
      // 可视区渲染的列
      tableColumn: [],
      // 渲染中的数据
      tableData: [],
      // 是否启用了横向 X 可视渲染方式加载
      scrollXLoad: !1,
      // 是否启用了纵向 Y 可视渲染方式加载
      scrollYLoad: !1,
      // 是否存在纵向滚动条
      overflowY: !0,
      // 是否存在横向滚动条
      overflowX: !1,
      // 纵向滚动条的宽度
      scrollbarWidth: 0,
      // 横向滚动条的高度
      scrollbarHeight: 0,
      // 最后滚动时间戳
      lastScrollTime: 0,
      // 行高
      rowHeight: 0,
      // 表格父容器的高度
      parentHeight: 0,
      // 是否使用分组表头
      isGroup: !1,
      isAllOverflow: !1,
      // 复选框属性，是否全选
      isAllSelected: !1,
      // 复选框属性，有选中且非全选状态
      isIndeterminate: !1,
      // 复选框属性，已选中的行集合
      selectCheckboxMaps: {},
      // 当前行
      currentRow: null,
      // 单选框属性，选中列
      currentColumn: null,
      // 单选框属性，选中行
      selectRadioRow: null,
      // 表尾合计数据
      footerTableData: [],
      // 展开列信息
      expandColumn: null,
      // 树节点列信息
      treeNodeColumn: null,
      hasFixedColumn: !1,
      // 已展开的行集合
      rowExpandedMaps: {},
      // 懒加载中的展开行的集合
      rowExpandLazyLoadedMaps: {},
      // 已展开树节点集合
      treeExpandedMaps: {},
      // 懒加载中的树节点的集合
      treeExpandLazyLoadedMaps: {},
      // 树节点不确定状态的集合
      treeIndeterminateMaps: {},
      // 合并单元格的对象集
      mergeList: [],
      // 合并表尾数据的对象集
      mergeFooterList: [],
      // 刷新列标识，当列筛选被改变时，触发表格刷新数据
      upDataFlag: 0,
      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列
      reColumnFlag: 0,
      // 已标记的对象集
      pendingRowMaps: {},
      // 已标记的行
      pendingRowList: [],
      // 初始化标识
      initStore: {
        filter: !1,
        import: !1,
        export: !1,
        custom: !1
      },
      // 自定义列相关的信息
      customStore: {
        btnEl: null,
        isAll: !1,
        isIndeterminate: !1,
        activeBtn: !1,
        activeWrapper: !1,
        visible: !1,
        maxHeight: 0,
        oldSortMaps: {},
        oldFixedMaps: {},
        oldVisibleMaps: {}
      },
      customColumnList: [],
      // 当前选中的筛选列
      filterStore: {
        isAllSelected: !1,
        isIndeterminate: !1,
        style: null,
        options: [],
        column: null,
        multiple: !1,
        visible: !1,
        maxHeight: null
      },
      // 存放列相关的信息
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        autoMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: [],
        remainList: []
      },
      // 存放快捷菜单的信息
      ctxMenuStore: {
        selected: null,
        visible: !1,
        showChild: !1,
        selectChild: null,
        list: [],
        style: null
      },
      // 存放可编辑相关信息
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 选中源
        selected: {
          row: null,
          column: null
        },
        // 已复制源
        copyed: {
          cut: !1,
          rows: [],
          columns: []
        },
        // 激活
        actived: {
          row: null,
          column: null
        },
        // 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
        focused: {
          row: null,
          column: null
        },
        insertMaps: {},
        removeMaps: {}
      },
      // 存放 tooltip 相关信息
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: !1,
        currOpts: {}
      },
      // 存放数据校验相关信息
      validStore: {
        visible: !1
      },
      validErrorMaps: {},
      // 导入相关信息
      importStore: {
        inited: !1,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: !1
      },
      importParams: {
        mode: "",
        types: null,
        message: !0
      },
      // 导出相关信息
      exportStore: {
        inited: !1,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: !1,
        hasFooter: !1,
        hasMerge: !1,
        hasTree: !1,
        hasColgroup: !1,
        visible: !1
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: !1,
        isMerge: !1,
        isAllExpand: !1,
        useStyle: !1,
        original: !1,
        message: !0,
        isHeader: !1,
        isFooter: !1
      },
      scrollVMLoading: !1,
      isCustomStatus: !1,
      isDragRowMove: !1,
      dragRow: null,
      isDragColMove: !1,
      dragCol: null,
      dragTipText: "",
      _isResize: !1,
      _isLoading: !1
    }), d = {
      tZindex: 0,
      elemStore: {},
      // 存放横向 X 虚拟滚动相关的信息
      scrollXStore: {
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 存放纵向 Y 虚拟滚动相关信息
      scrollYStore: {
        rowHeight: 0,
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 表格宽度
      tableWidth: 0,
      // 表格高度
      tableHeight: 0,
      // 表头高度
      headerHeight: 0,
      // 表尾高度
      footerHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      // 当前 hover 行
      hoverRow: null,
      // 最后滚动位置
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 单选框属性，已选中保留的行
      radioReserveRow: null,
      // 复选框属性，已选中保留的行集合
      checkboxReserveRowMap: {},
      // 行数据，已展开保留的行集合
      rowExpandedReserveRowMap: {},
      // 树结构数据，已展开保留的行集合
      treeExpandedReserveRowMap: {},
      // 树结构数据，不确定状态的集合
      treeIndeterminateRowMaps: {},
      // 列表完整数据、条件处理后
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      // 列表条件处理后数据集合
      afterFullRowMaps: {},
      // 树结构完整数据、条件处理后
      tableFullTreeData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 收集的列配置（带分组）
      collectColumn: [],
      // 完整所有列（不带分组）
      tableFullColumn: [],
      // 渲染所有列
      visibleColumn: [],
      // 总的缓存数据集
      fullAllDataRowIdData: {},
      // 渲染中缓存数据
      sourceDataRowIdData: {},
      fullDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      // 列选取状态
      columnStatusMaps: {},
      // 行选取状态
      rowStatusMaps: {},
      // prevDragRow: null,
      inited: !1,
      tooltipTimeout: null,
      initStatus: !1,
      isActivated: !1
    };
    let p = {}, w = {};
    const v = ke(), D = ke(), S = ke(), x = ke(), h = ke(), O = ke(), g = ke(), b = ke(), E = ke(), C = ke(), V = ke(), Q = ke(), Z = ke(), G = ke(), ue = ke(), Y = ke(), K = ke(), L = ke(), ye = ke(), se = ke(), P = ke(), M = ke(), I = ke(), B = ke(), H = ke(), ce = ke(), A = ke(), j = ke(), fe = ke(), pe = ke(), ne = mt("$xeGrid", null);
    let $;
    const J = _(() => {
      const { id: f } = e;
      return f ? r.isFunction(f) ? `${f({ $table: U, $grid: ne }) || ""}` : `${f}` : "";
    }), ge = _(() => Object.assign({}, Mn().table.validConfig, e.validConfig)), Oe = _(() => Object.assign({}, Mn().table.scrollX, e.scrollX)), Se = _(() => {
      const f = Oe.value, { threshold: y } = f;
      return y ? r.toNumber(y) : 0;
    }), de = _(() => Object.assign({}, Mn().table.scrollY, e.scrollY)), Ie = _(() => {
      const f = de.value, { threshold: y } = f;
      return y ? r.toNumber(y) : 0;
    }), je = _(() => ({
      default: 48,
      medium: 44,
      small: 40,
      mini: 36
    })), Ue = _(() => Object.assign({}, Mn().table.columnConfig, e.columnConfig)), Ae = _(() => Object.assign({}, Mn().table.cellConfig, e.cellConfig)), _e = _(() => Object.assign({}, Mn().table.rowConfig, e.rowConfig)), it = _(() => Object.assign({}, Mn().table.rowDragConfig, e.rowDragConfig)), vt = _(() => Object.assign({}, Mn().table.columnDragConfig, e.columnDragConfig)), dt = _(() => Object.assign({}, Mn().table.resizeConfig, e.resizeConfig)), at = _(() => Object.assign({}, Mn().table.resizableConfig, e.resizableConfig)), Et = _(() => Object.assign({ startIndex: 0 }, Mn().table.seqConfig, e.seqConfig)), Qe = _(() => Object.assign({}, Mn().table.radioConfig, e.radioConfig)), De = _(() => Object.assign({}, Mn().table.checkboxConfig, e.checkboxConfig));
    let Re = ke();
    Re = _(() => Object.assign({}, Mn().tooltip, Mn().table.tooltipConfig, e.tooltipConfig));
    const Be = _(() => {
      const f = Re.value;
      return Object.assign({}, f);
    }), ve = _(() => {
      const f = Re.value;
      return Object.assign({ isArrow: !1 }, f);
    }), Ne = _(() => Object.assign({}, Mn().table.editConfig, e.editConfig)), q = _(() => Object.assign({ orders: ["asc", "desc", null] }, Mn().table.sortConfig, e.sortConfig)), z = _(() => Object.assign({}, Mn().table.filterConfig, e.filterConfig)), R = _(() => Object.assign({}, Mn().table.mouseConfig, e.mouseConfig)), le = _(() => Object.assign({}, Mn().table.areaConfig, e.areaConfig)), F = _(() => Object.assign({}, Mn().table.keyboardConfig, e.keyboardConfig)), re = _(() => Object.assign({}, Mn().table.clipConfig, e.clipConfig)), N = _(() => Object.assign({}, Mn().table.fnrConfig, e.fnrConfig)), ee = _(() => Object.assign({}, Mn().table.menuConfig, e.menuConfig)), be = _(() => {
      const y = ee.value.header;
      return y && y.options ? y.options : [];
    }), we = _(() => {
      const y = ee.value.body;
      return y && y.options ? y.options : [];
    }), Te = _(() => {
      const y = ee.value.footer;
      return y && y.options ? y.options : [];
    }), ze = _(() => {
      const f = ee.value, y = be.value, T = we.value, k = Te.value;
      return !!(e.menuConfig && fn(f) && (y.length || T.length || k.length));
    }), st = _(() => {
      const { ctxMenuStore: f } = u, y = [];
      return f.list.forEach((T) => {
        T.forEach((k) => {
          y.push(k);
        });
      }), y;
    }), ct = _(() => Object.assign({}, Mn().table.exportConfig, e.exportConfig)), Ke = _(() => Object.assign({}, Mn().table.importConfig, e.importConfig)), wt = _(() => Object.assign({}, Mn().table.printConfig, e.printConfig)), St = _(() => Object.assign({}, Mn().table.expandConfig, e.expandConfig)), Dt = _(() => Object.assign({}, Mn().table.treeConfig, e.treeConfig)), Wt = _(() => Object.assign({}, Mn().table.emptyRender, e.emptyRender)), nn = _(() => Object.assign({}, Mn().table.loadingConfig, e.loadingConfig)), zt = _(() => e.border ? Math.max(2, Math.ceil(u.scrollbarWidth / u.tableColumn.length)) : 1), At = _(() => Object.assign({}, Mn().table.customConfig, e.customConfig)), Ee = _(() => {
      const { visibleColumn: f } = d, { tableColumn: y } = u;
      return y.length || f.length ? f.filter((T) => T.width === "auto" || T.minWidth === "auto") : [];
    }), Ye = _(() => {
      const { collectColumn: f } = d;
      let y = 0;
      return f.forEach((T) => {
        T.renderFixed && y++;
      }), y;
    }), rt = _(() => {
      const f = Ye.value, y = Ue.value, { maxFixedSize: T } = y;
      return T ? f >= T : !1;
    }), Ot = _(() => {
      const { border: f } = e;
      return f === !0 ? "full" : f || "default";
    }), Jt = _(() => {
      const { tableData: f } = u, { tableFullData: y } = d, T = De.value, { strict: k, checkMethod: W } = T;
      return k ? f.length || y.length ? W ? y.every((ie) => !W({ row: ie })) : !1 : !0 : !1;
    }), Bt = _(() => {
      const { overflowX: f, scrollXLoad: y, overflowY: T, scrollYLoad: k } = u;
      return {
        x: f && y,
        y: T && k
      };
    }), Gt = {
      refElem: v,
      refTooltip: D,
      refValidTooltip: x,
      refTableFilter: O,
      refTableCustom: g,
      refTableMenu: h,
      refTableHeader: b,
      refTableBody: E,
      refTableFooter: C,
      refTableLeftHeader: V,
      refTableLeftBody: Q,
      refTableLeftFooter: Z,
      refTableRightHeader: G,
      refTableRightBody: ue,
      refTableRightFooter: Y,
      refLeftContainer: K,
      refRightContainer: L,
      refCellResizeBar: ye,
      refCellResizeTip: se,
      refScrollXVirtualElem: H,
      refScrollYVirtualElem: ce,
      refScrollXHandleElem: A,
      refScrollYHandleElem: j,
      refScrollXSpaceElem: fe,
      refScrollYSpaceElem: pe
    }, Qt = {
      computeSize: m,
      computeTableId: J,
      computeValidOpts: ge,
      computeSXOpts: Oe,
      computeSYOpts: de,
      computeColumnOpts: Ue,
      computeCellOpts: Ae,
      computeRowOpts: _e,
      computeRowDragOpts: it,
      computeColumnDragOpts: vt,
      computeResizeOpts: dt,
      computeResizableOpts: at,
      computeSeqOpts: Et,
      computeRadioOpts: Qe,
      computeCheckboxOpts: De,
      computeTooltipOpts: Re,
      computeEditOpts: Ne,
      computeSortOpts: q,
      computeFilterOpts: z,
      computeMouseOpts: R,
      computeAreaOpts: le,
      computeKeyboardOpts: F,
      computeClipOpts: re,
      computeFNROpts: N,
      computeHeaderMenu: be,
      computeBodyMenu: we,
      computeFooterMenu: Te,
      computeIsMenu: ze,
      computeMenuOpts: ee,
      computeExportOpts: ct,
      computeImportOpts: Ke,
      computePrintOpts: wt,
      computeExpandOpts: St,
      computeTreeOpts: Dt,
      computeEmptyOpts: Wt,
      computeLoadingOpts: nn,
      computeCustomOpts: At,
      computeFixedColumnSize: Ye,
      computeIsMaxFixedColumn: rt,
      computeIsAllCheckboxDisabled: Jt,
      computeVirtualScrollBars: Bt
    }, U = {
      xID: i,
      props: e,
      context: t,
      reactData: u,
      internalData: d,
      getRefMaps: () => Gt,
      getComputeMaps: () => Qt,
      xegrid: ne
    }, Lt = (f, y, T) => {
      const k = r.get(f, T), W = r.get(y, T);
      return cr(k) && cr(W) ? !0 : r.isString(k) || r.isNumber(k) ? "" + k == "" + W : r.isEqual(k, W);
    }, on = (f) => {
      const y = q.value, { orders: T } = y, k = f.order || null, W = T.indexOf(k) + 1;
      return T[W < T.length ? W : 0];
    }, en = (f) => {
      const y = Mn().version, T = r.toStringJSON(localStorage.getItem(Ap) || ""), k = T && T._v === y ? T : { _v: y };
      return (f ? k[f] : k) || {};
    }, hn = (f, y) => {
      const T = Mn().version, k = en();
      k[f] = y || void 0, k._v = T, localStorage.setItem(Ap, r.toJSONString(k));
    }, En = (f) => {
      const { fullAllDataRowIdData: y } = d, T = {};
      return r.each(f, (k, W) => {
        y[W] && (T[W] = k);
      }), T;
    }, mn = (f) => {
      const { fullDataRowIdData: y } = d, T = [];
      return r.each(f, (k, W) => {
        y[W] && U.findRowIndexOf(T, y[W].row) === -1 && T.push(y[W].row);
      }), T;
    }, gn = () => {
      const { visibleColumn: f } = d, y = E.value, T = y ? y.$el : null;
      if (T) {
        const { scrollLeft: k, clientWidth: W } = T, ie = k + W;
        let te = -1, he = 0, xe = 0;
        for (let Me = 0, $e = f.length; Me < $e && (he += f[Me].renderWidth, te === -1 && k < he && (te = Me), !(te >= 0 && (xe++, he > ie))); Me++)
          ;
        return { toVisibleIndex: Math.max(0, te), visibleSize: Math.max(6, xe) };
      }
      return { toVisibleIndex: 0, visibleSize: 6 };
    }, Sn = () => {
      const { showOverflow: f } = e, y = b.value, T = E.value, k = T ? T.$el : null, W = m.value, ie = je.value;
      let te = 24;
      if (f && k) {
        const he = y ? y.$el : null;
        let xe;
        xe = k.querySelector("tr"), !xe && he && (xe = he.querySelector("tr")), xe && (te = xe.clientHeight), te || (te = ie[W || "default"]);
      }
      return te;
    }, Fn = () => {
      const { scrollYStore: f, afterFullData: y, fullAllDataRowIdData: T } = d, k = E.value, W = k ? k.$el : null, { rowHeight: ie } = f;
      if (W) {
        const { scrollTop: te, clientHeight: he } = W, xe = te + he;
        let Me = -1, $e = 0, Ge = 0;
        for (let Fe = 0, He = y.length; Fe < He; Fe++) {
          const et = y[Fe], Xe = yt(U, et), nt = T[Xe];
          if (!nt || ($e += nt.height || ie, Me === -1 && te < $e && (Me = Fe), Me >= 0 && (Ge++, $e > xe)))
            break;
        }
        return { toVisibleIndex: Math.max(0, Me), visibleSize: Math.max(8, Ge) };
      }
      return { toVisibleIndex: 0, visibleSize: 8 };
    }, co = (f, y, T) => {
      for (let k = 0, W = f.length; k < W; k++) {
        const ie = f[k], { startIndex: te, endIndex: he } = y, xe = ie[T], Me = ie[T + "span"], $e = xe + Me;
        xe < te && te < $e && (y.startIndex = xe), xe < he && he < $e && (y.endIndex = $e), (y.startIndex !== te || y.endIndex !== he) && (k = -1);
      }
    }, Uo = (f, y, T) => {
      if (f) {
        const { treeConfig: k } = e, { visibleColumn: W } = d;
        r.isArray(f) || (f = [f]), k && f.length && Ut("vxe.error.noTree", ["merge-cells | merge-footer-items"]), f.forEach((ie) => {
          let { row: te, col: he, rowspan: xe, colspan: Me } = ie;
          if (T && r.isNumber(te) && (te = T[te]), r.isNumber(he) && (he = W[he]), (T ? te : r.isNumber(te)) && he && (xe || Me) && (xe = r.toNumber(xe) || 1, Me = r.toNumber(Me) || 1, xe > 1 || Me > 1)) {
            const $e = r.findIndexOf(y, (Fe) => (Fe._row === te || yt(U, Fe._row) === yt(U, te)) && (Fe._col.id === he || Fe._col.id === he.id)), Ge = y[$e];
            if (Ge)
              Ge.rowspan = xe, Ge.colspan = Me, Ge._rowspan = xe, Ge._colspan = Me;
            else {
              const Fe = T ? U.findRowIndexOf(T, te) : te, He = p.getVTColumnIndex(he);
              y.push({
                row: Fe,
                col: He,
                rowspan: xe,
                colspan: Me,
                _row: te,
                _col: he,
                _rowspan: xe,
                _colspan: Me
              });
            }
          }
        });
      }
    }, Qn = (f, y, T) => {
      const k = [];
      if (f) {
        const { treeConfig: W } = e, { visibleColumn: ie } = d;
        r.isArray(f) || (f = [f]), W && f.length && Ut("vxe.error.noTree", ["merge-cells | merge-footer-items"]), f.forEach((te) => {
          let { row: he, col: xe } = te;
          T && r.isNumber(he) && (he = T[he]), r.isNumber(xe) && (xe = ie[xe]);
          const Me = r.findIndexOf(y, ($e) => ($e._row === he || yt(U, $e._row) === yt(U, he)) && ($e._col.id === xe || $e._col.id === xe.id));
          if (Me > -1) {
            const $e = y.splice(Me, 1);
            k.push($e[0]);
          }
        });
      }
      return k;
    }, ho = () => {
      const { tableFullColumn: f } = d;
      f.forEach((y) => {
        y.order = null;
      });
    }, Co = (f) => {
      const { parentHeight: y } = u, T = e[f];
      let k = 0;
      if (T)
        if (T === "100%" || T === "auto")
          k = y;
        else {
          const W = U.getExcludeHeight();
          Ci(T) ? k = Math.floor((r.toInteger(T) || 1) / 100 * y) : k = r.toNumber(T), k = Math.max(40, k - W);
        }
      return k;
    }, Oo = (f) => {
      let { collectColumn: y } = d;
      const { resizableData: T, sortData: k, visibleData: W, fixedData: ie } = f;
      let te = !1;
      T || k || W || ie ? (r.eachTree(y, (he, xe, Me, $e, Ge) => {
        const Fe = he.getKey();
        Ge || (ie && ie[Fe] && (he.fixed = ie[Fe]), k && r.isNumber(k[Fe]) && (te = !0, he.renderSortNumber = k[Fe])), T && r.isNumber(T[Fe]) && (he.resizeWidth = T[Fe]), W && r.isBoolean(W[Fe]) && (he.visible = W[Fe]);
      }), te && (y = r.orderBy(y, "renderSortNumber"), d.collectColumn = y, d.tableFullColumn = Zs(y)), u.isCustomStatus = !0) : u.isCustomStatus = !1;
    }, Po = () => {
      const { customConfig: f } = e, y = J.value, T = At.value, { storage: k, restoreStore: W } = T, ie = k === !0, te = ie ? {} : Object.assign({}, k || {}), he = ie || te.resizable, xe = ie || te.visible, Me = ie || te.fixed, $e = ie || te.sort;
      if ((f ? fn(T) : T.enabled) && (he || xe || Me || $e)) {
        if (!y) {
          Ut("vxe.error.reqProp", ["id"]);
          return;
        }
        const Ge = en(y);
        return W ? Promise.resolve(W({ id: y, type: "restore", storeData: Ge })).then((Fe) => {
          if (Fe)
            return Oo(Fe);
        }).catch((Fe) => Fe) : Oo(Ge);
      }
    }, Ys = () => {
      const { tableFullColumn: f, collectColumn: y } = d, T = d.fullColumnIdData = {}, k = d.fullColumnFieldData = {}, W = R.value, ie = Ue.value, te = _e.value, he = y.some(Tl);
      let xe = !!e.showOverflow, Me, $e, Ge, Fe, He;
      const et = (Xe, nt, Ct, ot, Tt) => {
        const { id: Xt, field: Pt, fixed: tn, type: pn, treeNode: zn } = Xe, On = { $index: -1, _index: -1, column: Xe, colid: Xt, index: nt, items: Ct, parent: Tt || null, width: 0 };
        Pt && (process.env.NODE_ENV === "development" && k[Pt] && rn("vxe.error.colRepet", ["field", Pt]), k[Pt] = On), !He && pn === "html" && (He = Xe), zn ? (process.env.NODE_ENV === "development" && $e && rn("vxe.error.colRepet", ["tree-node", zn]), $e || ($e = Xe)) : pn === "expand" && (process.env.NODE_ENV === "development" && Me && rn("vxe.error.colRepet", ["type", pn]), Me || (Me = Xe)), process.env.NODE_ENV === "development" && (pn === "checkbox" ? (Ge && rn("vxe.error.colRepet", ["type", pn]), Ge || (Ge = Xe)) : pn === "radio" && (Fe && rn("vxe.error.colRepet", ["type", pn]), Fe || (Fe = Xe))), xe && Xe.showOverflow === !1 && (xe = !1), T[Xt] && Ut("vxe.error.colRepet", ["colId", Xt]), T[Xt] = On;
      };
      he ? r.eachTree(y, (Xe, nt, Ct, ot, Tt, Xt) => {
        Xe.level = Xt.length, et(Xe, nt, Ct, ot, Tt);
      }) : f.forEach(et), process.env.NODE_ENV === "development" && Me && W.area && Ut("vxe.error.errConflicts", ["mouse-config.area", "column.type=expand"]), process.env.NODE_ENV === "development" && He && (ie.useKey || Ut("vxe.error.reqProp", ["column-config.useKey", "column.type=html"]), te.useKey || Ut("vxe.error.reqProp", ["row-config.useKey", "column.type=html"])), u.isGroup = he, u.treeNodeColumn = $e, u.expandColumn = Me, u.isAllOverflow = xe;
    }, Fs = () => {
      d.customHeight = Co("height"), d.customMinHeight = Co("minHeight"), d.customMaxHeight = Co("maxHeight");
    }, ms = () => {
      const f = Ee.value;
      return u.isCalcColumn = !0, me().then(() => {
        const { fullColumnIdData: y } = d, T = v.value;
        T && (f.forEach((k) => {
          const W = k.id, ie = y[W], te = T.querySelectorAll(`.vxe-header--column.${k.id}>.vxe-cell,.vxe-body--column.${k.id}>.vxe-cell,.vxe-footer--column.${k.id}>.vxe-cell`), he = te[0];
          let xe = 0;
          if (he) {
            const $e = getComputedStyle(he);
            xe = Math.floor(r.toNumber($e.paddingLeft) + r.toNumber($e.paddingRight)) + 2;
          }
          let Me = k.renderAutoWidth - xe;
          r.arrayEach(te, ($e) => {
            const Ge = $e, Fe = Ge.parentElement;
            let He = 0;
            if (`${Fe.tagName}`.toLowerCase() === "th")
              r.arrayEach(Ge.children, (et) => {
                He += et.offsetWidth + 1;
              });
            else {
              const et = Ge.firstElementChild;
              et && (He = et.offsetWidth);
            }
            He && (Me = Math.max(Me, Math.ceil(He) + 4));
          }), ie && (ie.width = Math.max(Me, ie.width)), k.renderAutoWidth = Me + xe;
        }), w.analyColumnWidth()), u.isCalcColumn = !1;
      });
    }, xr = () => {
      const f = b.value, y = E.value, T = C.value, k = y ? y.$el : null, W = f ? f.$el : null, ie = T ? T.$el : null;
      if (!k)
        return;
      let te = 0;
      const he = 40, xe = k.clientWidth - 1;
      let Me = xe, $e = Me / 100;
      const { fit: Ge } = e, { columnStore: Fe } = u, { resizeList: He, pxMinList: et, autoMinList: Xe, pxList: nt, scaleList: Ct, scaleMinList: ot, autoList: Tt, remainList: Xt } = Fe;
      if (et.forEach((ln) => {
        const an = r.toInteger(ln.minWidth);
        te += an, ln.renderWidth = an;
      }), Xe.forEach((ln) => {
        const an = Math.max(60, r.toInteger(ln.renderAutoWidth));
        te += an, ln.renderWidth = an;
      }), ot.forEach((ln) => {
        const an = Math.floor(r.toInteger(ln.minWidth) * $e);
        te += an, ln.renderWidth = an;
      }), Ct.forEach((ln) => {
        const an = Math.floor(r.toInteger(ln.width) * $e);
        te += an, ln.renderWidth = an;
      }), nt.forEach((ln) => {
        const an = r.toInteger(ln.width);
        te += an, ln.renderWidth = an;
      }), Tt.forEach((ln) => {
        const an = Math.max(60, r.toInteger(ln.renderAutoWidth));
        te += an, ln.renderWidth = an;
      }), He.forEach((ln) => {
        const an = r.toInteger(ln.resizeWidth);
        te += an, ln.renderWidth = an;
      }), Me -= te, $e = Me > 0 ? Math.floor(Me / (ot.length + et.length + Xe.length + Xt.length)) : 0, Ge ? Me > 0 && ot.concat(et).concat(Xe).forEach((ln) => {
        te += $e, ln.renderWidth += $e;
      }) : $e = he, Xt.forEach((ln) => {
        const an = Math.max($e, he);
        ln.renderWidth = an, te += an;
      }), Ge) {
        const ln = Ct.concat(ot).concat(et).concat(Xe).concat(Xt);
        let an = ln.length - 1;
        if (an > 0) {
          let Hn = xe - te;
          if (Hn > 0) {
            for (; Hn > 0 && an >= 0; )
              Hn--, ln[an--].renderWidth++;
            te = xe;
          }
        }
      }
      const Pt = k.offsetHeight, tn = k.scrollHeight > k.clientHeight;
      let pn = 0;
      tn && (pn = Math.max(k.offsetWidth - k.clientWidth, 0)), u.scrollbarWidth = pn, u.overflowY = tn, d.tableWidth = te, d.tableHeight = Pt;
      let zn = 0;
      W && (zn = W.clientHeight, me(() => {
        W && k && W.scrollLeft !== k.scrollLeft && (W.scrollLeft = k.scrollLeft);
      })), d.headerHeight = zn;
      let On = !1, xn = 0, _n = 0;
      ie ? (xn = ie.offsetHeight, On = te > ie.clientWidth, _n = Math.max(xn - ie.clientHeight, 0)) : (On = te > xe, _n = Math.max(Pt - k.clientHeight, 0)), d.footerHeight = xn, u.overflowX = On, u.scrollbarHeight = _n, Fs(), u.parentHeight = Math.max(d.headerHeight + xn + 20, w.getParentHeight()), On && w.checkScrolling();
    }, Es = () => {
      const { showOverflow: f } = e, { tableData: y, scrollXLoad: T, scrollYLoad: k } = u, { fullAllDataRowIdData: W } = d, ie = v.value;
      if (!f && (T || k) && ie) {
        let te = 0, he = 0, xe = !1;
        y.forEach((Me) => {
          const $e = yt(U, Me), Ge = W[$e], Fe = ie.querySelectorAll(`.vxe-body--row[rowid="${$e}"]`);
          if (Ge && Fe.length) {
            let He = 0;
            for (let et = 0; et < Fe.length; et++) {
              const nt = Fe[et].children;
              for (let Ct = 0; Ct < nt.length; Ct++) {
                const ot = nt[Ct], Tt = ot.querySelector(".vxe-cell");
                xe || (te = r.toNumber(getComputedStyle(ot).paddingTop), he = r.toNumber(getComputedStyle(ot).paddingBottom), xe = !0);
                let Xt = te + he;
                Tt && (Xt += Tt.offsetHeight), He = Math.max(He, Xt);
              }
            }
            Ge.height = T ? Math.max(Ge.height, He) : He;
          }
        });
      }
    }, oo = (f) => {
      const { sortBy: y, sortType: T } = f;
      return (k) => {
        let W;
        return y ? W = r.isFunction(y) ? y({ row: k, column: f }) : r.get(k, y) : W = p.getCellLabel(k, f), !T || T === "auto" ? isNaN(W) ? W : r.toNumber(W) : T === "number" ? r.toNumber(W) : T === "string" ? r.toValueString(W) : W;
      };
    }, Bo = () => {
      const { treeConfig: f } = e, { afterFullData: y, fullDataRowIdData: T, fullAllDataRowIdData: k } = d, W = Dt.value;
      f && W.transform && y.forEach((ie, te) => {
        const he = yt(U, ie), xe = k[he];
        if (xe)
          xe._index = te;
        else {
          const Me = { row: ie, rowid: he, seq: "-1", index: -1, $index: -1, _index: te, items: [], parent: null, level: 0, height: 0 };
          k[he] = Me, T[he] = Me;
        }
      });
    }, ko = () => {
      const { treeConfig: f } = e, { afterFullData: y, fullDataRowIdData: T, fullAllDataRowIdData: k, afterTreeFullData: W } = d, ie = Dt.value, te = ie.children || ie.childrenField, he = {};
      f ? (r.eachTree(W, (xe, Me, $e, Ge) => {
        const Fe = yt(U, xe), He = k[Fe], et = Ge.map((Xe, nt) => nt % 2 === 0 ? Number(Xe) + 1 : ".").join("");
        if (He)
          He.seq = et;
        else {
          const Xe = { row: xe, rowid: Fe, seq: et, index: -1, $index: -1, _index: -1, items: [], parent: null, level: 0, height: 0 };
          k[Fe] = Xe, T[Fe] = Xe;
        }
        he[Fe] = xe;
      }, { children: ie.transform ? ie.mapChildrenField : te }), Bo()) : y.forEach((xe, Me) => {
        const $e = yt(U, xe), Ge = k[$e], Fe = Me + 1;
        if (Ge)
          Ge.seq = Fe, Ge._index = Me;
        else {
          const He = { row: xe, rowid: $e, seq: Fe, index: -1, $index: -1, _index: Me, items: [], parent: null, level: 0, height: 0 };
          k[$e] = He, T[$e] = He;
        }
        he[$e] = xe;
      }), d.afterFullRowMaps = he;
    }, _o = () => {
      const { treeConfig: f } = e, { treeExpandedMaps: y } = u, { fullAllDataRowIdData: T } = d, k = Dt.value, W = k.children || k.childrenField;
      if (f && k.transform) {
        const ie = [], te = {};
        return r.eachTree(d.afterTreeFullData, (he, xe, Me, $e, Ge) => {
          const Fe = yt(U, he), He = yt(U, Ge);
          if (!Ge || te[He] && y[He]) {
            const et = T[Fe];
            et && (et._index = ie.length), te[Fe] = 1, ie.push(he);
          }
        }, { children: W }), d.afterFullData = ie, cl(ie), ie;
      }
      return d.afterFullData;
    }, ts = () => {
      const { treeConfig: f } = e, { tableFullColumn: y, tableFullData: T, tableFullTreeData: k } = d, W = z.value, ie = q.value, te = Dt.value, he = te.children || te.childrenField, { transform: xe } = te, { remote: Me, filterMethod: $e } = W, { remote: Ge, sortMethod: Fe, multiple: He, chronological: et } = ie;
      let Xe = [], nt = [];
      if (!Me || !Ge) {
        const Ct = [];
        let ot = [];
        if (y.forEach((Tt) => {
          const { field: Xt, sortable: Pt, order: tn, filters: pn } = Tt;
          if (!Me && pn && pn.length) {
            const zn = [], On = [];
            pn.forEach((xn) => {
              xn.checked && (On.push(xn), zn.push(xn.value));
            }), On.length && Ct.push({ column: Tt, valueList: zn, itemList: On });
          }
          !Ge && Pt && tn && ot.push({ column: Tt, field: Xt, property: Xt, order: tn, sortTime: Tt.sortTime });
        }), He && et && ot.length > 1 && (ot = r.orderBy(ot, "sortTime")), !Me && Ct.length) {
          const Tt = (Xt) => Ct.every(({ column: Pt, valueList: tn, itemList: pn }) => {
            const { filterMethod: zn, filterRender: On } = Pt, xn = fn(On) ? Np.get(On.name) : null, _n = xn ? xn.tableFilterMethod || xn.filterMethod : null, ln = xn ? xn.tableFilterDefaultMethod || xn.defaultTableFilterMethod || xn.defaultFilterMethod : null, an = Do(Xt, Pt);
            return zn ? pn.some((Hn) => zn({ value: Hn.value, option: Hn, cellValue: an, row: Xt, column: Pt, $table: U })) : _n ? pn.some((Hn) => _n({ value: Hn.value, option: Hn, cellValue: an, row: Xt, column: Pt, $table: U })) : $e ? $e({ options: pn, values: tn, cellValue: an, row: Xt, column: Pt }) : ln ? pn.some((Hn) => ln({ value: Hn.value, option: Hn, cellValue: an, row: Xt, column: Pt, $table: U })) : tn.indexOf(r.get(Xt, Pt.field)) > -1;
          });
          f && xe ? (nt = r.searchTree(k, Tt, {
            original: !0,
            isEvery: !0,
            children: te.mapChildrenField,
            mapChildren: he
          }), Xe = nt) : (Xe = f ? k.filter(Tt) : T.filter(Tt), nt = Xe);
        } else
          f && xe ? (nt = r.searchTree(k, () => !0, {
            original: !0,
            isEvery: !0,
            children: te.mapChildrenField,
            mapChildren: he
          }), Xe = nt) : (Xe = f ? k.slice(0) : T.slice(0), nt = Xe);
        if (!Ge && ot.length)
          if (f && xe) {
            if (Fe) {
              const Tt = Fe({ data: nt, sortList: ot, $table: U });
              nt = r.isArray(Tt) ? Tt : nt;
            } else
              nt = r.orderBy(nt, ot.map(({ column: Tt, order: Xt }) => [oo(Tt), Xt]));
            Xe = nt;
          } else {
            if (Fe) {
              const Tt = Fe({ data: Xe, sortList: ot, $table: U });
              Xe = r.isArray(Tt) ? Tt : Xe;
            } else
              Xe = r.orderBy(Xe, ot.map(({ column: Tt, order: Xt }) => [oo(Tt), Xt]));
            nt = Xe;
          }
      } else
        f && xe ? (nt = r.searchTree(k, () => !0, {
          original: !0,
          isEvery: !0,
          children: te.mapChildrenField,
          mapChildren: he
        }), Xe = nt) : (Xe = f ? k.slice(0) : T.slice(0), nt = Xe);
      d.afterFullData = Xe, d.afterTreeFullData = nt, ko();
    }, Kn = () => {
      const { border: f, showFooter: y, showOverflow: T, showHeaderOverflow: k, showFooterOverflow: W, mouseConfig: ie, spanMethod: te, footerSpanMethod: he, keyboardConfig: xe } = e, { isGroup: Me, currentRow: $e, tableColumn: Ge, scrollXLoad: Fe, scrollYLoad: He, overflowX: et, scrollbarWidth: Xe, scrollbarHeight: nt, columnStore: Ct, editStore: ot, mergeList: Tt, mergeFooterList: Xt, isAllOverflow: Pt } = u;
      let { visibleColumn: tn, fullColumnIdData: pn, tableHeight: zn, tableWidth: On, headerHeight: xn, footerHeight: _n, elemStore: ln, customHeight: an, customMinHeight: Hn, customMaxHeight: Yo } = d;
      const Ss = ["main", "left", "right"], wr = P.value, Er = zt.value, Ds = R.value, Qs = F.value, jr = Ho(ln["main-body-wrapper"]);
      wr && (wr.style.top = `${xn}px`, wr.style.height = jr ? `${jr.offsetHeight - nt}px` : ""), an > 0 && y && (an += nt);
      const qr = H.value;
      qr && (qr.style.height = `${nt}px`);
      const er = ce.value;
      if (er) {
        let so = 0, Xo = 0;
        const Pn = Hn - xn - _n;
        Yo && (Xo = Yo - xn - _n, Xo = Math.max(Pn, Xo)), an && (so = an - xn - _n, Xo && (so = Math.min(Xo, so)), so = Math.max(Pn, so)), er.style.top = `${xn}px`, er.style.width = `${Xe}px`, er.style.height = `${so + (et ? -Math.max(1, nt) : 0)}px`;
      }
      return Ss.forEach((so, Xo) => {
        const Pn = Xo > 0 ? so : "", uo = ["header", "body", "footer"], No = Pn === "left";
        let ro = [], Mo;
        Pn && (ro = No ? Ct.leftList : Ct.rightList, Mo = No ? K.value : L.value), uo.forEach((to) => {
          const ss = Ho(ln[`${so}-${to}-wrapper`]), Os = Ho(ln[`${so}-${to}-table`]);
          if (to === "header") {
            let Zo = On, Eo = Ge;
            Me ? Eo = tn : Pn && (Fe || k) && (Eo = ro), Zo = Eo.reduce((Fo, rs) => Fo + rs.renderWidth, 0), Os && (Os.style.width = Zo ? `${Zo + Xe}px` : "");
            const Ls = Ho(ln[`${so}-${to}-repair`]);
            Ls && (Ls.style.width = `${On}px`);
            const lo = Ho(ln[`${so}-${to}-list`]);
            Me && lo && r.arrayEach(lo.querySelectorAll(".col--group"), (Fo) => {
              const rs = p.getColumnNode(Fo);
              if (rs) {
                const Ur = rs.item, { showHeaderOverflow: As } = Ur, ri = r.isBoolean(As) ? As : k, li = ri === "title" || (ri === !0 || ri === "tooltip") || ri === "ellipsis";
                let ii = 0, fl = 0;
                li && r.eachTree(Ur.children, (ai) => {
                  (!ai.children || !Ur.children.length) && fl++, ii += ai.renderWidth;
                }, { children: "children" }), Fo.style.width = li ? `${ii - fl - (f ? 2 : 0)}px` : "";
              }
            });
          } else if (to === "body") {
            const Zo = Ho(ln[`${so}-${to}-emptyBlock`]);
            if (Tu(ss)) {
              let lo = 0;
              const Fo = Hn - xn - _n;
              if (Yo && (lo = Yo - xn - _n, Pn && (lo -= y ? 0 : nt), lo = Math.max(Fo, lo), ss.style.maxHeight = `${lo}px`), an) {
                let rs = an - xn - _n;
                Pn && (rs -= y ? 0 : nt), lo && (rs = Math.min(lo, rs)), ss.style.height = `${Math.max(Fo, rs)}px`;
              } else
                ss.style.height = "";
              ss.style.minHeight = `${Fo}px`;
            }
            Mo && (Tu(ss) && (ss.style.top = `${xn}px`), Mo.style.height = `${(an > 0 ? an - xn - _n : zn) + xn + _n - nt * (y ? 2 : 1)}px`, Mo.style.width = `${ro.reduce((lo, Fo) => lo + Fo.renderWidth, No ? 0 : Xe)}px`);
            let Eo = On, Ls = Ge;
            Pn && (!u.expandColumn && (He || T && Pt) && !Tt.length && !te && !(xe && Qs.isMerge) ? Ls = ro : Ls = tn), Eo = Ls.reduce((lo, Fo) => lo + Fo.renderWidth, 0), Os && (Os.style.width = Eo ? `${Eo}px` : "", Os.style.paddingRight = Xe && Pn && (Ml["-moz"] || Ml.safari) ? `${Xe}px` : ""), Zo && (Zo.style.width = Eo ? `${Eo}px` : "");
          } else if (to === "footer") {
            let Zo = On, Eo = Ge;
            Pn && (!u.expandColumn && (Fe || W) && (!Xt.length || !he) ? Eo = ro : Eo = tn), Zo = Eo.reduce((Ls, lo) => Ls + lo.renderWidth, 0), Tu(ss) && (Mo && (ss.style.top = `${an > 0 ? an - _n : zn + xn}px`), ss.style.marginTop = `${-Math.max(1, nt)}px`), Os && (Os.style.width = Zo ? `${Zo + Xe}px` : "");
          }
          const si = Ho(ln[`${so}-${to}-colgroup`]);
          si && r.arrayEach(si.children, (Zo) => {
            const Eo = Zo.getAttribute("name");
            if (Eo === "col_gutter" && (Zo.style.width = `${Xe}px`), pn[Eo]) {
              const lo = pn[Eo].column, { showHeaderOverflow: Fo, showFooterOverflow: rs, showOverflow: Ur } = lo;
              let As;
              Zo.style.width = `${lo.renderWidth}px`, to === "header" ? As = r.isUndefined(Fo) || r.isNull(Fo) ? k : Fo : to === "footer" ? As = r.isUndefined(rs) || r.isNull(rs) ? W : rs : As = r.isUndefined(Ur) || r.isNull(Ur) ? T : Ur;
              let aa = As === "title" || (As === !0 || As === "tooltip") || As === "ellipsis";
              const li = Ho(ln[`${so}-${to}-list`]);
              He && !aa && (aa = !0), li && r.arrayEach(li.querySelectorAll(`.${lo.id}`), (ii) => {
                const fl = parseInt(ii.getAttribute("colspan") || 1), ai = ii.querySelector(".vxe-cell");
                let Nd = lo.renderWidth;
                if (ai) {
                  if (fl > 1) {
                    const mb = p.getColumnIndex(lo);
                    for (let au = 1; au < fl; au++) {
                      const Fd = p.getColumns(mb + au);
                      Fd && (Nd += Fd.renderWidth);
                    }
                  }
                  ai.style.width = aa ? `${Nd - Er * fl}px` : "";
                }
              });
            }
          });
        });
      }), $e && p.setCurrentRow($e), ie && Ds.selected && ot.selected.row && ot.selected.column && U.addCellSelectedClass(), me();
    }, $o = (f) => U.triggerValidate ? U.triggerValidate(f) : me(), Wo = (f, y) => {
      $o("blur").catch((T) => T).then(() => {
        U.handleEdit(y, f).then(() => $o("change")).catch((T) => T);
      });
    }, Go = () => {
      const { sortConfig: f } = e;
      if (f) {
        const y = q.value;
        let { defaultSort: T } = y;
        T && (r.isArray(T) || (T = [T]), T.length && ((f.multiple ? T : T.slice(0, 1)).forEach((k, W) => {
          const { field: ie, order: te } = k;
          if (ie && te) {
            const he = p.getColumnByField(ie);
            he && he.sortable && (he.order = te, he.sortTime = Date.now() + W);
          }
        }), y.remote || w.handleTableData(!0).then(Kn)));
      }
    }, Xs = () => {
      const { checkboxConfig: f } = e;
      if (f) {
        const { fullDataRowIdData: y } = d, T = De.value, { checkAll: k, checkRowKeys: W } = T;
        if (k)
          Ze(!0, !0);
        else if (W) {
          const ie = [];
          W.forEach((te) => {
            y[te] && ie.push(y[te].row);
          }), We(ie, !0, !0);
        }
      }
    }, yr = () => {
      const { radioConfig: f } = e;
      if (f) {
        const { fullDataRowIdData: y } = d, T = Qe.value, { checkRowKey: k, reserve: W } = T;
        if (k && (y[k] && ae(y[k].row, !0), W)) {
          const ie = ir(U);
          d.radioReserveRow = { [ie]: k };
        }
      }
    }, ns = () => {
      const { expandConfig: f } = e;
      if (f) {
        const { fullDataRowIdData: y } = d, T = St.value, { expandAll: k, expandRowKeys: W } = T;
        if (k)
          p.setAllRowExpand(!0);
        else if (W) {
          const ie = [];
          W.forEach((te) => {
            y[te] && ie.push(y[te].row);
          }), p.setRowExpand(ie, !0);
        }
      }
    }, zr = (f) => {
      Qe.value.reserve && (d.radioReserveRow = f);
    }, mo = (f, y) => {
      const { checkboxReserveRowMap: T } = d;
      if (De.value.reserve) {
        const W = yt(U, f);
        y ? T[W] = f : T[W] && delete T[W];
      }
    }, ae = (f, y) => {
      const T = Qe.value, { checkMethod: k } = T;
      return f && (y || !k || k({ row: f })) && (u.selectRadioRow = f, zr(f)), me();
    }, We = (f, y, T) => (f && !r.isArray(f) && (f = [f]), w.handleBatchSelectRows(f, !!y, T), w.checkSelectionStatus(), me()), Ze = (f, y) => {
      const { treeConfig: T } = e, { selectCheckboxMaps: k } = u, { afterFullData: W, checkboxReserveRowMap: ie } = d, te = Dt.value, he = te.children || te.childrenField, xe = De.value, { checkField: Me, reserve: $e, checkStrictly: Ge, checkMethod: Fe } = xe, He = xe.indeterminateField || xe.halfField, et = {};
      if (Ge)
        u.isAllSelected = f;
      else {
        if (Me) {
          const Xe = (nt) => {
            (y || !Fe || Fe({ row: nt })) && (f && (et[yt(U, nt)] = nt), r.set(nt, Me, f)), T && He && r.set(nt, He, !1);
          };
          T ? r.eachTree(W, Xe, { children: he }) : W.forEach(Xe);
        } else
          T ? f ? r.eachTree(W, (Xe) => {
            (y || !Fe || Fe({ row: Xe })) && (et[yt(U, Xe)] = Xe);
          }, { children: he }) : !y && Fe && r.eachTree(W, (Xe) => {
            const nt = yt(U, Xe);
            !Fe({ row: Xe }) && k[nt] && (et[nt] = Xe);
          }, { children: he }) : f ? !y && Fe ? W.forEach((Xe) => {
            const nt = yt(U, Xe);
            (k[nt] || Fe({ row: Xe })) && (et[nt] = Xe);
          }) : W.forEach((Xe) => {
            et[yt(U, Xe)] = Xe;
          }) : !y && Fe && W.forEach((Xe) => {
            const nt = yt(U, Xe);
            !Fe({ row: Xe }) && k[nt] && (et[nt] = Xe);
          });
        $e && (f ? r.each(et, (Xe, nt) => {
          ie[nt] = Xe;
        }) : W.forEach((Xe) => mo(Xe, !1))), u.selectCheckboxMaps = Me ? {} : et;
      }
      return u.treeIndeterminateMaps = {}, d.treeIndeterminateRowMaps = {}, w.checkSelectionStatus(), me();
    }, ft = () => {
      const { treeConfig: f } = e, { expandColumn: y, currentRow: T, selectCheckboxMaps: k, selectRadioRow: W, rowExpandedMaps: ie, treeExpandedMaps: te } = u, { fullDataRowIdData: he, fullAllDataRowIdData: xe, radioReserveRow: Me } = d, $e = St.value, Ge = Dt.value, Fe = Qe.value, He = De.value;
      if (W && !xe[yt(U, W)] && (u.selectRadioRow = null), Fe.reserve && Me) {
        const et = yt(U, Me);
        he[et] && ae(he[et].row, !0);
      }
      u.selectCheckboxMaps = En(k), He.reserve && We(mn(d.checkboxReserveRowMap), !0, !0), T && !xe[yt(U, T)] && (u.currentRow = null), u.rowExpandedMaps = y ? En(ie) : {}, y && $e.reserve && p.setRowExpand(mn(d.rowExpandedReserveRowMap), !0), u.treeExpandedMaps = f ? En(te) : {}, f && Ge.reserve && p.setTreeExpand(mn(d.treeExpandedReserveRowMap), !0);
    }, $t = () => {
      const { treeConfig: f } = e;
      if (f) {
        const { tableFullData: y } = d, T = Dt.value, { expandAll: k, expandRowKeys: W } = T, ie = T.children || T.childrenField;
        if (k)
          p.setAllTreeExpand(!0);
        else if (W) {
          const te = [], he = ir(U);
          W.forEach((xe) => {
            const Me = r.findTree(y, ($e) => xe === r.get($e, he), { children: ie });
            Me && te.push(Me.item);
          }), p.setTreeExpand(te, !0);
        }
      }
    }, Mt = (f) => {
      const y = Dt.value, T = De.value, { transform: k, loadMethod: W } = y, { checkStrictly: ie } = T;
      return new Promise((te) => {
        if (W) {
          const { treeExpandLazyLoadedMaps: he } = u, { fullAllDataRowIdData: xe } = d, Me = yt(U, f), $e = xe[Me];
          he[Me] = f, Promise.resolve(W({ $table: U, row: f })).then((Ge) => {
            if ($e && ($e.treeLoaded = !0), he[Me] && delete he[Me], r.isArray(Ge) || (Ge = []), Ge)
              return p.loadTreeChildren(f, Ge).then((Fe) => {
                const { treeExpandedMaps: He } = u;
                return Fe.length && !He[Me] && (He[Me] = f), !ie && p.isCheckedByCheckboxRow(f) && We(Fe, !0), me().then(() => {
                  if (k)
                    return w.handleTableData(), Bo(), me();
                });
              });
          }).catch(() => {
            const { treeExpandLazyLoadedMaps: Ge } = u;
            $e && ($e.treeLoaded = !1), Ge[Me] && delete Ge[Me];
          }).finally(() => {
            me().then(() => p.recalculate()).then(() => te());
          });
        } else
          te();
      });
    }, jt = (f, y) => {
      const { treeExpandedReserveRowMap: T } = d;
      if (Dt.value.reserve) {
        const W = yt(U, f);
        y ? T[W] = f : T[W] && delete T[W];
      }
    }, qt = (f) => new Promise((y) => {
      const T = St.value, { loadMethod: k } = T;
      if (k) {
        const { fullAllDataRowIdData: W } = d, { rowExpandLazyLoadedMaps: ie } = u, te = yt(U, f), he = W[te];
        ie[te] = f, k({ $table: U, row: f, rowIndex: p.getRowIndex(f), $rowIndex: p.getVMRowIndex(f) }).then(() => {
          const { rowExpandedMaps: xe } = u;
          he && (he.expandLoaded = !0), xe[te] = f;
        }).catch(() => {
          he && (he.expandLoaded = !1);
        }).finally(() => {
          const { rowExpandLazyLoadedMaps: xe } = u;
          xe[te] && delete xe[te], me().then(() => p.recalculate()).then(() => y());
        });
      } else
        y();
    }), tt = (f, y) => {
      const { rowExpandedReserveRowMap: T } = d;
      if (St.value.reserve) {
        const W = yt(U, f);
        y ? T[W] = f : T[W] && delete T[W];
      }
    }, _t = () => {
      const { mergeCells: f } = e;
      f && p.setMergeCells(f);
    }, In = () => {
      const { mergeFooterItems: f } = e;
      f && p.setMergeFooterItems(f);
    }, yn = () => me().then(() => {
      const { scrollXLoad: f, scrollYLoad: y } = u, { scrollXStore: T, scrollYStore: k } = d, W = de.value, ie = Oe.value;
      if (f) {
        const { visibleSize: xe } = gn(), Me = Math.max(0, ie.oSize ? r.toNumber(ie.oSize) : Ml.edge ? 5 : 0);
        T.offsetSize = Me, T.visibleSize = xe, T.endIndex = Math.max(T.startIndex + T.visibleSize + Me, T.endIndex), w.updateScrollXData();
      } else
        w.updateScrollXSpace();
      Es();
      const te = Sn();
      k.rowHeight = te, u.rowHeight = te;
      const { visibleSize: he } = Fn();
      if (y) {
        const xe = Math.max(0, W.oSize ? r.toNumber(W.oSize) : Ml.edge ? 10 : 0);
        k.offsetSize = xe, k.visibleSize = he, k.endIndex = Math.max(k.startIndex + he + xe, k.endIndex), w.updateScrollYData();
      } else
        w.updateScrollYSpace();
      me(Kn);
    }), Rn = (f) => {
      const y = v.value;
      return !y || !y.clientWidth ? me() : (ms(), xr(), yn().then(() => {
        if (f === !0)
          return Es(), ms(), xr(), yn();
      }));
    }, To = (f) => {
      const { keepSource: y, treeConfig: T, showOverflow: k } = e, { editStore: W, scrollYLoad: ie } = u, { scrollYStore: te, scrollXStore: he, lastScrollLeft: xe, lastScrollTop: Me } = d, $e = Dt.value, Ge = _e.value, { transform: Fe } = $e, He = $e.children || $e.childrenField;
      let et = [], Xe = Rt(f ? f.slice(0) : []);
      T && (Fe ? (process.env.NODE_ENV === "development" && ($e.rowField || Ut("vxe.error.reqProp", ["tree-config.rowField"]), $e.parentField || Ut("vxe.error.reqProp", ["tree-config.parentField"]), He || Ut("vxe.error.reqProp", ["tree-config.childrenField"]), $e.mapChildrenField || Ut("vxe.error.reqProp", ["tree-config.mapChildrenField"]), He === $e.mapChildrenField && Ut("vxe.error.errConflicts", ["tree-config.childrenField", "tree-config.mapChildrenField"])), et = r.toArrayTree(Xe, {
        key: $e.rowField,
        parentKey: $e.parentField,
        children: He,
        mapChildren: $e.mapChildrenField
      }), Xe = et.slice(0)) : et = Xe.slice(0)), te.startIndex = 0, te.endIndex = 1, he.startIndex = 0, he.endIndex = 1, u.scrollVMLoading = !1, W.insertMaps = {}, W.removeMaps = {};
      const nt = cl(Xe);
      if (u.scrollYLoad = nt, u.isDragRowMove = !1, d.tableFullData = Xe, d.tableFullTreeData = et, w.cacheRowMap(!0), d.tableSynchData = f, y && w.cacheSourceMap(Xe), nt) {
        if (k && !Ge.height) {
          const Ct = d.tableFullColumn.find((ot) => ot.showOverflow === !1);
          Ct && Ut("vxe.error.errProp", [`column[field="${Ct.field}"].show-overflow=false`, "show-overflow=true"]);
        }
        process.env.NODE_ENV === "development" && (e.height || e.maxHeight || Ut("vxe.error.reqProp", ["table.height | table.max-height | table.scroll-y={enabled: false}"]), e.spanMethod && rn("vxe.error.scrollErrProp", ["table.span-method"]));
      }
      return U.clearCellAreas && e.mouseConfig && (U.clearCellAreas(), U.clearCopyCellArea()), p.clearMergeCells(), p.clearMergeFooterItems(), w.handleTableData(!0), p.updateFooter(), me().then(() => {
        Fs(), Kn();
      }).then(() => {
        yn();
      }).then(() => (nt && (te.endIndex = te.visibleSize), ft(), w.checkSelectionStatus(), new Promise((Ct) => {
        me().then(() => p.recalculate()).then(() => {
          let ot = xe, Tt = Me;
          const Xt = Oe.value, Pt = de.value;
          Xt.scrollToLeftOnChange && (ot = 0), Pt.scrollToTopOnChange && (Tt = 0), ie === nt ? Mu(U, ot, Tt).then(Ct) : setTimeout(() => Mu(U, ot, Tt).then(Ct));
        });
      })));
    }, vo = () => {
      Xs(), yr(), ns(), $t(), _t(), In(), me(() => setTimeout(() => p.recalculate()));
    }, go = () => {
      Go();
    }, Xn = () => {
      const { scrollXLoad: f } = u, { visibleColumn: y, scrollXStore: T, fullColumnIdData: k } = d, W = f ? y.slice(T.startIndex, T.endIndex) : y.slice(0);
      W.forEach((ie, te) => {
        const he = ie.id, xe = k[he];
        xe && (xe.$index = te);
      }), u.tableColumn = W;
    }, bo = () => {
      const { mergeList: f, mergeFooterList: y } = u, { scrollXStore: T } = d, { startIndex: k, endIndex: W, offsetSize: ie } = T, { toVisibleIndex: te, visibleSize: he } = gn(), xe = {
        startIndex: Math.max(0, te - 1 - ie),
        endIndex: te + he + ie
      };
      co(f.concat(y), xe, "col");
      const { startIndex: Me, endIndex: $e } = xe;
      (te <= k || te >= W - he - 1) && (k !== Me || W !== $e) && (T.startIndex = Me, T.endIndex = $e, w.updateScrollXData()), p.closeTooltip();
    }, Zs = (f) => {
      const y = [];
      return f.forEach((T) => {
        y.push(...T.children && T.children.length ? Zs(T.children) : [T]);
      }), y;
    }, Jl = () => {
      const { showOverflow: f } = e, y = _e.value, T = [], k = [], W = [], { isGroup: ie, columnStore: te } = u, he = Oe.value, { collectColumn: xe, tableFullColumn: Me, scrollXStore: $e, fullColumnIdData: Ge } = d;
      if (ie) {
        const et = [], Xe = [], nt = [];
        r.eachTree(xe, (Ct, ot, Tt, Xt, Pt) => {
          const tn = Tl(Ct);
          Pt && Pt.fixed && (Ct.fixed = Pt.fixed), Pt && Ct.fixed !== Pt.fixed && Ut("vxe.error.groupFixed"), tn ? Ct.visible = !!r.findTree(Ct.children, (pn) => Tl(pn) ? !1 : pn.visible) : Ct.visible && (Ct.fixed === "left" ? T.push(Ct) : Ct.fixed === "right" ? W.push(Ct) : k.push(Ct));
        }), xe.forEach((Ct) => {
          Ct.visible && (Ct.fixed === "left" ? et.push(Ct) : Ct.fixed === "right" ? nt.push(Ct) : Xe.push(Ct));
        }), u.tableGroupColumn = et.concat(Xe).concat(nt);
      } else
        Me.forEach((et) => {
          et.visible && (et.fixed === "left" ? T.push(et) : et.fixed === "right" ? W.push(et) : k.push(et));
        });
      const Fe = T.concat(k).concat(W), He = !!he.enabled && he.gt > -1 && (he.gt === 0 || he.gt < Me.length);
      if (u.hasFixedColumn = T.length > 0 || W.length > 0, Object.assign(te, { leftList: T, centerList: k, rightList: W }), He) {
        if (f && !y.height) {
          const Xe = d.tableFullColumn.find((nt) => nt.showOverflow === !1);
          Xe && Ut("vxe.error.errProp", [`column[field="${Xe.field}"].show-overflow=false`, "show-overflow=true"]);
        }
        process.env.NODE_ENV === "development" && (e.spanMethod && rn("vxe.error.scrollErrProp", ["span-method"]), e.footerSpanMethod && rn("vxe.error.scrollErrProp", ["footer-span-method"]));
        const { visibleSize: et } = gn();
        $e.startIndex = 0, $e.endIndex = et, $e.visibleSize = et;
      }
      return (Fe.length !== d.visibleColumn.length || !d.visibleColumn.every((et, Xe) => et === Fe[Xe])) && (p.clearMergeCells(), p.clearMergeFooterItems()), u.scrollXLoad = He, Fe.forEach((et, Xe) => {
        const nt = et.id, Ct = Ge[nt];
        Ct && (Ct._index = Xe);
      }), d.visibleColumn = Fe, Xn(), p.updateFooter().then(() => p.recalculate()).then(() => (p.updateCellAreas(), p.recalculate()));
    }, sa = () => {
      const { collectColumn: f } = d;
      f.forEach((y, T) => {
        const k = T + 1;
        y.sortNumber = k, y.renderSortNumber = k;
      });
    }, ra = (f) => {
      d.collectColumn = f;
      const y = Zs(f);
      return d.tableFullColumn = y, u._isLoading = !0, u.isDragColMove = !1, sa(), Promise.resolve(Po()).then(() => (u._isLoading = !1, Ys(), Jl().then(() => {
        u.scrollXLoad && bo();
      }), p.clearMergeCells(), p.clearMergeFooterItems(), w.handleTableData(!0), process.env.NODE_ENV === "development" && (u.scrollXLoad || u.scrollYLoad) && u.expandColumn && rn("vxe.error.scrollErrProp", ["column.type=expand"]), me().then(() => ($ && $.syncUpdate({ collectColumn: f, $table: U }), p.recalculate()))));
    }, cl = (f) => {
      const { treeConfig: y } = e, T = de.value, k = Dt.value, { transform: W } = k, ie = f || d.tableFullData, te = (W || !y) && !!T.enabled && T.gt > -1 && (T.gt === 0 || T.gt < ie.length);
      return u.scrollYLoad = te, te;
    }, la = (f, y) => {
      const { treeExpandedMaps: T, treeExpandLazyLoadedMaps: k, treeNodeColumn: W } = u, ie = Object.assign({}, T), { fullAllDataRowIdData: te, tableFullData: he } = d, xe = Dt.value, { reserve: Me, lazy: $e, accordion: Ge, toggleMethod: Fe } = xe, He = xe.children || xe.childrenField, et = xe.hasChild || xe.hasChildField, Xe = [], nt = p.getColumnIndex(W), Ct = p.getVMColumnIndex(W);
      let ot = Fe ? f.filter((Tt) => Fe({ $table: U, expanded: y, column: W, columnIndex: nt, $columnIndex: Ct, row: Tt })) : f;
      if (Ge) {
        ot = ot.length ? [ot[ot.length - 1]] : [];
        const Tt = r.findTree(he, (Xt) => Xt === ot[0], { children: He });
        Tt && Tt.items.forEach((Xt) => {
          const Pt = yt(U, Xt);
          ie[Pt] && delete ie[Pt];
        });
      }
      return y ? ot.forEach((Tt) => {
        const Xt = yt(U, Tt);
        if (!ie[Xt]) {
          const Pt = te[Xt];
          Pt && ($e && Tt[et] && !Pt.treeLoaded && !k[Xt] ? Xe.push(Mt(Tt)) : Tt[He] && Tt[He].length && (ie[Xt] = Tt));
        }
      }) : ot.forEach((Tt) => {
        const Xt = yt(U, Tt);
        ie[Xt] && delete ie[Xt];
      }), Me && ot.forEach((Tt) => jt(Tt, y)), u.treeExpandedMaps = ie, Promise.all(Xe).then(() => p.recalculate());
    }, Zc = (f, y) => la(f, y).then(() => {
      _o(), w.handleTableData(), Bo();
    }).then(() => p.recalculate()).then(() => {
      setTimeout(() => {
        p.updateCellAreas();
      }, 30);
    }), ia = (f, y) => {
      Ze(y), f && bt("checkbox-all", {
        records: p.getCheckboxRecords(),
        reserves: p.getCheckboxReserveRecords(),
        indeterminates: p.getCheckboxIndeterminateRecords(),
        checked: y
      }, f);
    }, Ql = () => {
      const { showOverflow: f } = e, { mergeList: y } = u, { tableHeight: T, scrollYStore: k } = d, { startIndex: W, endIndex: ie, offsetSize: te } = k, he = f ? te : te + Math.min(8, Math.ceil(T / 200)), { toVisibleIndex: xe, visibleSize: Me } = Fn(), $e = {
        startIndex: Math.max(0, xe - 1 - he),
        endIndex: xe + Me + he
      };
      co(y, $e, "row");
      const { startIndex: Ge, endIndex: Fe } = $e;
      (xe <= W || xe >= ie - Me - 1) && (W !== Ge || ie !== Fe) && (k.startIndex = Ge, k.endIndex = Fe, w.updateScrollYData());
    }, ul = (f) => function(y) {
      const { fullAllDataRowIdData: T } = d;
      if (y) {
        const k = yt(U, y), W = T[k];
        if (W)
          return W[f];
      }
      return -1;
    }, ei = (f) => function(y) {
      const { fullColumnIdData: T } = d;
      if (y) {
        const k = T[y.id];
        if (k)
          return k[f];
      }
      return -1;
    }, $d = () => {
      const { lxTimeout: f, lxRunTime: y, scrollXStore: T } = d, { visibleSize: k } = T, W = Math.min(80, Math.floor(k * 3));
      f && clearTimeout(f), (!y || y + W < Date.now()) && (d.lxRunTime = Date.now(), bo()), d.lxTimeout = setTimeout(() => {
        d.lxRunTime = void 0, d.lxRunTime = void 0, bo();
      }, W);
    }, Jc = () => {
      const { lyTimeout: f, lyRunTime: y, scrollYStore: T } = d, { visibleSize: k } = T, W = Math.min(80, Math.floor(k * 2));
      f && clearTimeout(f), (!y || y + W < Date.now()) && (d.lyRunTime = Date.now(), Ql()), d.lyTimeout = setTimeout(() => {
        d.lyTimeout = void 0, d.lyRunTime = void 0, Ql();
      }, W);
    }, X = (f) => {
      const { inFooterScroll: y, inBodyScroll: T, lastScrollTop: k } = d;
      if (y || T)
        return;
      const W = b.value, ie = E.value, te = C.value, he = ie.$el, xe = W ? W.$el : null, Me = te ? te.$el : null, $e = j.value, Ge = f.currentTarget, { scrollLeft: Fe } = Ge, He = $e || he;
      let et = 0;
      He && (et = He.scrollTop);
      const Xe = !0, nt = et !== k;
      d.inVirtualScroll = !0, fo(he, Fe), fo(xe, Fe), fo(Me, Fe), U.triggerScrollXEvent(f), U.handleScrollEvent(f, nt, Xe, et, Fe, {
        type: "table",
        fixed: ""
      });
    }, Le = (f) => {
      const { inFooterScroll: y, inBodyScroll: T, lastScrollLeft: k } = d;
      if (y || T)
        return;
      const W = E.value, ie = Q.value, te = ue.value, he = W.$el, xe = ie ? ie.$el : null, Me = te ? te.$el : null, $e = A.value, Ge = f.currentTarget, { scrollTop: Fe } = Ge, He = $e || he;
      let et = 0;
      He && (et = He.scrollLeft);
      const Xe = et !== k, nt = !0;
      d.inVirtualScroll = !0, no(he, Fe), no(xe, Fe), no(Me, Fe), U.triggerScrollYEvent(f), U.handleScrollEvent(f, nt, Xe, Fe, et, {
        type: "table",
        fixed: ""
      });
    }, qe = (f, y) => {
      const { scrollXLoad: T, scrollYLoad: k } = u, { lcsTimeout: W } = d;
      W && clearTimeout(W), d.lcsTimeout = setTimeout(() => {
        d.lcsTimeout = void 0, d.inVirtualScroll = !1, d.inBodyScroll = !1, d.bodyScrollType = "", d.inFooterScroll = !1, f && T && w.updateScrollXData(), y && k && w.updateScrollYData(), p.updateCellAreas();
      }, 200);
    };
    let gt;
    const bt = (f, y, T) => {
      s(f, GN(T, { $table: U, $grid: ne }, y));
    }, It = (f, y) => {
      const { fullColumnIdData: T } = d, k = io(U, f);
      return k && T[k.id] ? Ep(U, k, y) : me();
    };
    p = {
      dispatchEvent: bt,
      /**
       * 重置表格的一切数据状态
       */
      clearAll() {
        return MN(U);
      },
      /**
       * 同步 data 数据（即将废弃）
       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
       */
      syncData() {
        return rn("vxe.error.delFunc", ["syncData", "getData"]), me().then(() => (u.tableData = [], s("update:data", d.tableFullData), me()));
      },
      /**
       * 手动处理数据，用于手动排序与筛选
       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
       */
      updateData() {
        const { scrollXLoad: f, scrollYLoad: y } = u;
        return w.handleTableData(!0).then(() => {
          if (p.updateFooter(), f || y)
            return f && w.updateScrollXSpace(), y && w.updateScrollYSpace(), p.refreshScroll();
        }).then(() => (p.updateCellAreas(), p.recalculate(!0))).then(() => {
          setTimeout(() => U.recalculate(), 50);
        });
      },
      /**
       * 重新加载数据，不会清空表格状态
       * @param {Array} datas 数据
       */
      loadData(f) {
        const { inited: y, initStatus: T } = d;
        return To(f).then(() => (d.inited = !0, d.initStatus = !0, T || vo(), y || go(), p.recalculate()));
      },
      /**
       * 重新加载数据，会清空表格状态
       * @param {Array} datas 数据
       */
      reloadData(f) {
        const { inited: y } = d;
        return p.clearAll().then(() => (d.inited = !0, d.initStatus = !0, To(f))).then(() => (vo(), y || go(), p.recalculate()));
      },
      /**
       * 修改行数据
       */
      setRow(f, y) {
        if (f && y) {
          let T = f;
          r.isArray(f) || (T = [f]);
          const k = ir(U);
          T.forEach((W) => {
            const ie = yt(U, W), te = r.clone(Object.assign({}, y), !0);
            r.set(te, k, ie), Object.assign(W, te);
          });
        }
        return me();
      },
      /**
       * 局部加载行数据并恢复到初始状态
       * 对于行数据需要局部更改的场景中可能会用到
       * @param {Row} row 行对象
       * @param {Object} record 新数据
       * @param {String} field 字段名
       */
      reloadRow(f, y, T) {
        const { keepSource: k } = e, { tableData: W } = u, { tableSourceData: ie } = d;
        if (k) {
          const te = p.getRowIndex(f), he = ie[te];
          if (he && f)
            if (T) {
              const xe = r.clone(r.get(y || f, T), !0);
              r.set(f, T, xe), r.set(he, T, xe);
            } else {
              const xe = ir(U), Me = yt(U, f), $e = r.clone(Object.assign({}, y), !0);
              r.set($e, xe, Me), r.destructuring(he, Object.assign(f, $e));
            }
          u.tableData = W.slice(0);
        } else
          process.env.NODE_ENV === "development" && rn("vxe.error.reqProp", ["keep-source"]);
        return me();
      },
      getParams() {
        return e.params;
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadTreeChildren(f, y) {
        const { keepSource: T } = e, { tableSourceData: k, fullDataRowIdData: W, fullAllDataRowIdData: ie, sourceDataRowIdData: te } = d, he = Dt.value, { transform: xe, mapChildrenField: Me } = he, $e = he.children || he.childrenField, Ge = ie[yt(U, f)], Fe = Ge ? Ge.level : 0;
        return p.createData(y).then((He) => {
          if (T) {
            const et = yt(U, f), Xe = r.findTree(k, (nt) => et === yt(U, nt), { children: $e });
            Xe && (Xe.item[$e] = r.clone(He, !0)), He.forEach((nt) => {
              const Ct = yt(U, nt);
              te[Ct] = r.clone(nt, !0);
            });
          }
          return r.eachTree(He, (et, Xe, nt, Ct, ot, Tt) => {
            const Xt = yt(U, et), Pt = ot || Ge.row, tn = { row: et, rowid: Xt, seq: -1, index: Xe, _index: -1, $index: -1, items: nt, parent: Pt, level: Fe + Tt.length, height: 0 };
            W[Xt] = tn, ie[Xt] = tn;
          }, { children: $e }), f[$e] = He, xe && (f[Me] = r.clone(He, !1)), ko(), He;
        });
      },
      /**
       * 加载列配置
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      loadColumn(f) {
        const y = r.mapTree(f, (T) => Rt(sn.createColumn(U, T)));
        return ra(y);
      },
      /**
       * 加载列配置并恢复到初始状态
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      reloadColumn(f) {
        return p.clearAll().then(() => p.loadColumn(f));
      },
      /**
       * 根据 tr 元素获取对应的 row 信息
       * @param {Element} tr 元素
       */
      getRowNode(f) {
        if (f) {
          const { fullAllDataRowIdData: y } = d, T = f.getAttribute("rowid");
          if (T) {
            const k = y[T];
            if (k)
              return {
                rowid: k.rowid,
                item: k.row,
                index: k.index,
                items: k.items,
                parent: k.parent
              };
          }
        }
        return null;
      },
      /**
       * 根据 th/td 元素获取对应的 column 信息
       * @param {Element} cell 元素
       */
      getColumnNode(f) {
        if (f) {
          const { fullColumnIdData: y } = d, T = f.getAttribute("colid");
          if (T) {
            const k = y[T];
            if (k)
              return {
                colid: k.colid,
                item: k.column,
                index: k.index,
                items: k.items,
                parent: k.parent
              };
          }
        }
        return null;
      },
      /**
       * 根据 row 获取序号
       * @param {Row} row 行对象
       */
      getRowSeq: ul("seq"),
      /**
       * 根据 row 获取相对于 data 中的索引
       * @param {Row} row 行对象
       */
      getRowIndex: ul("index"),
      /**
       * 根据 row 获取相对于当前数据中的索引
       * @param {Row} row 行对象
       */
      getVTRowIndex: ul("_index"),
      /**
       * 根据 row 获取渲染中的虚拟索引
       * @param {Row} row 行对象
       */
      getVMRowIndex: ul("$index"),
      /**
       * 根据 column 获取相对于 columns 中的索引
       * @param {ColumnInfo} column 列配置
       */
      getColumnIndex: ei("index"),
      /**
       * 根据 column 获取相对于当前表格列中的索引
       * @param {ColumnInfo} column 列配置
       */
      getVTColumnIndex: ei("_index"),
      /**
       * 根据 column 获取渲染中的虚拟索引
       * @param {ColumnInfo} column 列配置
       */
      getVMColumnIndex: ei("$index"),
      /**
       * 创建 data 对象
       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
       * @param {Array} records 新数据
       */
      createData(f) {
        return me().then(() => Rt(w.defineField(f)));
      },
      /**
       * 创建 Row|Rows 对象
       * 对于某些特殊场景需要对数据进行手动插入时可能会用到
       * @param {Array/Object} records 新数据
       */
      createRow(f) {
        const y = r.isArray(f);
        return y || (f = [f || {}]), p.createData(f).then((T) => y ? T : T[0]);
      },
      // toOriginalRecords (rows: any[]) {
      //   const { treeConfig } = props
      //   const treeOpts = computeTreeOpts.value
      //   const { transform, mapChildrenField } = treeOpts
      //   const rowkey = getRowkey($xeTable)
      //   if (treeConfig) {
      //     if (transform) {
      //       return []
      //     }
      //     return []
      //   }
      //   return rows.map(item => {
      //     const obj = Object.assign({}, item)
      //     delete obj.rowkey
      //     return obj
      //   })
      // },
      /**
       * 还原数据
       * 如果不传任何参数，则还原整个表格
       * 如果传 row 则还原一行
       * 如果传 rows 则还原多行
       * 如果还额外传了 field 则还原指定的单元格数据
       */
      revertData(f, y) {
        const { keepSource: T } = e, { tableSourceData: k, sourceDataRowIdData: W } = d;
        if (!T)
          return process.env.NODE_ENV === "development" && rn("vxe.error.reqProp", ["keep-source"]), me();
        let ie = f;
        return f ? r.isArray(f) || (ie = [f]) : ie = r.toArray(U.getUpdateRecords()), ie.length && ie.forEach((te) => {
          if (!p.isInsertByRow(te)) {
            const he = yt(U, te), xe = W[he];
            xe && te && (y ? r.set(te, y, r.clone(r.get(xe, y), !0)) : r.destructuring(te, r.clone(xe, !0)));
          }
        }), f ? me() : p.reloadData(k);
      },
      /**
       * 清空单元格内容
       * 如果不创参数，则清空整个表格内容
       * 如果传 row 则清空一行内容
       * 如果传 rows 则清空多行内容
       * 如果还额外传了 field 则清空指定单元格内容
       * @param {Array/Row} rows 行数据
       * @param {String} field 字段名
       */
      clearData(f, y) {
        const { tableFullData: T, visibleColumn: k } = d;
        return arguments.length ? f && !r.isArray(f) && (f = [f]) : f = T, y ? f.forEach((W) => r.set(W, y, null)) : f.forEach((W) => {
          k.forEach((ie) => {
            ie.field && js(W, ie, null);
          });
        }), me();
      },
      getCellElement(f, y) {
        const T = io(U, y);
        if (!T)
          return null;
        const k = yt(U, f), W = E.value, ie = Q.value, te = ue.value;
        let he;
        return T && (T.fixed && (T.fixed === "left" ? ie && (he = ie.$el) : te && (he = te.$el)), he || (he = W.$el), he) ? he.querySelector(`.vxe-body--row[rowid="${k}"] .${T.id}`) : null;
      },
      getCellLabel(f, y) {
        const T = io(U, y);
        if (!T)
          return null;
        const k = T.formatter, W = Do(f, T);
        let ie = W;
        if (k) {
          let te;
          const { fullAllDataRowIdData: he } = d, xe = yt(U, f), Me = T.id, $e = he[xe];
          if ($e && (te = $e.formatData, te || (te = he[xe].formatData = {}), $e && te[Me] && te[Me].value === W))
            return te[Me].label;
          const Ge = { cellValue: W, row: f, rowIndex: p.getRowIndex(f), column: T, columnIndex: p.getColumnIndex(T) };
          if (r.isString(k)) {
            const Fe = Fp.get(k), He = Fe ? Fe.tableCellFormatMethod || Fe.cellFormatMethod : null;
            ie = He ? He(Ge) : "";
          } else if (r.isArray(k)) {
            const Fe = Fp.get(k[0]), He = Fe ? Fe.tableCellFormatMethod || Fe.cellFormatMethod : null;
            ie = He ? He(Ge, ...k.slice(1)) : "";
          } else
            ie = k(Ge);
          te && (te[Me] = { value: W, label: ie });
        }
        return ie;
      },
      /**
       * 检查是否为临时行数据
       * @param {Row} row 行对象
       */
      isInsertByRow(f) {
        const { editStore: y } = u, T = yt(U, f);
        return !!y.insertMaps[T];
      },
      /**
       * 删除所有新增的临时数据
       * @returns
       */
      removeInsertRow() {
        const { editStore: f } = u;
        return f.insertMaps = {}, U.remove(U.getInsertRecords());
      },
      /**
       * 检查行或列数据是否发生改变
       * @param {Row} row 行对象
       * @param {String} field 字段名
       */
      isUpdateByRow(f, y) {
        const { keepSource: T } = e, { tableFullColumn: k, fullDataRowIdData: W, sourceDataRowIdData: ie } = d;
        if (T) {
          const te = yt(U, f);
          if (!W[te])
            return !1;
          const he = ie[te];
          if (he) {
            if (arguments.length > 1)
              return !Lt(he, f, y);
            for (let xe = 0, Me = k.length; xe < Me; xe++) {
              const $e = k[xe].field;
              if ($e && !Lt(he, f, $e))
                return !0;
            }
          }
        }
        return !1;
      },
      /**
       * 获取表格的可视列，也可以指定索引获取列
       * @param {Number} columnIndex 索引
       */
      getColumns(f) {
        const y = d.visibleColumn;
        return r.isUndefined(f) ? y.slice(0) : y[f];
      },
      /**
       * 根据列获取列的唯一主键
       */
      getColid(f) {
        const y = io(U, f);
        return y ? y.id : null;
      },
      /**
       * 根据列的唯一主键获取列
       * @param {String} colid 列主键
       */
      getColumnById(f) {
        const y = d.fullColumnIdData;
        return f && y[f] ? y[f].column : null;
      },
      /**
       * 根据列的字段名获取列
       * @param {String} field 字段名
       */
      getColumnByField(f) {
        const y = d.fullColumnFieldData;
        return f && y[f] ? y[f].column : null;
      },
      getParentColumn(f) {
        const y = d.fullColumnIdData, T = io(U, f);
        return T && T.parentId && y[T.parentId] ? y[T.parentId].column : null;
      },
      /**
       * 获取当前表格的列
       * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
       */
      getTableColumn() {
        return {
          collectColumn: d.collectColumn.slice(0),
          fullColumn: d.tableFullColumn.slice(0),
          visibleColumn: d.visibleColumn.slice(0),
          tableColumn: u.tableColumn.slice(0)
        };
      },
      /**
       * 获取表格的全量列
       */
      getFullColumns() {
        const { collectColumn: f } = d;
        return f.slice(0);
      },
      /**
       * 获取数据，和 data 的行为一致，也可以指定索引获取数据
       */
      getData(f) {
        const y = e.data || d.tableSynchData;
        return r.isUndefined(f) ? y.slice(0) : y[f];
      },
      /**
       * 用于多选行，获取已选中的数据
       */
      getCheckboxRecords(f) {
        const { treeConfig: y } = e, { tableFullData: T, afterFullData: k, afterTreeFullData: W, tableFullTreeData: ie, fullDataRowIdData: te, afterFullRowMaps: he } = d, xe = Dt.value, Me = De.value, { transform: $e, mapChildrenField: Ge } = xe, { checkField: Fe } = Me, He = xe.children || xe.childrenField;
        let et = [];
        const Xe = f ? $e ? ie : T : $e ? W : k;
        if (Fe)
          y ? et = r.filterTree(Xe, (nt) => r.get(nt, Fe), { children: $e ? Ge : He }) : et = Xe.filter((nt) => r.get(nt, Fe));
        else {
          const { selectCheckboxMaps: nt } = u;
          r.each(nt, (Ct, ot) => {
            f ? te[ot] && et.push(te[ot].row) : he[ot] && et.push(he[ot]);
          });
        }
        return et;
      },
      /**
       * 只对 tree-config 有效，获取行的子级
       */
      getTreeRowChildren(f) {
        const { treeConfig: y } = e, { fullDataRowIdData: T } = d, k = Dt.value, { transform: W, mapChildrenField: ie } = k, te = k.children || k.childrenField;
        if (f && y) {
          let he;
          if (r.isString(f) ? he = f : he = yt(U, f), he) {
            const xe = T[he], Me = xe ? xe.row : null;
            if (Me)
              return Me[W ? ie : te] || [];
          }
        }
        return [];
      },
      /**
       * 只对 tree-config 有效，获取行的父级
       */
      getTreeParentRow(f) {
        const { treeConfig: y } = e, { fullDataRowIdData: T } = d;
        if (f && y) {
          let k;
          if (r.isString(f) ? k = f : k = yt(U, f), k) {
            const W = T[k];
            return W ? W.parent : null;
          }
        }
        return null;
      },
      getParentRow(f) {
        return rn("vxe.error.delFunc", ["getParentRow", "getTreeParentRow"]), U.getTreeParentRow(f);
      },
      /**
       * 根据行的唯一主键获取行
       * @param {String/Number} rowid 行主键
       */
      getRowById(f) {
        const { fullDataRowIdData: y } = d, T = r.eqNull(f) ? "" : encodeURIComponent(f || "");
        return y[T] ? y[T].row : null;
      },
      /**
       * 根据行获取行的唯一主键
       * @param {Row} row 行对象
       */
      getRowid(f) {
        return yt(U, f);
      },
      /**
       * 获取处理后的表格数据
       * 如果存在筛选条件，继续处理
       * 如果存在排序，继续处理
       */
      getTableData() {
        const { tableData: f, footerTableData: y } = u, { tableFullData: T, afterFullData: k, tableFullTreeData: W } = d;
        return {
          fullData: e.treeConfig ? W.slice(0) : T.slice(0),
          visibleData: k.slice(0),
          tableData: f.slice(0),
          footerData: y.slice(0)
        };
      },
      /**
       * 获取表格的全量数据，如果是 tree-config 则返回带层级的树结构
       */
      getFullData() {
        const { treeConfig: f } = e, { tableFullData: y, tableFullTreeData: T } = d;
        if (f) {
          const k = Dt.value, { transform: W, mapChildrenField: ie } = k, te = k.children || k.childrenField;
          return W ? r.toArrayTree(r.toTreeArray(T, {
            children: ie
          }), { children: te }) : T.slice(0);
        }
        return y.slice(0);
      },
      /**
       * 设置为固定列
       */
      setColumnFixed(f, y) {
        let T = !1;
        const k = r.isArray(f) ? f : [f], W = Ue.value, ie = rt.value;
        for (let te = 0; te < k.length; te++) {
          const he = k[te], xe = io(U, he), Me = Cp(U, xe);
          if (Me && Me.fixed !== y) {
            if (!Me.fixed && ie)
              return Ce.modal && Ce.modal.message({
                status: "error",
                content: bl("vxe.table.maxFixedCol", [W.maxFixedSize])
              }), me();
            r.eachTree([Me], ($e) => {
              $e.fixed = y;
            }), w.saveCustomStore("update:fixed"), T || (T = !0);
          }
        }
        return T ? p.refreshColumn() : me();
      },
      /**
       * 取消指定固定列
       */
      clearColumnFixed(f) {
        let y = !1;
        return (r.isArray(f) ? f : [f]).forEach((k) => {
          const W = io(U, k), ie = Cp(U, W);
          ie && ie.fixed && (r.eachTree([ie], (te) => {
            te.fixed = null;
          }), w.saveCustomStore("update:fixed"), y || (y = !0));
        }), y ? p.refreshColumn() : me();
      },
      /**
       * 隐藏指定列
       */
      hideColumn(f) {
        let y = !1;
        return (r.isArray(f) ? f : [f]).forEach((k) => {
          const W = io(U, k);
          W && W.visible && (W.visible = !1, y || (y = !0));
        }), y ? w.handleCustom() : me();
      },
      /**
       * 显示指定列
       */
      showColumn(f) {
        let y = !1;
        return (r.isArray(f) ? f : [f]).forEach((k) => {
          const W = io(U, k);
          W && !W.visible && (W.visible = !0, y || (y = !0));
        }), y ? w.handleCustom() : me();
      },
      setColumnWidth(f, y) {
        let T = !1;
        return (r.isArray(f) ? f : [f]).forEach((W) => {
          const ie = io(U, W);
          if (ie) {
            const te = r.toInteger(y);
            let he = te;
            if (Ci(y)) {
              const xe = E.value, Me = xe ? xe.$el : null, $e = Me ? Me.clientWidth - 1 : 0;
              he = Math.floor(te * $e);
            }
            ie.resizeWidth = he, T || (T = !0);
          }
        }), T ? p.refreshColumn() : me();
      },
      getColumnWidth(f) {
        const y = io(U, f);
        return y ? y.renderWidth : 0;
      },
      /**
       * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；
       * 如果为 true 则重置所有状态
       * 如果已关联工具栏，则会同步更新
       */
      resetColumn(f) {
        return rn("vxe.error.delFunc", ["resetColumn", "resetCustom"]), U.resetCustom(f);
      },
      /**
       * 刷新列信息
       * 将固定的列左边、右边分别靠边
       * 如果传 true 则会检查列顺序并排序
       */
      refreshColumn(f) {
        if (f) {
          const y = r.orderBy(d.collectColumn, "renderSortNumber");
          d.collectColumn = y;
          const T = Zs(y);
          d.tableFullColumn = T, Ys();
        }
        return Jl().then(() => p.refreshScroll()).then(() => p.recalculate());
      },
      /**
       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
       */
      refreshScroll() {
        const { lastScrollLeft: f, lastScrollTop: y } = d, T = E.value, k = C.value, W = Q.value, ie = ue.value, te = T ? T.$el : null, he = W ? W.$el : null, xe = ie ? ie.$el : null, Me = k ? k.$el : null;
        return new Promise(($e) => {
          if (f || y)
            return Mu(U, f, y).then().then(() => {
              setTimeout($e, 30);
            });
          no(te, y), no(he, y), no(xe, y), fo(Me, f), setTimeout($e, 30);
        });
      },
      /**
       * 重新渲染布局
       * 刷新布局
       */
      recalculate(f) {
        return new Promise((y) => {
          const { rceTimeout: T } = d;
          T ? (clearTimeout(T), me(() => {
            y();
          })) : y(Rn(!!f)), d.rceTimeout = setTimeout(() => {
            d.rceTimeout = void 0, Rn(!!f);
          }, 20);
        });
      },
      openTooltip(f, y) {
        const T = S.value;
        return T && T.open ? T.open(f, y) : me();
      },
      /**
       * 关闭 tooltip
       */
      closeTooltip() {
        const { tooltipStore: f } = u, y = D.value, T = S.value;
        return f.visible && (Object.assign(f, {
          row: null,
          column: null,
          content: null,
          visible: !1,
          currOpts: {}
        }), y && y.close && y.close()), T && T.close && T.close(), me();
      },
      /**
       * 判断列头复选框是否被选中
       */
      isAllCheckboxChecked() {
        return u.isAllSelected;
      },
      /**
       * 判断列头复选框是否被半选
       */
      isAllCheckboxIndeterminate() {
        return !u.isAllSelected && u.isIndeterminate;
      },
      /**
       * 获取复选框半选状态的行数据
       */
      getCheckboxIndeterminateRecords(f) {
        const { treeConfig: y } = e, { fullDataRowIdData: T } = d, { treeIndeterminateMaps: k } = u;
        if (y) {
          const W = [], ie = [];
          return r.each(k, (te, he) => {
            te && (W.push(te), T[he] && ie.push(te));
          }), f ? W : ie;
        }
        return [];
      },
      /**
       * 用于多选行，设置行为选中状态，第二个参数为选中与否
       * @param {Array/Row} rows 行数据
       * @param {Boolean} value 是否选中
       */
      setCheckboxRow(f, y) {
        return f && !r.isArray(f) && (f = [f]), We(f, y, !0);
      },
      isCheckedByCheckboxRow(f) {
        const { selectCheckboxMaps: y } = u, T = De.value, { checkField: k } = T;
        return k ? r.get(f, k) : !!y[yt(U, f)];
      },
      isIndeterminateByCheckboxRow(f) {
        const { treeIndeterminateMaps: y } = u;
        return !!y[yt(U, f)] && !p.isCheckedByCheckboxRow(f);
      },
      /**
       * 多选，切换某一行的选中状态
       */
      toggleCheckboxRow(f) {
        const { selectCheckboxMaps: y } = u, T = De.value, { checkField: k } = T, W = k ? !r.get(f, k) : !y[yt(U, f)];
        return w.handleSelectRow({ row: f }, W, !0), w.checkSelectionStatus(), me();
      },
      /**
       * 用于多选行，设置所有行的选中状态
       * @param {Boolean} value 是否选中
       */
      setAllCheckboxRow(f) {
        return Ze(f, !0);
      },
      /**
       * 获取单选框保留选中的行
       */
      getRadioReserveRecord(f) {
        const { treeConfig: y } = e, { fullDataRowIdData: T, radioReserveRow: k, afterFullData: W } = d, ie = Qe.value, te = Dt.value, he = te.children || te.childrenField;
        if (ie.reserve && k) {
          const xe = yt(U, k);
          if (f) {
            if (!T[xe])
              return k;
          } else {
            const Me = ir(U);
            if (y) {
              if (r.findTree(W, (Ge) => xe === r.get(Ge, Me), { children: he }))
                return k;
            } else if (!W.some(($e) => xe === r.get($e, Me)))
              return k;
          }
        }
        return null;
      },
      clearRadioReserve() {
        return d.radioReserveRow = null, me();
      },
      /**
       * 获取复选框保留选中的行
       */
      getCheckboxReserveRecords(f) {
        const { treeConfig: y } = e, { afterFullData: T, fullDataRowIdData: k, checkboxReserveRowMap: W } = d, ie = De.value, te = Dt.value, he = te.children || te.childrenField, xe = [];
        if (ie.reserve) {
          const Me = {};
          y ? r.eachTree(T, ($e) => {
            Me[yt(U, $e)] = 1;
          }, { children: he }) : T.forEach(($e) => {
            Me[yt(U, $e)] = 1;
          }), r.each(W, ($e, Ge) => {
            $e && (f ? k[Ge] || xe.push($e) : Me[Ge] || xe.push($e));
          });
        }
        return xe;
      },
      clearCheckboxReserve() {
        return d.checkboxReserveRowMap = {}, me();
      },
      /**
       * 多选，切换所有行的选中状态
       */
      toggleAllCheckboxRow() {
        return ia(null, !u.isAllSelected), me();
      },
      /**
       * 用于多选行，手动清空用户的选择
       * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
       */
      clearCheckboxRow() {
        const { treeConfig: f } = e, { tableFullData: y } = d, T = Dt.value, k = T.children || T.childrenField, W = De.value, { checkField: ie, reserve: te } = W, he = W.indeterminateField || W.halfField;
        if (ie) {
          const xe = (Me) => {
            f && he && r.set(Me, he, !1), r.set(Me, ie, !1);
          };
          f ? r.eachTree(y, xe, { children: k }) : y.forEach(xe);
        }
        return te && y.forEach((xe) => mo(xe, !1)), u.isAllSelected = !1, u.isIndeterminate = !1, u.selectCheckboxMaps = {}, u.treeIndeterminateMaps = {}, me();
      },
      /**
       * 用于当前行，设置某一行为高亮状态
       * @param {Row} row 行对象
       */
      setCurrentRow(f) {
        const y = _e.value, T = v.value;
        return p.clearCurrentRow(), u.currentRow = f, (y.isCurrent || e.highlightCurrentRow) && T && r.arrayEach(T.querySelectorAll(`[rowid="${yt(U, f)}"]`), (k) => Ms(k, "row--current")), me();
      },
      isCheckedByRadioRow(f) {
        return U.eqRow(u.selectRadioRow, f);
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param {Row} row 行对象
       */
      setRadioRow(f) {
        return ae(f, !0);
      },
      /**
       * 用于当前行，手动清空当前高亮的状态
       */
      clearCurrentRow() {
        const f = v.value;
        return u.currentRow = null, d.hoverRow = null, f && r.arrayEach(f.querySelectorAll(".row--current"), (y) => jo(y, "row--current")), me();
      },
      /**
       * 用于单选行，手动清空用户的选择
       */
      clearRadioRow() {
        return u.selectRadioRow = null, me();
      },
      /**
       * 用于当前行，获取当前行的数据
       */
      getCurrentRecord() {
        return _e.value.isCurrent || e.highlightCurrentRow ? u.currentRow : null;
      },
      /**
       * 用于单选行，获取当已选中的数据
       */
      getRadioRecord(f) {
        const { fullDataRowIdData: y, afterFullRowMaps: T } = d, { selectRadioRow: k } = u;
        if (k) {
          const W = yt(U, k);
          if (f) {
            if (y[W])
              return k;
          } else if (T[W])
            return k;
        }
        return null;
      },
      getCurrentColumn() {
        return Ue.value.isCurrent || e.highlightCurrentColumn ? u.currentColumn : null;
      },
      /**
       * 用于当前列，设置某列行为高亮状态
       */
      setCurrentColumn(f) {
        const y = io(U, f);
        return y && (p.clearCurrentColumn(), u.currentColumn = y), me();
      },
      /**
       * 用于当前列，手动清空当前高亮的状态
       */
      clearCurrentColumn() {
        return u.currentColumn = null, me();
      },
      setPendingRow(f, y) {
        const T = Object.assign({}, u.pendingRowMaps), k = [...u.pendingRowList];
        return f && !r.isArray(f) && (f = [f]), y ? f.forEach((W) => {
          const ie = yt(U, W);
          ie && !T[ie] && (k.push(W), T[ie] = W);
        }) : f.forEach((W) => {
          const ie = yt(U, W);
          if (ie && T[ie]) {
            const te = U.findRowIndexOf(k, W);
            te > -1 && k.splice(te, 1), delete T[ie];
          }
        }), u.pendingRowMaps = T, u.pendingRowList = k, me();
      },
      togglePendingRow(f) {
        const y = Object.assign({}, u.pendingRowMaps), T = [...u.pendingRowList];
        return f && !r.isArray(f) && (f = [f]), f.forEach((k) => {
          const W = yt(U, k);
          if (W)
            if (y[W]) {
              const ie = U.findRowIndexOf(T, k);
              ie > -1 && T.splice(ie, 1), delete y[W];
            } else
              T.push(k), y[W] = k;
        }), u.pendingRowMaps = y, u.pendingRowList = T, me();
      },
      hasPendingByRow(f) {
        return p.isPendingByRow(f);
      },
      isPendingByRow(f) {
        const { pendingRowMaps: y } = u, T = yt(U, f);
        return !!y[T];
      },
      getPendingRecords() {
        const { pendingRowList: f } = u;
        return f.slice(0);
      },
      clearPendingRow() {
        return u.pendingRowMaps = {}, u.pendingRowList = [], me();
      },
      sort(f, y) {
        const T = q.value, { multiple: k, remote: W, orders: ie } = T;
        return f && r.isString(f) && (f = [
          { field: f, order: y }
        ]), r.isArray(f) || (f = [f]), f.length ? (k || ho(), (k ? f : [f[0]]).forEach((te, he) => {
          let { field: xe, order: Me } = te, $e = xe;
          r.isString(xe) && ($e = p.getColumnByField(xe)), $e && $e.sortable && (ie.indexOf(Me) === -1 && (Me = on($e)), $e.order !== Me && ($e.order = Me), $e.sortTime = Date.now() + he);
        }), W || w.handleTableData(!0), me().then(() => (p.updateCellAreas(), Kn()))) : me();
      },
      /**
       * 清空指定列的排序条件
       * 如果为空则清空所有列的排序条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearSort(f) {
        const y = q.value;
        if (f) {
          const T = io(U, f);
          T && (T.order = null);
        } else
          ho();
        return y.remote || w.handleTableData(!0), me().then(Kn);
      },
      isSort(f) {
        if (f) {
          const y = io(U, f);
          return y ? y.sortable && !!y.order : !1;
        }
        return p.getSortColumns().length > 0;
      },
      getSortColumns() {
        const f = q.value, { multiple: y, chronological: T } = f, k = [], { tableFullColumn: W } = d;
        return W.forEach((ie) => {
          const { field: te, order: he } = ie;
          ie.sortable && he && k.push({ column: ie, field: te, property: te, order: he, sortTime: ie.sortTime });
        }), y && T && k.length > 1 ? r.orderBy(k, "sortTime") : k;
      },
      /**
       * 关闭筛选
       * @param {Event} evnt 事件
       */
      closeFilter() {
        const { filterStore: f } = u, { column: y, visible: T } = f;
        return Object.assign(f, {
          isAllSelected: !1,
          isIndeterminate: !1,
          options: [],
          visible: !1
        }), T && bt("filter-visible", { column: y, property: y.field, field: y.field, filterList: U.getCheckedFilters(), visible: !1 }, null), me();
      },
      /**
       * 判断指定列是否为筛选状态，如果为空则判断所有列
       * @param {String} fieldOrColumn 字段名
       */
      isActiveFilterByColumn(f) {
        const y = io(U, f);
        return y ? y.filters && y.filters.some((T) => T.checked) : U.getCheckedFilters().length > 0;
      },
      isFilter(f) {
        return p.isActiveFilterByColumn(f);
      },
      /**
       * 判断展开行是否懒加载完成
       * @param {Row} row 行对象
       */
      isRowExpandLoaded(f) {
        const { fullAllDataRowIdData: y } = d, T = y[yt(U, f)];
        return T && !!T.expandLoaded;
      },
      clearRowExpandLoaded(f) {
        const { rowExpandLazyLoadedMaps: y } = u, { fullAllDataRowIdData: T } = d, k = St.value, { lazy: W } = k, ie = yt(U, f), te = T[ie];
        return W && te && (te.expandLoaded = !1, delete y[ie]), me();
      },
      /**
       * 重新懒加载展开行，并展开内容
       * @param {Row} row 行对象
       */
      reloadRowExpand(f) {
        const { rowExpandLazyLoadedMaps: y } = u, T = St.value, { lazy: k } = T, W = yt(U, f);
        return k && !y[W] && p.clearRowExpandLoaded(f).then(() => qt(f)), me();
      },
      reloadExpandContent(f) {
        return process.env.NODE_ENV === "development" && rn("vxe.error.delFunc", ["reloadExpandContent", "reloadRowExpand"]), p.reloadRowExpand(f);
      },
      /**
       * 切换展开行
       */
      toggleRowExpand(f) {
        return p.setRowExpand(f, !p.isRowExpandByRow(f));
      },
      /**
       * 设置所有行的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllRowExpand(f) {
        const y = Dt.value, { tableFullData: T, tableFullTreeData: k } = d, W = y.children || y.childrenField;
        let ie = [];
        return e.treeConfig ? r.eachTree(k, (te) => {
          ie.push(te);
        }, { children: W }) : ie = T, p.setRowExpand(ie, f);
      },
      /**
       * 设置展开行，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setRowExpand(f, y) {
        const { rowExpandedMaps: T, rowExpandLazyLoadedMaps: k, expandColumn: W } = u, { fullAllDataRowIdData: ie } = d;
        let te = Object.assign({}, T);
        const he = St.value, { reserve: xe, lazy: Me, accordion: $e, toggleMethod: Ge } = he, Fe = [], He = p.getColumnIndex(W), et = p.getVMColumnIndex(W);
        if (f) {
          r.isArray(f) || (f = [f]), $e && (te = {}, f = f.slice(f.length - 1, f.length));
          const Xe = Ge ? f.filter((nt) => Ge({ $table: U, expanded: y, column: W, columnIndex: He, $columnIndex: et, row: nt, rowIndex: p.getRowIndex(nt), $rowIndex: p.getVMRowIndex(nt) })) : f;
          y ? Xe.forEach((nt) => {
            const Ct = yt(U, nt);
            if (!te[Ct]) {
              const ot = ie[Ct];
              Me && !ot.expandLoaded && !k[Ct] ? Fe.push(qt(nt)) : te[Ct] = nt;
            }
          }) : Xe.forEach((nt) => {
            const Ct = yt(U, nt);
            te[Ct] && delete te[Ct];
          }), xe && Xe.forEach((nt) => tt(nt, y));
        }
        return u.rowExpandedMaps = te, Promise.all(Fe).then(() => p.recalculate());
      },
      /**
       * 判断行是否为展开状态
       * @param {Row} row 行对象
       */
      isRowExpandByRow(f) {
        const { rowExpandedMaps: y } = u, T = yt(U, f);
        return !!y[T];
      },
      isExpandByRow(f) {
        return process.env.NODE_ENV === "development" && rn("vxe.error.delFunc", ["isExpandByRow", "isRowExpandByRow"]), p.isRowExpandByRow(f);
      },
      /**
       * 手动清空展开行状态，数据会恢复成未展开的状态
       */
      clearRowExpand() {
        const { tableFullData: f } = d, y = St.value, { reserve: T } = y, k = p.getRowExpandRecords();
        return u.rowExpandedMaps = {}, T && f.forEach((W) => tt(W, !1)), me().then(() => {
          k.length && p.recalculate();
        });
      },
      clearRowExpandReserve() {
        return d.rowExpandedReserveRowMap = {}, me();
      },
      getRowExpandRecords() {
        const f = [];
        return r.each(u.rowExpandedMaps, (y) => {
          y && f.push(y);
        }), f;
      },
      getTreeExpandRecords() {
        const f = [];
        return r.each(u.treeExpandedMaps, (y) => {
          y && f.push(y);
        }), f;
      },
      /**
       * 判断树节点是否懒加载完成
       * @param {Row} row 行对象
       */
      isTreeExpandLoaded(f) {
        const { fullAllDataRowIdData: y } = d, T = y[yt(U, f)];
        return T && !!T.treeLoaded;
      },
      clearTreeExpandLoaded(f) {
        const { treeExpandedMaps: y } = u, { fullAllDataRowIdData: T } = d, k = Dt.value, { transform: W, lazy: ie } = k, te = yt(U, f), he = T[te];
        return ie && he && (he.treeLoaded = !1, y[te] && delete y[te]), W ? (_o(), w.handleTableData()) : me();
      },
      /**
       * 重新懒加载树节点，并展开该节点
       * @param {Row} row 行对象
       */
      reloadTreeExpand(f) {
        const { treeExpandLazyLoadedMaps: y } = u, T = Dt.value, k = T.hasChild || T.hasChildField, { transform: W, lazy: ie } = T, te = yt(U, f);
        return ie && f[k] && !y[te] ? p.clearTreeExpandLoaded(f).then(() => Mt(f)).then(() => {
          if (W)
            return _o(), w.handleTableData();
        }).then(() => p.recalculate()) : me();
      },
      reloadTreeChilds(f) {
        return process.env.NODE_ENV === "development" && rn("vxe.error.delFunc", ["reloadTreeChilds", "reloadTreeExpand"]), p.reloadTreeExpand(f);
      },
      /**
       * 切换/展开树节点
       */
      toggleTreeExpand(f) {
        return p.setTreeExpand(f, !p.isTreeExpandByRow(f));
      },
      /**
       * 设置所有树节点的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllTreeExpand(f) {
        const { tableFullData: y } = d, T = Dt.value, { transform: k, lazy: W } = T, ie = T.children || T.childrenField, te = [];
        return r.eachTree(y, (he) => {
          const xe = he[ie];
          (W || xe && xe.length) && te.push(he);
        }, { children: ie }), p.setTreeExpand(te, f).then(() => {
          if (k)
            return _o(), p.recalculate();
        });
      },
      /**
       * 设置展开树形节点，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setTreeExpand(f, y) {
        const T = Dt.value, { transform: k } = T;
        return f && (r.isArray(f) || (f = [f]), f.length) ? k ? Zc(f, y) : la(f, y) : me();
      },
      /**
       * 判断行是否为树形节点展开状态
       * @param {Row} row 行对象
       */
      isTreeExpandByRow(f) {
        const { treeExpandedMaps: y } = u;
        return !!y[yt(U, f)];
      },
      /**
       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
       */
      clearTreeExpand() {
        const { tableFullTreeData: f } = d, y = Dt.value, T = y.children || y.childrenField, { transform: k, reserve: W } = y, ie = p.getTreeExpandRecords();
        return u.treeExpandedMaps = {}, W && r.eachTree(f, (te) => jt(te, !1), { children: T }), w.handleTableData().then(() => {
          if (k)
            return _o(), w.handleTableData();
        }).then(() => {
          if (ie.length)
            return p.recalculate();
        });
      },
      clearTreeExpandReserve() {
        return d.treeExpandedReserveRowMap = {}, me();
      },
      /**
       * 获取表格的滚动状态
       */
      getScroll() {
        const { scrollXLoad: f, scrollYLoad: y } = u, k = E.value.$el;
        return {
          virtualX: f,
          virtualY: y,
          scrollTop: k.scrollTop,
          scrollLeft: k.scrollLeft
        };
      },
      /**
       * 如果有滚动条，则滚动到对应的位置
       * @param {Number} scrollLeft 左距离
       * @param {Number} scrollTop 上距离
       */
      scrollTo(f, y) {
        const T = E.value, k = b.value, W = C.value, ie = Q.value, te = ue.value, he = T ? T.$el : null, xe = ie ? ie.$el : null, Me = te ? te.$el : null, $e = k ? k.$el : null, Ge = W ? W.$el : null;
        if (r.isNumber(f)) {
          const Fe = A.value;
          Fe ? fo(Fe, f) : (fo(he, f), fo($e, f), fo(Ge, f));
        }
        if (r.isNumber(y)) {
          const Fe = j.value;
          Fe ? no(Fe, y) : (no(he, y), no(xe, y), no(Me, y));
        }
        return u.scrollXLoad || u.scrollYLoad ? new Promise((Fe) => {
          setTimeout(() => {
            me(() => {
              Fe();
            });
          }, 30);
        }) : me();
      },
      /**
       * 如果有滚动条，则滚动到对应的行
       * @param {Row} row 行对象
       * @param {ColumnInfo} fieldOrColumn 列配置
       */
      scrollToRow(f, y) {
        const T = [];
        return f && (e.treeConfig ? T.push(w.scrollToTreeRow(f)) : T.push(wp(U, f))), y && T.push(It(y, f)), Promise.all(T);
      },
      /**
       * 如果有滚动条，则滚动到对应的列
       */
      scrollToColumn(f) {
        const { fullColumnIdData: y } = d, T = io(U, f);
        return T && y[T.id] ? Ep(U, T) : me();
      },
      /**
       * 手动清除滚动相关信息，还原到初始状态
       */
      clearScroll() {
        const { scrollXStore: f, scrollYStore: y } = d, T = E.value, k = b.value, W = C.value, ie = Q.value, te = ue.value, he = ie ? ie.$el : null, xe = T ? T.$el : null, Me = te ? te.$el : null, $e = k ? k.$el : null, Ge = W ? W.$el : null, Fe = A.value;
        Fe ? fo(Fe, 0) : (fo(xe, 0), fo($e, 0), fo(Ge, 0));
        const He = j.value;
        return He ? no(He, 0) : (no(xe, 0), no(he, 0), no(Me, 0)), f.startIndex = 0, f.endIndex = f.visibleSize, y.startIndex = 0, y.endIndex = y.visibleSize, me().then(() => {
          fo(xe, 0), fo($e, 0), fo(Ge, 0), no(xe, 0), no(he, 0), no(Me, 0);
        });
      },
      /**
       * 更新表尾合计
       */
      updateFooter() {
        const { showFooter: f, footerData: y, footerMethod: T } = e, { visibleColumn: k, afterFullData: W } = d;
        let ie = [];
        return f && y && y.length ? ie = y.slice(0) : f && T && (ie = k.length ? T({ columns: k, data: W, $table: U, $grid: ne }) : []), u.footerTableData = ie, me();
      },
      /**
       * 更新列状态 updateStatus({ row, column }, cellValue)
       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
       * 如果单元格配置了校验规则，则会进行校验
       */
      updateStatus(f, y) {
        const T = !r.isUndefined(y);
        return me().then(() => {
          const { editRules: k } = e, { validStore: W } = u, ie = E.value;
          if (f && ie && k) {
            const { row: te, column: he } = f, xe = "change";
            if (U.hasCellRules && U.hasCellRules(xe, te, he)) {
              const Me = p.getCellElement(te, he);
              if (Me)
                return U.validCellRules(xe, te, he, y).then(() => {
                  T && W.visible && js(te, he, y), U.clearValidate(te, he);
                }).catch(({ rule: $e }) => {
                  T && js(te, he, y), U.showValidTooltip({ rule: $e, row: te, column: he, cell: Me });
                });
            }
          }
        });
      },
      /**
       * 设置合并单元格
       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
       */
      setMergeCells(f) {
        return e.spanMethod && Ut("vxe.error.errConflicts", ["merge-cells", "span-method"]), Uo(f, u.mergeList, d.afterFullData), me().then(() => (p.updateCellAreas(), Kn()));
      },
      /**
       * 移除单元格合并
       * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(f) {
        e.spanMethod && Ut("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        const y = Qn(f, u.mergeList, d.afterFullData);
        return me().then(() => (p.updateCellAreas(), Kn(), y));
      },
      /**
       * 获取所有被合并的单元格
       */
      getMergeCells() {
        return u.mergeList.slice(0);
      },
      /**
       * 清除所有单元格合并
       */
      clearMergeCells() {
        return u.mergeList = [], me().then(() => Kn());
      },
      setMergeFooterItems(f) {
        return e.footerSpanMethod && Ut("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]), Uo(f, u.mergeFooterList), me().then(() => (p.updateCellAreas(), Kn()));
      },
      removeMergeFooterItems(f) {
        e.footerSpanMethod && Ut("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        const y = Qn(f, u.mergeFooterList);
        return me().then(() => (p.updateCellAreas(), Kn(), y));
      },
      /**
       * 获取所有被合并的表尾
       */
      getMergeFooterItems() {
        return u.mergeFooterList.slice(0);
      },
      /**
       * 清除所有表尾合并
       */
      clearMergeFooterItems() {
        return u.mergeFooterList = [], me().then(() => Kn());
      },
      updateCellAreas() {
        const { mouseConfig: f } = e, y = R.value;
        return f && y.area && U.handleRecalculateCellAreas ? U.handleRecalculateCellAreas() : me();
      },
      getCustomStoreData() {
        const { id: f } = e, y = At.value, { collectColumn: T } = d, { checkMethod: k } = y, W = {}, ie = {}, te = {}, he = {}, xe = {
          resizableData: void 0,
          sortData: void 0,
          visibleData: void 0,
          fixedData: void 0
        };
        if (!f)
          return Ut("vxe.error.reqProp", ["id"]), xe;
        let Me = 0, $e = 0, Ge = 0, Fe = 0;
        return r.eachTree(T, (He, et, Xe, nt, Ct) => {
          if (!Ct && (T.forEach((ot) => {
            const Tt = ot.getKey();
            Tt && ($e = 1, ie[Tt] = ot.renderSortNumber);
          }), He.fixed && He.fixed !== He.defaultFixed)) {
            const ot = He.getKey();
            ot && (Ge = 1, he[ot] = He.fixed);
          }
          if (He.resizeWidth) {
            const ot = He.getKey();
            ot && (Me = 1, W[ot] = He.renderWidth);
          }
          if (!k || k({ column: He })) {
            if (!He.visible && He.defaultVisible) {
              const ot = He.getKey();
              ot && (Fe = 1, te[ot] = !1);
            } else if (He.visible && !He.defaultVisible) {
              const ot = He.getKey();
              ot && (Fe = 1, te[ot] = !0);
            }
          }
        }), Me && (xe.resizableData = W), $e && (xe.sortData = ie), Ge && (xe.fixedData = he), Fe && (xe.visibleData = te), xe;
      },
      focus() {
        return d.isActivated = !0, me();
      },
      blur() {
        return d.isActivated = !1, me();
      },
      /**
       * 连接工具栏
       * @param $toolbar
       */
      connect(f) {
        return f ? ($ = f, $.syncUpdate({ collectColumn: d.collectColumn, $table: U })) : Ut("vxe.error.barUnableLink"), me();
      }
    };
    const Kt = (f) => {
      const { editStore: y, ctxMenuStore: T, filterStore: k, customStore: W } = u, { mouseConfig: ie, editRules: te } = e, he = v.value, xe = Ne.value, Me = ge.value, $e = le.value, { actived: Ge } = y, Fe = x.value, He = O.value, et = g.value, Xe = h.value;
      if (He && (kn(f, he, "vxe-cell--filter").flag || kn(f, He.$el).flag || kn(f, document.body, "vxe-table--ignore-clear").flag || w.preventEvent(f, "event.clearFilter", k.args, p.closeFilter)), et && (W.btnEl === f.target || kn(f, document.body, "vxe-toolbar-custom-target").flag || kn(f, et.$el).flag || kn(f, document.body, "vxe-table--ignore-clear").flag || w.preventEvent(f, "event.clearCustom", {}, () => {
        U.closeCustom && U.closeCustom();
      })), Ge.row) {
        if (xe.autoClear !== !1) {
          const Ct = Ge.args.cell;
          (!Ct || !kn(f, Ct).flag) && (Fe && kn(f, Fe.$el).flag || (!d._lastCallTime || d._lastCallTime + 50 < Date.now()) && (kn(f, document.body, "vxe-table--ignore-clear").flag || w.preventEvent(f, "event.clearEdit", Ge.args, () => {
            let ot;
            if (xe.mode === "row") {
              const Tt = kn(f, he, "vxe-body--row"), Xt = Tt.flag ? p.getRowNode(Tt.targetElem) : null;
              ot = Xt ? !U.eqRow(Xt.item, Ge.args.row) : !1;
            } else
              ot = !kn(f, he, "col--edit").flag;
            if (ot || (ot = kn(f, he, "vxe-header--row").flag), ot || (ot = kn(f, he, "vxe-footer--row").flag), !ot && e.height && !u.overflowY) {
              const Tt = f.target;
              sl(Tt, "vxe-table--body-wrapper") && (ot = f.offsetY < Tt.clientHeight);
            }
            (ot || // 如果点击了当前表格之外
            !kn(f, he).flag) && setTimeout(() => {
              U.handleClearEdit(f).then(() => {
                !d.isActivated && te && Me.autoClear && (u.validErrorMaps = {});
              });
            });
          })));
        }
      } else if (ie && !kn(f, he).flag && !(ne && kn(f, ne.getRefMaps().refElem.value).flag) && !(Xe && kn(f, Xe.getRefMaps().refElem.value).flag) && !($ && kn(f, $.getRefMaps().refElem.value).flag) && (U.clearSelected && U.clearSelected(), $e.autoClear && U.getCellAreas)) {
        const Ct = U.getCellAreas();
        Ct && Ct.length && !kn(f, document.body, "vxe-table--ignore-areas-clear").flag && w.preventEvent(f, "event.clearAreas", {}, () => {
          U.clearCellAreas(), U.clearCopyCellArea(), bt("clear-cell-area-selection", { cellAreas: Ct }, f);
        });
      }
      U.closeMenu && T.visible && Xe && !kn(f, Xe.getRefMaps().refElem.value).flag && U.closeMenu();
      const nt = kn(f, ne ? ne.getRefMaps().refElem.value : he).flag;
      !nt && te && Me.autoClear && (u.validErrorMaps = {}), d.isActivated = nt;
    }, Ft = () => {
      p.closeFilter(), U.closeMenu && U.closeMenu();
    }, Je = () => {
      p.closeTooltip(), U.closeMenu && U.closeMenu();
    }, Vt = (f) => {
      const { mouseConfig: y, keyboardConfig: T } = e, { filterStore: k, ctxMenuStore: W, editStore: ie } = u, te = R.value, he = F.value, { actived: xe } = ie;
      An.hasKey(f, ls.ESCAPE) && w.preventEvent(f, "event.keydown", null, () => {
        if (bt("keydown-start", {}, f), T && y && te.area && U.handleKeyboardCellAreaEvent)
          U.handleKeyboardCellAreaEvent(f);
        else if ((xe.row || k.visible || W.visible) && (f.stopPropagation(), U.closeMenu && U.closeMenu(), p.closeFilter(), T && he.isEsc && xe.row)) {
          const $e = xe.args;
          U.handleClearEdit(f), te.selected && me(() => U.handleSelected($e, f));
        }
        bt("keydown", {}, f), bt("keydown-end", {}, f);
      });
    }, un = (f) => {
      d.isActivated && w.preventEvent(f, "event.keydown", null, () => {
        const { mouseConfig: y, keyboardConfig: T, treeConfig: k, editConfig: W, highlightCurrentRow: ie } = e, { ctxMenuStore: te, editStore: he, currentRow: xe } = u, { afterFullData: Me } = d, $e = ze.value, Ge = we.value, Fe = F.value, He = R.value, et = Ne.value, Xe = Dt.value, nt = st.value, Ct = _e.value, { selected: ot, actived: Tt } = he, Xt = Xe.children || Xe.childrenField, Pt = f.keyCode, tn = An.hasKey(f, ls.ESCAPE), pn = An.hasKey(f, ls.BACKSPACE), zn = An.hasKey(f, ls.TAB), On = An.hasKey(f, ls.ENTER), xn = An.hasKey(f, ls.SPACEBAR), _n = An.hasKey(f, ls.ARROW_LEFT), ln = An.hasKey(f, ls.ARROW_UP), an = An.hasKey(f, ls.ARROW_RIGHT), Hn = An.hasKey(f, ls.ARROW_DOWN), Yo = An.hasKey(f, ls.DELETE), Ss = An.hasKey(f, ls.F2), wr = An.hasKey(f, ls.CONTEXT_MENU), Er = f.metaKey, Ds = f.ctrlKey, Qs = f.shiftKey, jr = f.altKey, qr = _n || ln || an || Hn, er = $e && te.visible && (On || xn || qr), so = fn(W) && Tt.column && Tt.row, Xo = et.beforeEditMethod || et.activeMethod;
        if (er)
          f.preventDefault(), te.showChild && Tl(te.selected) ? U.moveCtxMenu(f, te, "selectChild", _n, !1, te.selected.children) : U.moveCtxMenu(f, te, "selected", an, !0, nt);
        else if (T && y && He.area && U.handleKeyboardCellAreaEvent)
          U.handleKeyboardCellAreaEvent(f);
        else if (tn) {
          if (U.closeMenu && U.closeMenu(), p.closeFilter(), T && Fe.isEsc && Tt.row) {
            const Pn = Tt.args;
            U.handleClearEdit(f), He.selected && me(() => U.handleSelected(Pn, f));
          }
        } else if (xn && T && Fe.isChecked && ot.row && ot.column && (ot.column.type === "checkbox" || ot.column.type === "radio"))
          f.preventDefault(), ot.column.type === "checkbox" ? w.handleToggleCheckRowEvent(f, ot.args) : w.triggerRadioRowEvent(f, ot.args);
        else if (Ss && fn(W))
          so || ot.row && ot.column && (f.preventDefault(), U.handleEdit(ot.args, f));
        else if (wr)
          d._keyCtx = ot.row && ot.column && Ge.length, clearTimeout(gt), gt = setTimeout(() => {
            d._keyCtx = !1;
          }, 1e3);
        else if (On && !jr && T && Fe.isEnter && (ot.row || Tt.row || k && (Ct.isCurrent || ie) && xe)) {
          const { isLastEnterAppendRow: Pn, beforeEnterMethod: uo, enterMethod: No } = Fe;
          if (Ds) {
            if (Tt.row) {
              const ro = Tt.args;
              U.handleClearEdit(f), He.selected && me(() => {
                U.handleSelected(ro, f);
              });
            }
          } else if (ot.row || Tt.row) {
            const ro = ot.row ? ot.args : Tt.args;
            if (Qs)
              Fe.enterToTab ? U.moveTabSelected(ro, Qs, f) : U.moveSelected(ro, _n, !0, an, !1, f);
            else if (Fe.enterToTab)
              U.moveTabSelected(ro, Qs, f);
            else {
              const Mo = ot.row || Tt.row, to = ot.column || Tt.column, ss = U.getVTRowIndex(Mo), Os = {
                row: Mo,
                rowIndex: U.getRowIndex(Mo),
                $rowIndex: U.getVMRowIndex(Mo),
                _rowIndex: ss,
                column: to,
                columnIndex: U.getColumnIndex(to),
                $columnIndex: U.getVMColumnIndex(to),
                _columnIndex: U.getVTColumnIndex(to),
                $table: U
              };
              if (!uo || uo(Os) !== !1) {
                if (Pn && ss >= Me.length - 1) {
                  U.insertAt({}, -1).then(({ row: si }) => {
                    U.scrollToRow(si, to), U.handleSelected(Object.assign(Object.assign({}, ro), { row: si }), f);
                  }), U.dispatchEvent("enter-append-row", Os, f);
                  return;
                }
                U.moveSelected(ro, _n, !1, an, !0, f), No && No(Os);
              }
            }
          } else if (k && (Ct.isCurrent || ie) && xe) {
            const ro = xe[Xt];
            if (ro && ro.length) {
              f.preventDefault();
              const Mo = ro[0], to = {
                $table: U,
                row: Mo,
                rowIndex: p.getRowIndex(Mo),
                $rowIndex: p.getVMRowIndex(Mo)
              };
              p.setTreeExpand(xe, !0).then(() => p.scrollToRow(Mo)).then(() => w.triggerCurrentRowEvent(f, to));
            }
          }
        } else if (qr && T && Fe.isArrow)
          so || (ot.row && ot.column ? U.moveSelected(ot.args, _n, ln, an, Hn, f) : (ln || Hn) && (Ct.isCurrent || ie) && U.moveCurrentRow(ln, Hn, f));
        else if (zn && T && Fe.isTab)
          ot.row || ot.column ? U.moveTabSelected(ot.args, Qs, f) : (Tt.row || Tt.column) && U.moveTabSelected(Tt.args, Qs, f);
        else if (T && Fe.isDel && Yo && fn(W) && (ot.row || ot.column)) {
          if (!so) {
            const { delMethod: Pn } = Fe, uo = {
              row: ot.row,
              rowIndex: p.getRowIndex(ot.row),
              column: ot.column,
              columnIndex: p.getColumnIndex(ot.column),
              $table: U,
              $grid: ne
            };
            (!Xo || Xo(uo)) && (Pn ? Pn(uo) : js(ot.row, ot.column, null), p.updateFooter(), bt("cell-delete-value", uo, f));
          }
        } else if (pn && T && Fe.isBack && fn(W) && (ot.row || ot.column)) {
          if (!so) {
            const { backMethod: Pn } = Fe;
            if (Fe.isDel && fn(W) && (ot.row || ot.column)) {
              const uo = {
                row: ot.row,
                rowIndex: p.getRowIndex(ot.row),
                column: ot.column,
                columnIndex: p.getColumnIndex(ot.column),
                $table: U,
                $grid: ne
              };
              (!Xo || Xo(uo)) && (Pn ? Pn(uo) : (js(ot.row, ot.column, null), U.handleEdit(ot.args, f)), bt("cell-backspace-value", uo, f));
            }
          }
        } else if (pn && T && k && Fe.isBack && (Ct.isCurrent || ie) && xe) {
          const { parent: Pn } = r.findTree(d.afterTreeFullData, (uo) => uo === xe, { children: Xt });
          if (Pn) {
            f.preventDefault();
            const uo = {
              row: Pn,
              rowIndex: p.getRowIndex(Pn),
              $rowIndex: p.getVMRowIndex(Pn),
              $table: U,
              $grid: ne
            };
            p.setTreeExpand(Pn, !1).then(() => p.scrollToRow(Pn)).then(() => w.triggerCurrentRowEvent(f, uo));
          }
        } else if (T && fn(W) && Fe.isEdit && !Ds && !Er && (xn || Pt >= 48 && Pt <= 57 || Pt >= 65 && Pt <= 90 || Pt >= 96 && Pt <= 111 || Pt >= 186 && Pt <= 192 || Pt >= 219 && Pt <= 222)) {
          const { editMode: Pn, editMethod: uo } = Fe;
          if (ot.column && ot.row && fn(ot.column.editRender)) {
            const No = et.beforeEditMethod || et.activeMethod, ro = {
              row: ot.row,
              rowIndex: p.getRowIndex(ot.row),
              column: ot.column,
              columnIndex: p.getColumnIndex(ot.column),
              $table: U,
              $grid: ne
            };
            (!No || No(Object.assign(Object.assign({}, ot.args), { $table: U, $grid: ne }))) && (uo ? uo(ro) : (Pn !== "insert" && js(ot.row, ot.column, null), U.handleEdit(ot.args, f)));
          }
        }
        bt("keydown", {}, f);
      });
    }, vn = (f) => {
      const { keyboardConfig: y, mouseConfig: T } = e, { editStore: k, filterStore: W } = u, { isActivated: ie } = d, te = R.value, he = F.value, { actived: xe } = k;
      ie && !W.visible && (xe.row || xe.column || y && he.isClip && T && te.area && U.handlePasteCellAreaEvent && U.handlePasteCellAreaEvent(f), bt("paste", {}, f));
    }, qn = (f) => {
      const { keyboardConfig: y, mouseConfig: T } = e, { editStore: k, filterStore: W } = u, { isActivated: ie } = d, te = R.value, he = F.value, { actived: xe } = k;
      ie && !W.visible && (xe.row || xe.column || y && he.isClip && T && te.area && U.handleCopyCellAreaEvent && U.handleCopyCellAreaEvent(f), bt("copy", {}, f));
    }, Ro = (f) => {
      const { keyboardConfig: y, mouseConfig: T } = e, { editStore: k, filterStore: W } = u, { isActivated: ie } = d, te = R.value, he = F.value, { actived: xe } = k;
      ie && !W.visible && (xe.row || xe.column || y && he.isClip && T && te.area && U.handleCutCellAreaEvent && U.handleCutCellAreaEvent(f), bt("cut", {}, f));
    }, Ko = () => {
      U.closeMenu && U.closeMenu();
      const f = v.value;
      if (!f || !f.clientWidth)
        return me();
      p.recalculate(!0), p.updateCellAreas();
    }, wo = (f) => {
      const y = D.value;
      clearTimeout(d.tooltipTimeout), f ? p.closeTooltip() : y && y.setActived && y.setActived(!0);
    }, eo = () => {
      const f = v.value;
      if (f) {
        const y = "row--drag-origin";
        r.arrayEach(f.querySelectorAll(`.${y}`), (T) => {
          T.draggable = !1, jo(T, y);
        });
      }
    }, os = (f) => {
      const y = v.value;
      if (y) {
        const T = "row--drag-origin", k = yt(U, f);
        r.arrayEach(y.querySelectorAll(`[rowid="${k}"]`), (W) => {
          Ms(W, T);
        });
      }
    }, Cr = (f) => {
      const { dragConfig: y } = e, { dragRow: T } = u, k = it.value, { tooltipMethod: W } = k, ie = W || (y ? y.rowTooltipMethod : null);
      let te = "";
      ie ? te = `${ie({
        row: T
      }) || ""}` : te = bl("vxe.table.dragTip", [f.textContent || ""]), u.dragTipText = te;
    }, Qc = (f) => {
      const y = v.value;
      if (y) {
        const T = [];
        r.eachTree([f], (W) => {
          T.push(`[colid="${W.id}"]`);
        });
        const k = "col--drag-origin";
        r.arrayEach(y.querySelectorAll(T.join(",")), (W) => {
          Ms(W, k);
        });
      }
    }, ti = () => {
      const f = v.value;
      if (f) {
        const y = "col--drag-origin";
        r.arrayEach(f.querySelectorAll(`.${y}`), (T) => {
          T.draggable = !1, jo(T, y);
        });
      }
    }, eu = (f) => {
      const { dragCol: y } = u, T = vt.value, { tooltipMethod: k } = T;
      let W = "";
      k ? W = `${k({
        column: y
      }) || ""}` : W = bl("vxe.table.dragTip", [f.textContent || ""]), u.dragTipText = W;
    }, Hr = (f, y, T, k, W) => {
      const ie = v.value;
      if (!ie)
        return;
      const { scrollbarWidth: te, scrollbarHeight: he } = u, xe = ie.getBoundingClientRect();
      if (y) {
        const $e = I.value;
        if ($e)
          if (k) {
            const Ge = y.getBoundingClientRect();
            $e.style.display = "block", $e.style.top = `${Math.max(1, Ge.y - xe.y)}px`, $e.style.height = `${Ge.height}px`, $e.style.width = `${xe.width - te}px`, $e.setAttribute("drag-pos", W);
          } else
            $e.style.display = "";
      } else if (T) {
        const $e = B.value;
        if ($e)
          if (k) {
            const Ge = T.getBoundingClientRect();
            $e.style.display = "block", $e.style.left = `${Math.max(1, Ge.x - xe.x)}px`, $e.style.width = `${Ge.width}px`, $e.style.height = `${xe.height - he}px`, $e.setAttribute("drag-pos", W);
          } else
            $e.style.display = "";
      }
      const Me = M.value;
      Me && (Me.style.display = "block", Me.style.top = `${Math.min(ie.clientHeight - ie.scrollTop - Me.clientHeight, f.clientY - xe.y)}px`, Me.style.left = `${Math.min(ie.clientWidth - ie.scrollLeft - Me.clientWidth - 16, f.clientX - xe.x)}px`, Me.setAttribute("drag-status", k ? "normal" : "disabled"));
    }, Js = () => {
      const f = M.value, y = I.value, T = B.value;
      f && (f.style.display = ""), y && (y.style.display = ""), T && (T.style.display = "");
    }, dl = (f, y, T, k, W) => {
      W.cell = y;
      const { tooltipStore: ie } = u, te = Re.value, { column: he, row: xe } = W, { showAll: Me, contentMethod: $e } = te, Ge = $e ? $e(W) : null, Fe = $e && !r.eqNull(Ge), He = Fe ? Ge : r.toString(he.type === "html" ? T.innerText : T.textContent).trim(), et = T.scrollWidth > T.clientWidth;
      return He && (Me || Fe || et) && (Object.assign(ie, {
        row: xe,
        column: he,
        visible: !0,
        currOpts: {}
      }), me(() => {
        const Xe = D.value;
        Xe && Xe.open && Xe.open(et ? T : k || T, po(He));
      })), me();
    }, ni = (f, y) => {
      if (f) {
        if (ne)
          return ne.callSlot(f, y);
        if (r.isFunction(f))
          return cs(f(y));
      }
      return [];
    };
    w = {
      getSetupOptions() {
        return Mn();
      },
      updateAfterDataIndex: ko,
      callSlot: ni,
      /**
       * 获取父容器元素
       */
      getParentElem() {
        const f = v.value;
        if (ne) {
          const y = ne.getRefMaps().refElem.value;
          return y ? y.parentNode : null;
        }
        return f ? f.parentNode : null;
      },
      /**
       * 获取父容器的高度
       */
      getParentHeight() {
        const { height: f } = e, y = v.value;
        if (y) {
          const T = y.parentNode, k = f === "100%" || f === "auto" ? td(T) : 0;
          return Math.floor(ne ? ne.getParentHeight() : r.toNumber(getComputedStyle(T).height) - k);
        }
        return 0;
      },
      /**
       * 获取需要排除的高度
       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
       * 如果存在表尾合计滚动条，则需要排除滚动条高度
       */
      getExcludeHeight() {
        return ne ? ne.getExcludeHeight() : 0;
      },
      /**
       * 定义行数据中的列属性，如果不存在则定义
       * @param {Row} records 行数据
       */
      defineField(f) {
        const { treeConfig: y } = e, T = St.value, k = Dt.value, W = Qe.value, ie = De.value, te = k.children || k.childrenField, he = ir(U);
        return r.isArray(f) || (f = [f]), f.map((xe) => (d.tableFullColumn.forEach(($e) => {
          const { field: Ge, editRender: Fe } = $e;
          if (Ge && !r.has(xe, Ge) && !xe[Ge]) {
            let He = null;
            if (Fe) {
              const { defaultValue: et } = Fe;
              r.isFunction(et) ? He = et({ column: $e }) : r.isUndefined(et) || (He = et);
            }
            r.set(xe, Ge, He);
          }
        }), [W.labelField, ie.checkField, ie.labelField, T.labelField].forEach(($e) => {
          $e && cr(r.get(xe, $e)) && r.set(xe, $e, null);
        }), y && k.lazy && r.isUndefined(xe[te]) && (xe[te] = null), cr(r.get(xe, he)) && r.set(xe, he, Iu()), xe));
      },
      handleTableData(f) {
        const { scrollYLoad: y } = u, { scrollYStore: T, fullDataRowIdData: k } = d;
        let W = d.afterFullData;
        f && (ts(), W = _o());
        const ie = y ? W.slice(T.startIndex, T.endIndex) : W.slice(0);
        return ie.forEach((te, he) => {
          const xe = yt(U, te), Me = k[xe];
          Me && (Me.$index = he);
        }), u.tableData = ie, me();
      },
      /**
       * 更新数据行的 Map
       * 牺牲数据组装的耗时，用来换取使用过程中的流畅
       */
      cacheRowMap(f) {
        const { treeConfig: y } = e, T = Dt.value, { fullAllDataRowIdData: k, tableFullData: W, tableFullTreeData: ie } = d, te = T.children || T.childrenField, he = T.hasChild || T.hasChildField, xe = ir(U), Me = y && T.lazy, $e = {}, Ge = {}, Fe = (He, et, Xe, nt, Ct, ot) => {
          let Tt = yt(U, He);
          const Xt = y && nt ? SN(nt) : et + 1, Pt = ot ? ot.length - 1 : 0;
          cr(Tt) && (Tt = Iu(), r.set(He, xe, Tt)), Me && He[he] && r.isUndefined(He[te]) && (He[te] = null);
          let tn = k[Tt];
          tn || (tn = { row: He, rowid: Tt, seq: Xt, index: -1, _index: -1, $index: -1, items: Xe, parent: Ct, level: Pt, height: 0 }), f && (tn.level = Pt, tn.index = y && Ct ? -1 : et, Ge[Tt] = tn), $e[Tt] = tn;
        };
        f && (d.fullDataRowIdData = Ge), d.fullAllDataRowIdData = $e, y ? r.eachTree(ie, Fe, { children: te }) : W.forEach(Fe);
      },
      cacheSourceMap(f) {
        const { treeConfig: y } = e, T = Dt.value;
        let { sourceDataRowIdData: k } = d;
        const W = r.clone(f, !0), ie = ir(U);
        k = d.sourceDataRowIdData = {};
        const te = (he) => {
          let xe = yt(U, he);
          cr(xe) && (xe = Iu(), r.set(he, ie, xe)), k[xe] = he;
        };
        if (y) {
          const he = T.children || T.childrenField;
          r.eachTree(W, te, { children: T.transform ? T.mapChildrenField : he });
        } else
          W.forEach(te);
        d.tableSourceData = W;
      },
      /**
       * 指定列宽的列进行拆分
       */
      analyColumnWidth() {
        const { tableFullColumn: f } = d, y = Ue.value, { width: T, minWidth: k } = y, W = [], ie = [], te = [], he = [], xe = [], Me = [], $e = [], Ge = [];
        f.forEach((Fe) => {
          T && !Fe.width && (Fe.width = T), k && !Fe.minWidth && (Fe.minWidth = k), Fe.visible && (Fe.resizeWidth ? W.push(Fe) : Fe.width === "auto" ? $e.push(Fe) : ed(Fe.width) ? ie.push(Fe) : Ci(Fe.width) ? xe.push(Fe) : ed(Fe.minWidth) ? te.push(Fe) : Fe.minWidth === "auto" ? he.push(Fe) : Ci(Fe.minWidth) ? Me.push(Fe) : Ge.push(Fe));
        }), Object.assign(u.columnStore, { resizeList: W, pxList: ie, pxMinList: te, autoMinList: he, scaleList: xe, scaleMinList: Me, autoList: $e, remainList: Ge });
      },
      saveCustomStore(f) {
        const { customConfig: y } = e, T = J.value, k = At.value, { updateStore: W, storage: ie } = k, te = ie === !0, he = te ? {} : Object.assign({}, ie || {}), xe = te || he.resizable, Me = te || he.visible, $e = te || he.fixed, Ge = te || he.sort;
        if ((y ? fn(k) : k.enabled) && (xe || Me || $e || Ge)) {
          if (!T)
            return Ut("vxe.error.reqProp", ["id"]), me();
          const Fe = f === "reset" ? {
            resizableData: {},
            sortData: {},
            visibleData: {},
            fixedData: {}
          } : p.getCustomStoreData();
          if (W)
            return W({
              id: T,
              type: f,
              storeData: Fe
            });
          hn(T, f === "reset" ? null : Fe);
        }
        return me();
      },
      handleCustom() {
        const { mouseConfig: f } = e;
        return f && (U.clearSelected && U.clearSelected(), U.clearCellAreas && (U.clearCellAreas(), U.clearCopyCellArea())), w.analyColumnWidth(), p.refreshColumn(!0);
      },
      handleUpdateDataQueue() {
        u.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        u.reColumnFlag++;
      },
      preventEvent(f, y, T, k, W) {
        let ie = Lp.get(y);
        !ie.length && y === "event.clearEdit" && (ie = Lp.get("event.clearActived"), process.env.NODE_ENV === "development" && ie.length && rn("vxe.error.delEvent", ["event.clearActived", "event.clearEdit"]));
        let te;
        return ie.some((he) => he(Object.assign({ $grid: ne, $table: U, $event: f }, T)) === !1) || k && (te = k()), W && W(), te;
      },
      checkSelectionStatus() {
        const { treeConfig: f } = e, { selectCheckboxMaps: y, treeIndeterminateMaps: T } = u, { afterFullData: k } = d, W = De.value, { checkField: ie, checkStrictly: te, checkMethod: he } = W, xe = W.indeterminateField || W.halfField;
        if (!te) {
          const Me = [];
          let $e = !1, Ge = !1, Fe = !1;
          ie ? ($e = k.every(he ? (He) => he({ row: He }) ? !!r.get(He, ie) : (Me.push(He), !0) : (He) => r.get(He, ie)), Ge = $e && k.length !== Me.length, f ? xe ? Fe = !Ge && k.some((He) => r.get(He, ie) || r.get(He, xe) || !!T[yt(U, He)]) : Fe = !Ge && k.some((He) => r.get(He, ie) || !!T[yt(U, He)]) : xe ? Fe = !Ge && k.some((He) => r.get(He, ie) || r.get(He, xe)) : Fe = !Ge && k.some((He) => r.get(He, ie))) : ($e = k.every(he ? (He) => he({ row: He }) ? !!y[yt(U, He)] : (Me.push(He), !0) : (He) => y[yt(U, He)]), Ge = $e && k.length !== Me.length, f ? Fe = !Ge && k.some((He) => {
            const et = yt(U, He);
            return T[et] || y[et];
          }) : Fe = !Ge && k.some((He) => y[yt(U, He)])), u.isAllSelected = Ge, u.isIndeterminate = Fe;
        }
      },
      /**
       * 多行
       * 多选，行选中事件
       * value 选中true 不选false 半选-1
       */
      handleBatchSelectRows(f, y, T) {
        const { treeConfig: k } = e, { selectCheckboxMaps: W } = u, ie = De.value, { checkField: te, checkStrictly: he, checkMethod: xe } = ie;
        if (te)
          k && !he ? f.forEach((Me) => {
            w.handleSelectRow({ row: Me }, y, T);
          }) : f.forEach((Me) => {
            (T || !xe || xe({ row: Me })) && (r.set(Me, te, y), mo(Me, y));
          });
        else if (k && !he)
          f.forEach((Me) => {
            w.handleSelectRow({ row: Me }, y, T);
          });
        else {
          const Me = Object.assign({}, W);
          f.forEach(($e) => {
            const Ge = yt(U, $e);
            (T || !xe || xe({ row: $e })) && (y ? Me[Ge] || (Me[Ge] = $e) : Me[Ge] && delete Me[Ge], mo($e, y));
          }), u.selectCheckboxMaps = Me;
        }
      },
      /**
       * 单行
       * 多选，行选中事件
       * value 选中true 不选false 半选-1
       */
      handleSelectRow({ row: f }, y, T) {
        const { treeConfig: k } = e, { selectCheckboxMaps: W, treeIndeterminateMaps: ie } = u, te = Object.assign({}, W), { afterFullData: he } = d, xe = Dt.value, Me = xe.children || xe.childrenField, $e = De.value, { checkField: Ge, checkStrictly: Fe, checkMethod: He } = $e, et = $e.indeterminateField || $e.halfField, Xe = yt(U, f);
        if (Ge)
          if (k && !Fe) {
            y === -1 ? (ie[Xe] || (et && r.set(f, et, !0), ie[Xe] = f), r.set(f, Ge, !1)) : r.eachTree([f], (Ct) => {
              (U.eqRow(Ct, f) || T || !He || He({ row: Ct })) && (r.set(Ct, Ge, y), et && r.set(f, et, !1), delete ie[yt(U, Ct)], mo(f, y));
            }, { children: Me });
            const nt = r.findTree(he, (Ct) => U.eqRow(Ct, f), { children: Me });
            if (nt && nt.parent) {
              let Ct;
              const ot = [], Tt = {};
              if (!T && He ? nt.items.forEach((Pt) => {
                if (He({ row: Pt })) {
                  const tn = yt(U, Pt);
                  Tt[tn] = Pt, ot.push(Pt);
                }
              }) : nt.items.forEach((Pt) => {
                const tn = yt(U, Pt);
                Tt[tn] = Pt, ot.push(Pt);
              }), r.find(nt.items, (Pt) => !!ie[yt(U, Pt)]))
                Ct = -1;
              else {
                const Pt = [];
                nt.items.forEach((tn) => {
                  r.get(tn, Ge) && Pt.push(tn);
                }), Ct = Pt.filter((tn) => Tt[yt(U, tn)]).length === ot.length ? !0 : Pt.length || y === -1 ? -1 : !1;
              }
              u.selectCheckboxMaps = te, w.handleSelectRow({ row: nt.parent }, Ct, T);
              return;
            }
          } else
            (T || !He || He({ row: f })) && (r.set(f, Ge, y), mo(f, y));
        else if (k && !Fe) {
          y === -1 ? (ie[Xe] || (et && r.set(f, et, !0), ie[Xe] = f), te[Xe] && delete te[Xe]) : r.eachTree([f], (Ct) => {
            const ot = yt(U, Ct);
            (U.eqRow(Ct, f) || T || !He || He({ row: Ct })) && (y ? te[ot] = Ct : te[ot] && delete te[ot], et && r.set(f, et, !1), delete ie[yt(U, Ct)], mo(f, y));
          }, { children: Me });
          const nt = r.findTree(he, (Ct) => U.eqRow(Ct, f), { children: Me });
          if (nt && nt.parent) {
            let Ct;
            const ot = [], Tt = {};
            if (!T && He ? nt.items.forEach((Pt) => {
              if (He({ row: Pt })) {
                const tn = yt(U, Pt);
                Tt[tn] = Pt, ot.push(Pt);
              }
            }) : nt.items.forEach((Pt) => {
              const tn = yt(U, Pt);
              Tt[tn] = Pt, ot.push(Pt);
            }), r.find(nt.items, (Pt) => !!ie[yt(U, Pt)]))
              Ct = -1;
            else {
              const Pt = [];
              nt.items.forEach((tn) => {
                const pn = yt(U, tn);
                te[pn] && Pt.push(tn);
              }), Ct = Pt.filter((tn) => Tt[yt(U, tn)]).length === ot.length ? !0 : Pt.length || y === -1 ? -1 : !1;
            }
            u.selectCheckboxMaps = te, w.handleSelectRow({ row: nt.parent }, Ct, T);
            return;
          }
        } else
          (T || !He || He({ row: f })) && (y ? te[Xe] || (te[Xe] = f) : te[Xe] && delete te[Xe], mo(f, y));
        u.selectCheckboxMaps = te;
      },
      triggerHeaderTitleEvent(f, y, T) {
        const k = y.content || y.message;
        if (k) {
          const { tooltipStore: W } = u, { column: ie } = T, te = fr(k);
          wo(!0), W.row = null, W.column = ie, W.visible = !0, W.currOpts = y, me(() => {
            const he = D.value;
            he && he.open && he.open(f.currentTarget, te);
          });
        }
      },
      /**
       * 触发表头 tooltip 事件
       */
      triggerHeaderTooltipEvent(f, y) {
        const { tooltipStore: T } = u, { column: k } = y, W = f.currentTarget;
        wo(!0), (T.column !== k || !T.visible) && dl(f, W, W, null, y);
      },
      /**
       * 触发单元格 tooltip 事件
       */
      triggerBodyTooltipEvent(f, y) {
        const { editConfig: T } = e, { editStore: k } = u, { tooltipStore: W } = u, ie = Ne.value, { actived: te } = k, { row: he, column: xe } = y, Me = f.currentTarget;
        if (wo(W.column !== xe || W.row !== he), !(xe.editRender && fn(T) && (ie.mode === "row" && te.row === he || te.row === he && te.column === xe)) && (W.column !== xe || W.row !== he || !W.visible)) {
          let $e, Ge;
          xe.treeNode ? ($e = Me.querySelector(".vxe-tree-cell"), xe.type === "html" && (Ge = Me.querySelector(".vxe-cell--html"))) : Ge = Me.querySelector(xe.type === "html" ? ".vxe-cell--html" : ".vxe-cell--label"), dl(f, Me, $e || Me.children[0], Ge, y);
        }
      },
      /**
       * 触发表尾 tooltip 事件
       */
      triggerFooterTooltipEvent(f, y) {
        const { column: T } = y, { tooltipStore: k } = u, W = f.currentTarget;
        wo(k.column !== T || !!k.row), (k.column !== T || !k.visible) && dl(f, W, W.querySelector(".vxe-cell--item") || W.children[0], null, y);
      },
      handleTargetLeaveEvent() {
        const f = Re.value;
        let y = D.value;
        y && y.setActived && y.setActived(!1), f.enterable ? d.tooltipTimeout = setTimeout(() => {
          y = D.value, y && y.isActived && !y.isActived() && p.closeTooltip();
        }, f.leaveDelay) : p.closeTooltip();
      },
      triggerHeaderCellClickEvent(f, y) {
        const { _lastResizeTime: T } = d, k = q.value, W = Ue.value, { column: ie } = y, te = f.currentTarget, he = T && T > Date.now() - 300, xe = kn(f, te, "vxe-cell--sort").flag, Me = kn(f, te, "vxe-cell--filter").flag;
        k.trigger === "cell" && !(he || xe || Me) && w.triggerSortEvent(f, ie, on(ie)), bt("header-cell-click", Object.assign({ triggerResizable: he, triggerSort: xe, triggerFilter: Me, cell: te }, y), f), (W.isCurrent || e.highlightCurrentColumn) && w.triggerCurrentColumnEvent(f, y);
      },
      triggerHeaderCellDblclickEvent(f, y) {
        bt("header-cell-dblclick", Object.assign({ cell: f.currentTarget }, y), f);
      },
      /**
       * 列点击事件
       * 如果是单击模式，则激活为编辑状态
       * 如果是双击模式，则单击后选中状态
       */
      triggerCellClickEvent(f, y) {
        const { highlightCurrentRow: T, editConfig: k } = e, { editStore: W } = u, ie = St.value, te = Ne.value, he = Dt.value, xe = Qe.value, Me = De.value, $e = F.value, Ge = _e.value, { actived: Fe, focused: He } = W, { row: et, column: Xe } = y, { type: nt, treeNode: Ct } = Xe, ot = nt === "radio", Tt = nt === "checkbox", Xt = nt === "expand", Pt = f.currentTarget, tn = ot && kn(f, Pt, "vxe-cell--radio").flag, pn = Tt && kn(f, Pt, "vxe-cell--checkbox").flag, zn = Ct && kn(f, Pt, "vxe-tree--btn-wrapper").flag, On = Xt && kn(f, Pt, "vxe-table--expanded").flag;
        y = Object.assign({ cell: Pt, triggerRadio: tn, triggerCheckbox: pn, triggerTreeNode: zn, triggerExpandNode: On }, y), !pn && !tn && (!On && (ie.trigger === "row" || Xt && ie.trigger === "cell") && w.triggerRowExpandEvent(f, y), (he.trigger === "row" || Ct && he.trigger === "cell") && w.triggerTreeExpandEvent(f, y)), zn || (On || ((Ge.isCurrent || T) && !pn && !tn && w.triggerCurrentRowEvent(f, y), !tn && (xe.trigger === "row" || ot && xe.trigger === "cell") && w.triggerRadioRowEvent(f, y), !pn && (Me.trigger === "row" || Tt && Me.trigger === "cell") && w.handleToggleCheckRowEvent(f, y)), fn(k) && ($e.arrowCursorLock && f && te.mode === "cell" && f.target && /^input|textarea$/i.test(f.target.tagName) && (He.column = Xe, He.row = et), te.trigger === "manual" ? Fe.args && Fe.row === et && Xe !== Fe.column && Wo(f, y) : (!Fe.args || et !== Fe.row || Xe !== Fe.column) && (te.trigger === "click" || te.trigger === "dblclick" && te.mode === "row" && Fe.row === et) && Wo(f, y))), bt("cell-click", y, f);
      },
      /**
       * 列双击点击事件
       * 如果是双击模式，则激活为编辑状态
       */
      triggerCellDblclickEvent(f, y) {
        const { editConfig: T } = e, { editStore: k } = u, W = Ne.value, { actived: ie } = k, te = f.currentTarget;
        y = Object.assign({ cell: te }, y), fn(T) && W.trigger === "dblclick" && (!ie.args || f.currentTarget !== ie.args.cell) && (W.mode === "row" ? $o("blur").catch((he) => he).then(() => {
          U.handleEdit(y, f).then(() => $o("change")).catch((he) => he);
        }) : W.mode === "cell" && U.handleEdit(y, f).then(() => $o("change")).catch((he) => he)), bt("cell-dblclick", y, f);
      },
      handleToggleCheckRowEvent(f, y) {
        const { selectCheckboxMaps: T } = u, k = De.value, { checkField: W, trigger: ie } = k, { row: te } = y;
        if (ie === "manual")
          return;
        let he = !1;
        W ? he = !r.get(te, W) : he = !T[yt(U, te)], f ? w.triggerCheckRowEvent(f, y, he) : (w.handleSelectRow(y, he), w.checkSelectionStatus());
      },
      triggerCheckRowEvent(f, y, T) {
        const k = De.value, { row: W } = y, { afterFullData: ie } = d, { checkMethod: te, trigger: he } = k;
        if (he !== "manual") {
          if (f.stopPropagation(), k.isShiftKey && f.shiftKey && !e.treeConfig) {
            const xe = p.getCheckboxRecords();
            if (xe.length) {
              const Me = xe[0], $e = p.getVTRowIndex(W), Ge = p.getVTRowIndex(Me);
              if ($e !== Ge) {
                p.setAllCheckboxRow(!1);
                const Fe = $e < Ge ? ie.slice($e, Ge + 1) : ie.slice(Ge, $e + 1);
                We(Fe, !0, !1), bt("checkbox-range-select", Object.assign({ rangeRecords: Fe }, y), f);
                return;
              }
            }
          }
          (!te || te({ row: W })) && (w.handleSelectRow(y, T), w.checkSelectionStatus(), bt("checkbox-change", Object.assign({
            records: p.getCheckboxRecords(),
            reserves: p.getCheckboxReserveRecords(),
            indeterminates: p.getCheckboxIndeterminateRecords(),
            checked: T
          }, y), f));
        }
      },
      /**
       * 多选，选中所有事件
       */
      triggerCheckAllEvent(f, y) {
        const T = De.value, { trigger: k } = T;
        k !== "manual" && (f && f.stopPropagation(), ia(f, y));
      },
      /**
       * 单选，行选中事件
       */
      triggerRadioRowEvent(f, y) {
        const { selectRadioRow: T } = u, { row: k } = y, W = Qe.value, { trigger: ie } = W;
        if (ie === "manual")
          return;
        f.stopPropagation();
        let te = k, he = T !== te;
        he ? ae(te) : W.strict || (he = T === te, he && (te = null, p.clearRadioRow())), he && bt("radio-change", Object.assign({ oldValue: T, newValue: te }, y), f);
      },
      triggerCurrentColumnEvent(f, y) {
        const T = Ue, { currentMethod: k } = T.value, { column: W } = y;
        (!k || k({ column: W })) && p.setCurrentColumn(W);
      },
      triggerCurrentRowEvent(f, y) {
        const { currentRow: T } = u, k = _e, { currentMethod: W } = k.value, { row: ie } = y, te = T !== ie;
        (!W || W({ row: ie })) && (p.setCurrentRow(ie), te && bt("current-change", Object.assign({ oldValue: T, newValue: ie }, y), f));
      },
      /**
       * 展开行事件
       */
      triggerRowExpandEvent(f, y) {
        const { rowExpandLazyLoadedMaps: T, expandColumn: k } = u, W = St.value, { row: ie } = y, { lazy: te, trigger: he } = W;
        if (he === "manual")
          return;
        f.stopPropagation();
        const xe = yt(U, ie);
        if (!te || !T[xe]) {
          const Me = !p.isRowExpandByRow(ie), $e = p.getColumnIndex(k), Ge = p.getVMColumnIndex(k);
          p.setRowExpand(ie, Me), bt("toggle-row-expand", {
            expanded: Me,
            column: k,
            columnIndex: $e,
            $columnIndex: Ge,
            row: ie,
            rowIndex: p.getRowIndex(ie),
            $rowIndex: p.getVMRowIndex(ie)
          }, f);
        }
      },
      /**
       * 展开树节点事件
       */
      triggerTreeExpandEvent(f, y) {
        const { treeExpandLazyLoadedMaps: T } = u, k = Dt.value, { row: W, column: ie } = y, { lazy: te, trigger: he } = k;
        if (he === "manual")
          return;
        f.stopPropagation();
        const xe = yt(U, W);
        if (!te || !T[xe]) {
          const Me = !p.isTreeExpandByRow(W), $e = p.getColumnIndex(ie), Ge = p.getVMColumnIndex(ie);
          p.setTreeExpand(W, Me), bt("toggle-tree-expand", { expanded: Me, column: ie, columnIndex: $e, $columnIndex: Ge, row: W }, f);
        }
      },
      /**
       * 点击排序事件
       */
      triggerSortEvent(f, y, T) {
        const { mouseConfig: k } = e, W = q.value, ie = R.value, { field: te, sortable: he } = y;
        if (he) {
          !T || y.order === T ? p.clearSort(W.multiple ? y : null) : p.sort({ field: te, order: T });
          const xe = { $table: U, $event: f, column: y, field: te, property: te, order: y.order, sortList: p.getSortColumns(), sortTime: y.sortTime };
          k && ie.area && U.handleSortEvent && U.handleSortEvent(f, xe), bt("sort-change", xe, f);
        }
      },
      /**
       * 行拖拽
       */
      handleRowDragDragstartEvent(f) {
        const y = new Image();
        f.dataTransfer && f.dataTransfer.setDragImage(y, 0, 0);
      },
      handleRowDragDragendEvent(f) {
        const { treeConfig: y, dragConfig: T } = e, k = it.value, { fullAllDataRowIdData: W } = d, { isCrossDrag: ie, isSelfToChildDrag: te, dragEndMethod: he } = k, xe = Dt.value, { transform: Me, mapChildrenField: $e, parentField: Ge } = xe, Fe = xe.children || xe.childrenField, { dragRow: He } = u, { afterFullData: et, tableFullData: Xe, prevDragRow: nt, prevDragPos: Ct } = d, ot = he || (T ? T.dragEndMethod : null), Tt = Ct === "bottom" ? 1 : 0;
        nt && He && nt !== He && Promise.resolve(ot ? ot({
          oldRow: He,
          newRow: nt,
          dragPos: Ct,
          offsetIndex: Tt
        }) : !0).then((Xt) => {
          if (!Xt)
            return;
          let Pt = -1, tn = -1;
          if (y) {
            if (Me) {
              const pn = yt(U, He), zn = W[pn], On = yt(U, nt), xn = W[On];
              if (zn && xn) {
                const { level: _n } = zn, { level: ln } = xn, an = {};
                r.eachTree([He], (Ds) => {
                  an[yt(U, Ds)] = Ds;
                }, { children: $e });
                let Hn = !1;
                if (_n && ln) {
                  if (!ie)
                    return;
                  if (an[On] && !te) {
                    Hn = !0, Ce.modal && Ce.modal.message({
                      status: "error",
                      content: bl("vxe.error.treeDragChild")
                    });
                    return;
                  }
                } else if (_n) {
                  if (!ie)
                    return;
                } else if (ln) {
                  if (!ie)
                    return;
                  if (an[On] && (Hn = !0, !te)) {
                    Ce.modal && Ce.modal.message({
                      status: "error",
                      content: bl("vxe.error.treeDragChild")
                    });
                    return;
                  }
                }
                const Yo = r.toTreeArray(d.afterTreeFullData, { children: Fe }), Ss = U.findRowIndexOf(Yo, He);
                Yo.splice(Ss, 1);
                const Er = U.findRowIndexOf(Yo, nt) + Tt;
                Yo.splice(Er, 0, He), Hn && te && r.each(He[Fe], (Ds) => {
                  Ds[Ge] = He[Ge];
                }), He[Ge] = nt[Ge], d.tableFullTreeData = r.toArrayTree(Yo, {
                  key: xe.rowField,
                  parentKey: xe.parentField,
                  children: Fe,
                  mapChildren: xe.mapChildrenField
                });
              }
            }
          } else {
            Pt = U.findRowIndexOf(et, He);
            const pn = U.findRowIndexOf(Xe, He);
            et.splice(Pt, 1), Xe.splice(pn, 1);
            const zn = U.findRowIndexOf(et, nt), On = U.findRowIndexOf(Xe, nt);
            tn = zn + Tt;
            const xn = On + Tt;
            et.splice(tn, 0, He), Xe.splice(xn, 0, He);
          }
          u.isDragRowMove = !0, U.handleTableData(y && Me), U.cacheRowMap(!0), cl(), y && Me || U.updateAfterDataIndex(), U.checkSelectionStatus(), u.scrollYLoad && U.updateScrollYSpace(), me().then(() => {
            U.updateCellAreas(), U.recalculate();
          }), bt("row-dragend", {
            oldRow: He,
            newRow: nt,
            dragPos: Ct,
            offsetIndex: Tt,
            _index: {
              newIndex: tn,
              oldIndex: Pt
            }
          }, f);
        }).catch(() => {
        }), Js(), eo(), u.dragRow = null, u.dragCol = null, setTimeout(() => {
          u.isDragRowMove = !1;
        }, 500);
      },
      handleRowDragDragoverEvent(f) {
        const { treeConfig: y } = e, { fullAllDataRowIdData: T } = d, { dragRow: k } = u, W = it.value, { isCrossDrag: ie } = W;
        if (!k) {
          f.preventDefault();
          return;
        }
        const te = f.currentTarget, he = te.getAttribute("rowid") || "", xe = T[he];
        if (xe) {
          const Me = xe.row;
          f.preventDefault();
          const { dragRow: $e } = u, Fe = f.clientY - te.getBoundingClientRect().y < te.clientHeight / 2 ? "top" : "bottom";
          if (U.eqRow($e, Me) || !ie && y && xe.level) {
            Hr(f, te, null, !1, Fe);
            return;
          }
          d.prevDragRow = Me, d.prevDragPos = Fe, Hr(f, te, null, !0, Fe), bt("row-dragover", {
            oldRow: $e,
            targetRow: Me,
            dragPos: Fe
          }, f);
        }
      },
      handleCellDragMousedownEvent(f, y) {
        var T;
        f.stopPropagation();
        const { dragConfig: k } = e, W = it.value, { dragStartMethod: ie } = W, { row: te } = y, xe = (T = f.currentTarget.parentElement) === null || T === void 0 ? void 0 : T.parentElement, Me = xe.parentElement, $e = ie || (k ? k.dragStartMethod : null);
        if (u.isDragRowMove = !1, eo(), $e && !$e(y)) {
          Me.draggable = !1, u.dragRow = null, u.dragCol = null, Js();
          return;
        }
        u.dragRow = te, u.dragCol = null, Me.draggable = !0, os(te), Cr(xe), bt("row-dragstart", y, f);
      },
      handleCellDragMouseupEvent() {
        eo(), Js(), u.dragRow = null, u.dragCol = null, u.isDragRowMove = !1;
      },
      /**
       * 列拖拽
       */
      handleHeaderCellDragDragstartEvent(f) {
        const y = new Image();
        f.dataTransfer && f.dataTransfer.setDragImage(y, 0, 0);
      },
      handleHeaderCellDragDragendEvent(f) {
        const { mouseConfig: y } = e, T = vt.value, { dragEndMethod: k } = T, { dragCol: W } = u, { collectColumn: ie, prevDragCol: te, prevDragPos: he } = d, xe = he === "right" ? 1 : 0;
        te && W && te !== W && Promise.resolve(k ? k({
          oldColumn: W,
          newColumn: te,
          dragPos: he,
          offsetIndex: xe
        }) : !0).then((Me) => {
          if (!Me)
            return;
          r.eachTree(ie, (He, et, Xe, nt, Ct) => {
            if (!Ct) {
              const ot = et + 1;
              He.renderSortNumber = ot;
            }
          });
          const $e = r.findIndexOf(ie, (He) => He.id === W.id), Ge = r.findIndexOf(ie, (He) => He.id === te.id) + xe, Fe = ie[Ge];
          Fe ? (W.renderSortNumber = Fe.renderSortNumber, Fe.renderSortNumber = W.renderSortNumber + 0.5) : W.renderSortNumber = ie.length + 1.5, u.isDragColMove = !0, y && (U.clearSelected && U.clearSelected(), U.clearCellAreas && (U.clearCellAreas(), U.clearCopyCellArea())), w.analyColumnWidth(), me().then(() => {
            U.updateCellAreas(), p.refreshColumn(!0);
          }), bt("column-dragend", {
            oldColumn: W,
            newColumn: te,
            dragPos: he,
            offsetIndex: xe,
            _index: {
              newIndex: Ge,
              oldIndex: $e
            }
          }, f), U.saveCustomStore("update:sort");
        }).catch(() => {
        }), Js(), ti(), u.dragRow = null, u.dragCol = null, setTimeout(() => {
          u.isDragColMove = !1;
        }, 500);
      },
      handleHeaderCellDragDragoverEvent(f) {
        const { dragCol: y } = u;
        if (!y) {
          f.preventDefault();
          return;
        }
        const T = f.currentTarget, k = T.getAttribute("colid"), W = U.getColumnById(k);
        if (W) {
          f.preventDefault();
          const { dragCol: ie } = u, he = f.clientX - T.getBoundingClientRect().x < T.clientWidth / 2 ? "left" : "right";
          if (ie.id === W.id || W.parentId) {
            Hr(f, null, T, !1, he);
            return;
          }
          d.prevDragCol = W, d.prevDragPos = he, Hr(f, null, T, !0, he), bt("column-dragover", {
            oldColumn: ie,
            targetColumn: W,
            dragPos: he
          }, f);
        }
      },
      handleHeaderCellDragMousedownEvent(f, y) {
        var T;
        f.stopPropagation();
        const k = vt.value, { dragStartMethod: W } = k, { column: ie } = y, he = (T = f.currentTarget.parentElement) === null || T === void 0 ? void 0 : T.parentElement;
        if (u.isDragColMove = !1, ti(), W && !W(y)) {
          he.draggable = !1, u.dragRow = null, u.dragCol = null, Js();
          return;
        }
        u.dragCol = ie, u.dragRow = null, he.draggable = !0, Qc(ie), eu(he), bt("column-dragstart", y, f);
      },
      handleHeaderCellDragMouseupEvent() {
        ti(), Js(), u.dragRow = null, u.dragCol = null, u.isDragColMove = !1;
      },
      handleScrollEvent(f, y, T, k, W, ie) {
        const { highlightHoverRow: te } = e, { lastScrollLeft: he, lastScrollTop: xe } = d, Me = E.value, $e = Me ? Me.$el : null, Ge = _e.value, Fe = x.value, He = D.value, et = $e ? $e.clientHeight : 0, Xe = $e ? $e.clientWidth : 0, nt = $e ? $e.scrollHeight : 0, Ct = $e ? $e.scrollWidth : 0;
        let ot = !1, Tt = !1, Xt = !1, Pt = !1, tn = "", pn = !1, zn = !1, On = !1, xn = !1;
        if (T) {
          const ln = Se.value;
          Xt = W <= 0, Xt || (Pt = W + Xe >= Ct), W > he ? (tn = "right", W + Xe >= Ct - ln && (xn = !0)) : (tn = "left", W <= ln && (On = !0)), w.checkScrolling(), d.lastScrollLeft = W;
        }
        if (y) {
          const ln = Ie.value;
          ot = k <= 0, ot || (Tt = k + et >= nt), k > xe ? (tn = "bottom", k + et >= nt - ln && (zn = !0)) : (tn = "top", k <= ln && (pn = !0)), d.lastScrollTop = k;
        }
        u.lastScrollTime = Date.now();
        const _n = Object.assign({
          scrollTop: k,
          scrollLeft: W,
          bodyHeight: et,
          bodyWidth: Xe,
          scrollHeight: nt,
          scrollWidth: Ct,
          isX: T,
          isY: y,
          isTop: ot,
          isBottom: Tt,
          isLeft: Xt,
          isRight: Pt,
          direction: tn
        }, ie);
        qe(T, y), (Ge.isHover || te) && U.clearHoverRow(), Fe && Fe.reactData.visible && Fe.close(), He && He.reactData.visible && He.close(), (zn || pn || xn || On) && bt("scroll-boundary", _n, f), bt("scroll", _n, f);
      },
      /**
       * 横向 X 可视渲染事件处理
       */
      triggerScrollXEvent() {
        Oe.value.immediate ? bo() : $d();
      },
      /**
       * 纵向 Y 可视渲染事件处理
       */
      triggerScrollYEvent() {
        de.value.immediate ? Ql() : Jc();
      },
      /**
       * 对于树形结构中，可以直接滚动到指定深层节点中
       * 对于某些特定的场景可能会用到，比如定位到某一节点
       * @param {Row} row 行对象
       */
      scrollToTreeRow(f) {
        const { treeConfig: y } = e, { tableFullData: T } = d, k = [];
        if (y) {
          const W = Dt.value, ie = W.children || W.childrenField, te = r.findTree(T, (he) => U.eqRow(he, f), { children: ie });
          if (te) {
            const he = te.nodes;
            he.forEach((xe, Me) => {
              Me < he.length - 1 && !p.isTreeExpandByRow(xe) && k.push(p.setTreeExpand(xe, !0));
            });
          }
        }
        return Promise.all(k).then(() => wp(U, f));
      },
      updateScrollYStatus: cl,
      // 更新横向 X 可视渲染上下剩余空间大小
      updateScrollXSpace() {
        const { isGroup: f, scrollXLoad: y, scrollbarWidth: T } = u, { visibleColumn: k, scrollXStore: W, elemStore: ie, tableWidth: te } = d, he = b.value, xe = E.value, Me = C.value, $e = xe ? xe.$el : null;
        if ($e) {
          const Ge = he ? he.$el : null, Fe = Me ? Me.$el : null, He = Ge ? Ge.querySelector(".vxe-table--header") : null, et = $e.querySelector(".vxe-table--body"), Xe = Fe ? Fe.querySelector(".vxe-table--footer") : null, nt = k.slice(0, W.startIndex).reduce((Xt, Pt) => Xt + Pt.renderWidth, 0);
          let Ct = "";
          y && (Ct = `${nt}px`), He && (He.style.marginLeft = f ? "" : Ct), et.style.marginLeft = Ct, Xe && (Xe.style.marginLeft = Ct), ["main"].forEach((Xt) => {
            ["header", "body", "footer"].forEach((tn) => {
              const pn = Ho(ie[`${Xt}-${tn}-xSpace`]);
              pn && (pn.style.width = y ? `${te + (tn === "header" ? T : 0)}px` : "");
            });
          });
          const Tt = fe.value;
          Tt && (Tt.style.width = `${te + T}px`), me(Kn);
        }
      },
      // 更新纵向 Y 可视渲染上下剩余空间大小
      updateScrollYSpace() {
        const { showOverflow: f } = e, { scrollYLoad: y } = u, { scrollYStore: T, elemStore: k, afterFullData: W, fullAllDataRowIdData: ie } = d, { startIndex: te, rowHeight: he } = T;
        let xe = 0, Me = 0;
        const $e = ["main", "left", "right"];
        let Ge = "", Fe = "";
        if (y) {
          if (f)
            xe = W.length * he, Me = Math.max(0, te * he);
          else {
            for (let et = 0; et < W.length; et++) {
              const Xe = W[et], nt = yt(U, Xe), Ct = ie[nt];
              Ct && (xe += Ct.height || he);
            }
            for (let et = 0; et < te; et++) {
              const Xe = W[et], nt = yt(U, Xe), Ct = ie[nt];
              Ct && (Me += Ct.height || he);
            }
          }
          Ge = `${Me}px`, Fe = `${xe}px`;
        }
        $e.forEach((et) => {
          const Xe = ["header", "body", "footer"], nt = Ho(k[`${et}-body-table`]);
          nt && (nt.style.marginTop = Ge), Xe.forEach((Ct) => {
            const ot = Ho(k[`${et}-${Ct}-ySpace`]);
            ot && (ot.style.height = Fe);
          });
        });
        const He = pe.value;
        He && (He.style.height = Fe), me(Kn);
      },
      updateScrollXData() {
        const { showOverflow: f } = e;
        return me().then(() => {
          Xn(), Es(), w.updateScrollXSpace(), f || w.updateScrollYSpace();
        });
      },
      updateScrollYData() {
        return me().then(() => {
          w.handleTableData(), Es(), w.updateScrollYSpace();
        });
      },
      /**
       * 处理固定列的显示状态
       */
      checkScrolling() {
        const f = K.value, y = L.value, T = E.value, k = T ? T.$el : null, ie = A.value || k;
        ie && (f && (ie.scrollLeft > 0 ? Ms(f, "scrolling--middle") : jo(f, "scrolling--middle")), y && (ie.clientWidth < ie.scrollWidth - Math.ceil(ie.scrollLeft) ? Ms(y, "scrolling--middle") : jo(y, "scrolling--middle")));
      },
      updateZindex() {
        e.zIndex ? d.tZindex = e.zIndex : d.tZindex < Nh() && (d.tZindex = Rh());
      },
      handleCheckedCheckboxRow: We,
      /**
       * 行 hover 事件
       */
      triggerHoverEvent(f, { row: y }) {
        w.setHoverRow(y);
      },
      setHoverRow(f) {
        const y = yt(U, f), T = v.value;
        w.clearHoverRow(), T && r.arrayEach(T.querySelectorAll(`[rowid="${y}"]`), (k) => Ms(k, "row--hover")), d.hoverRow = f;
      },
      clearHoverRow() {
        const f = v.value;
        f && r.arrayEach(f.querySelectorAll(".vxe-body--row.row--hover"), (y) => jo(y, "row--hover")), d.hoverRow = null;
      },
      /**
       * 已废弃，被 getCellElement 替换
       * @deprecated
       */
      getCell(f, y) {
        return p.getCellElement(f, y);
      },
      findRowIndexOf(f, y) {
        return y ? r.findIndexOf(f, (T) => U.eqRow(T, y)) : -1;
      },
      eqRow(f, y) {
        return f && y ? f === y ? !0 : yt(U, f) === yt(U, y) : !1;
      }
    }, process.env.NODE_ENV === "development" && ("openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print".split(",").forEach((f) => {
      U[f] = function() {
        Ut("vxe.error.reqModule", ["VxeTableExportModule"]);
      };
    }), "clearValidate,fullValidate,validate".split(",").forEach((f) => {
      U[f] = function() {
        Ut("vxe.error.reqModule", ["VxeTableValidatorModule"]);
      };
    })), Object.assign(U, p, w);
    const Rd = (f) => {
      const { showHeader: y, showFooter: T } = e, { tableData: k, tableColumn: W, tableGroupColumn: ie, columnStore: te, footerTableData: he } = u, xe = f === "left", Me = xe ? te.leftList : te.rightList;
      return o("div", {
        ref: xe ? K : L,
        class: `vxe-table--fixed-${f}-wrapper`
      }, [
        y ? o(kp, {
          ref: xe ? V : G,
          fixedType: f,
          tableData: k,
          tableColumn: W,
          tableGroupColumn: ie,
          fixedColumn: Me
        }) : Vo(U),
        o(Vp, {
          ref: xe ? Q : ue,
          fixedType: f,
          tableData: k,
          tableColumn: W,
          fixedColumn: Me
        }),
        T ? o($p, {
          ref: xe ? Z : Y,
          footerTableData: he,
          tableColumn: W,
          fixedColumn: Me,
          fixedType: f
        }) : Vo(U)
      ]);
    }, ab = () => {
      const f = Wt.value, y = { $table: U };
      if (n.empty)
        return n.empty(y);
      {
        const T = f.name ? Np.get(f.name) : null, k = T ? T.renderTableEmpty || T.renderTableEmptyView || T.renderEmpty : null;
        if (k)
          return cs(k(f, y));
      }
      return fr(e.emptyText) || bl("vxe.table.emptyText");
    }, cb = () => {
      const { dragConfig: f } = e, { dragRow: y, dragCol: T, dragTipText: k } = u, W = vt.value, he = (it.value.slots || {}).tip || (f && f.slots ? f.slots.rowTip : null), Me = (W.slots || {}).tip;
      return y && he ? ni(he, { row: y }) : T && Me ? ni(Me, { column: T }) : [o("span", k)];
    }, ub = () => {
      const { dragRow: f } = u, y = _e.value, T = Ue.value, k = it.value, W = vt.value;
      return y.drag || T.drag ? o("div", {
        class: "vxe-table--drag-wrapper"
      }, [
        o("div", {
          ref: I,
          class: ["vxe-table--drag-row-line", {
            "is--guides": k.showGuidesStatus
          }]
        }),
        o("div", {
          ref: B,
          class: ["vxe-table--drag-col-line", {
            "is--guides": W.showGuidesStatus
          }]
        }),
        o("div", {
          ref: M,
          class: "vxe-table--drag-sort-tip"
        }, [
          o("div", {
            class: "vxe-table--drag-sort-tip-wrapper"
          }, [
            o("div", {
              class: "vxe-table--drag-sort-tip-status"
            }, [
              o("span", {
                class: ["vxe-table--drag-sort-tip-normal-status", f ? Pu().TABLE_DRAG_STATUS_ROW : Pu().TABLE_DRAG_STATUS_COLUMN]
              }),
              o("span", {
                class: ["vxe-table--drag-sort-tip-disabled-status", Pu().TABLE_DRAG_DISABLED]
              })
            ]),
            o("div", {
              class: "vxe-table--drag-sort-tip-content"
            }, cb())
          ])
        ])
      ]) : Vo(U);
    };
    function tu() {
      const f = v.value;
      f && f.clientWidth && f.clientHeight && p.recalculate();
    }
    const db = () => {
      const { loading: f, stripe: y, showHeader: T, height: k, treeConfig: W, mouseConfig: ie, showFooter: te, highlightCell: he, highlightHoverRow: xe, highlightHoverColumn: Me, editConfig: $e, editRules: Ge } = e, { isCalcColumn: Fe, isGroup: He, overflowX: et, overflowY: Xe, scrollXLoad: nt, scrollYLoad: Ct, scrollbarHeight: ot, tableData: Tt, tableColumn: Xt, tableGroupColumn: Pt, footerTableData: tn, initStore: pn, columnStore: zn, filterStore: On, customStore: xn, tooltipStore: _n } = u, { leftList: ln, rightList: an } = zn, Hn = n.loading, Yo = Be.value, Ss = ge.value, wr = De.value, Er = Dt.value, Ds = _e.value, Qs = Ue.value, jr = m.value, qr = Ot.value, er = R.value, so = le.value, Xo = ve.value, Pn = nn.value, uo = ze.value, No = u._isLoading || f, ro = Bt.value, Mo = at.value, to = ie && er.area;
      return o("div", {
        ref: v,
        class: ["vxe-table", "vxe-table--render-default", `tid_${i}`, `border--${qr}`, {
          [`size--${jr}`]: jr,
          [`valid-msg--${Ss.msgMode}`]: !!Ge,
          "vxe-editable": !!$e,
          "old-cell-valid": Ge && Mn().cellVaildMode === "obsolete",
          "cell--highlight": he,
          "cell--selected": ie && er.selected,
          "cell--area": to,
          "header-cell--area": to && so.selectCellByHeader,
          "body-cell--area": to && so.selectCellByBody,
          "row--highlight": Ds.isHover || xe,
          "column--highlight": Qs.isHover || Me,
          "checkbox--range": wr.range,
          "column--calc": Fe,
          "is--header": T,
          "is--footer": te,
          "is--group": He,
          "is--tree-line": W && (Er.showLine || Er.line),
          "is--fixed-left": ln.length,
          "is--fixed-right": an.length,
          "is--animat": !!e.animat,
          "is--padding": e.padding,
          "is--round": e.round,
          "is--stripe": !W && y,
          "is--loading": No,
          "is--empty": !No && !Tt.length,
          "is--scroll-y": Xe,
          "is--scroll-x": et,
          "is--virtual-x": nt,
          "is--virtual-y": Ct
        }],
        spellcheck: !1,
        onKeydown: Vt
      }, [
        /**
         * 隐藏列
         */
        o("div", {
          class: "vxe-table-slots"
        }, n.default ? n.default({}) : []),
        o("div", {
          key: "tw",
          class: "vxe-table--render-wrapper"
        }, [
          o("div", {
            class: "vxe-table--main-wrapper"
          }, [
            /**
             * 表头
             */
            T ? o(kp, {
              ref: b,
              tableData: Tt,
              tableColumn: Xt,
              tableGroupColumn: Pt
            }) : Vo(U),
            /**
             * 表体
             */
            o(Vp, {
              ref: E,
              tableData: Tt,
              tableColumn: Xt
            }),
            /**
             * 表尾
             */
            te ? o($p, {
              ref: C,
              footerTableData: tn,
              tableColumn: Xt
            }) : Vo(U)
          ]),
          o("div", {
            class: "vxe-table--fixed-wrapper"
          }, [
            ln && ln.length && et ? Rd("left") : Vo(U),
            an && an.length && et ? Rd("right") : Vo(U)
          ])
        ]),
        ro.x ? o("div", {
          key: "vx",
          ref: H,
          class: "vxe-table--scroll-x-virtual"
        }, [
          o("div", {
            ref: A,
            class: "vxe-table--scroll-x-handle",
            onScroll: X
          }, [
            o("div", {
              ref: fe,
              class: "vxe-table--scroll-x-space"
            })
          ])
        ]) : Vo(U),
        ro.y ? o("div", {
          key: "vy",
          ref: ce,
          class: "vxe-table--scroll-y-virtual"
        }, [
          o("div", {
            ref: j,
            class: "vxe-table--scroll-y-handle",
            onScroll: Le
          }, [
            o("div", {
              ref: pe,
              class: "vxe-table--scroll-y-space"
            })
          ])
        ]) : Vo(U),
        /**
         * 空数据
         */
        o("div", {
          key: "tn",
          ref: P,
          class: "vxe-table--empty-placeholder"
        }, [
          o("div", {
            class: "vxe-table--empty-content"
          }, ab())
        ]),
        /**
         * 边框线
         */
        o("div", {
          key: "tl",
          class: "vxe-table--border-line"
        }),
        /**
         * 列宽线
         */
        o("div", {
          key: "cl",
          ref: ye,
          class: "vxe-table--resizable-bar",
          style: et ? {
            "padding-bottom": `${ot}px`
          } : null
        }, Mo.showDragTip ? [
          o("div", {
            ref: se,
            class: "vxe-table--resizable-number-tip"
          }, "23432px")
        ] : []),
        /**
         * 加载中
         */
        l ? o(l, {
          key: "lg",
          class: "vxe-table--loading",
          modelValue: No,
          icon: Pn.icon,
          text: Pn.text
        }, Hn ? {
          default: () => ni(Hn, { $table: U, $grid: ne, loading: No })
        } : {}) : Hn ? o("div", {
          class: ["vxe-loading--custom-wrapper", {
            "is--visible": No
          }]
        }, ni(Hn, { $table: U, $grid: ne, loading: No })) : Vo(U),
        /**
         * 自定义列
         */
        pn.custom ? o(_N, {
          key: "cs",
          ref: g,
          customStore: xn
        }) : Vo(U),
        /**
         * 筛选
         */
        pn.filter ? o(WN, {
          key: "tf",
          ref: O,
          filterStore: On
        }) : Vo(U),
        /**
         * 导入
         */
        pn.import && e.importConfig ? o(HN, {
          key: "it",
          defaultOptions: u.importParams,
          storeData: u.importStore
        }) : Vo(U),
        /**
         * 导出
         */
        pn.export && (e.exportConfig || e.printConfig) ? o(jN, {
          key: "et",
          defaultOptions: u.exportParams,
          storeData: u.exportStore
        }) : Vo(U),
        /**
         * 快捷菜单
         */
        uo ? o(UN, {
          key: "tm",
          ref: h
        }) : Vo(U),
        /**
         * 拖拽排序提示
         */
        ub(),
        /**
         * 提示相关
         */
        a ? o("div", {}, [
          /**
           * 通用提示
           */
          o(a, {
            key: "ctp",
            ref: S,
            isArrow: !1,
            enterable: !1
          }),
          /**
            * 工具提示
            */
          o(a, Object.assign({
            key: "btp",
            ref: D
          }, Yo, _n.currOpts)),
          /**
            * 校验提示
            */
          e.editRules && Ss.showMessage && (Ss.message === "default" ? !k : Ss.message === "tooltip") ? o(a, Object.assign({ key: "vtp", ref: x, class: [{
            "old-cell-valid": Ge && Mn().cellVaildMode === "obsolete"
          }, "vxe-table--valid-error"] }, Ss.message === "tooltip" || Tt.length === 1 ? Xo : {})) : Vo(U)
        ]) : Vo(U)
      ]);
    }, nu = ke(0);
    lt(() => e.data ? e.data.length : -1, () => {
      nu.value++;
    }), lt(() => e.data, () => {
      nu.value++;
    }), lt(nu, () => {
      const { inited: f, initStatus: y } = d;
      To(e.data || []).then(() => {
        const { scrollXLoad: T, scrollYLoad: k, expandColumn: W } = u;
        d.inited = !0, d.initStatus = !0, y || vo(), f || go(), process.env.NODE_ENV === "development" && (T || k) && W && rn("vxe.error.scrollErrProp", ["column.type=expand"]), p.recalculate();
      });
    });
    const ou = ke(0);
    lt(() => u.staticColumns.length, () => {
      ou.value++;
    }), lt(() => u.staticColumns, () => {
      ou.value++;
    }), lt(ou, () => {
      ra(u.staticColumns);
    });
    const su = ke(0);
    lt(() => u.tableColumn.length, () => {
      su.value++;
    }), lt(() => u.tableColumn, () => {
      su.value++;
    }), lt(su, () => {
      w.analyColumnWidth();
    }), lt(() => u.upDataFlag, () => {
      me(() => {
        p.updateData();
      });
    }), lt(() => u.reColumnFlag, () => {
      me(() => {
        p.refreshColumn();
      });
    }), lt(() => e.showHeader, () => {
      me(() => {
        p.recalculate(!0).then(() => p.refreshScroll());
      });
    }), lt(() => e.showFooter, () => {
      me(() => {
        p.recalculate(!0).then(() => p.refreshScroll());
      });
    });
    const ru = ke(0);
    lt(() => e.footerData ? e.footerData.length : -1, () => {
      ru.value++;
    }), lt(() => e.footerData, () => {
      ru.value++;
    }), lt(ru, () => {
      p.updateFooter();
    }), lt(() => e.height, () => {
      me(() => p.recalculate(!0));
    }), lt(() => e.maxHeight, () => {
      me(() => p.recalculate(!0));
    }), lt(() => e.syncResize, (f) => {
      f && (tu(), me(() => {
        tu(), setTimeout(() => tu());
      }));
    });
    const lu = ke(0);
    lt(() => e.mergeCells ? e.mergeCells.length : -1, () => {
      lu.value++;
    }), lt(() => e.mergeCells, () => {
      lu.value++;
    }), lt(lu, () => {
      p.clearMergeCells(), me(() => {
        e.mergeCells && p.setMergeCells(e.mergeCells);
      });
    });
    const iu = ke(0);
    lt(() => e.mergeFooterItems ? e.mergeFooterItems.length : -1, () => {
      iu.value++;
    }), lt(() => e.mergeFooterItems, () => {
      iu.value++;
    }), lt(iu, () => {
      p.clearMergeFooterItems(), me(() => {
        e.mergeFooterItems && p.setMergeFooterItems(e.mergeFooterItems);
      });
    }), c && lt(() => c ? c.reactData.resizeFlag : null, () => {
      Ko();
    }), YN.forEach((f) => {
      const { setupTable: y } = f;
      if (y) {
        const T = y(U);
        T && r.isObject(T) && Object.assign(U, T);
      }
    }), w.preventEvent(null, "created", { $table: U });
    let oi;
    return Cm(() => {
      p.recalculate().then(() => p.refreshScroll()), w.preventEvent(null, "activated", { $table: U });
    }), gb(() => {
      d.isActivated = !1, w.preventEvent(null, "deactivated", { $table: U });
    }), wn(() => {
      me(() => {
        const { data: f, treeConfig: y, showOverflow: T } = e, { scrollXStore: k, scrollYStore: W } = d, ie = de.value, te = Ne.value, he = Dt.value, xe = Qe.value, Me = De.value, $e = St.value, Ge = _e.value;
        if (process.env.NODE_ENV === "development") {
          e.rowId && rn("vxe.error.delProp", ["row-id", "row-config.keyField"]), e.rowKey && rn("vxe.error.delProp", ["row-key", "row-config.useKey"]), e.columnKey && rn("vxe.error.delProp", ["column-id", "column-config.useKey"]), !(e.rowId || Ge.keyField) && (Me.reserve || Me.checkRowKeys || xe.reserve || xe.checkRowKey || $e.expandRowKeys || he.expandRowKeys) && rn("vxe.error.reqProp", ["row-config.keyField"]), e.editConfig && (te.showStatus || te.showUpdateStatus || te.showInsertStatus) && !e.keepSource && rn("vxe.error.reqProp", ["keep-source"]), y && (he.showLine || he.line) && (!(e.rowKey || Ge.useKey) || !T) && rn("vxe.error.reqProp", ["row-config.useKey | show-overflow"]), y && !he.transform && e.stripe && rn("vxe.error.noTree", ["stripe"]), e.showFooter && !(e.footerMethod || e.footerData) && rn("vxe.error.reqProp", ["footer-data | footer-method"]);
          const { exportConfig: Fe, importConfig: He } = e, et = ct.value, Xe = Ke.value;
          He && Xe.types && !Xe.importMethod && !r.includeArrays(r.keys(Xe._typeMaps), Xe.types) && rn("vxe.error.errProp", [`export-config.types=${Xe.types.join(",")}`, Xe.types.filter((nt) => r.includes(r.keys(Xe._typeMaps), nt)).join(",") || r.keys(Xe._typeMaps).join(",")]), Fe && et.types && !et.exportMethod && !r.includeArrays(r.keys(et._typeMaps), et.types) && rn("vxe.error.errProp", [`export-config.types=${et.types.join(",")}`, et.types.filter((nt) => r.includes(r.keys(et._typeMaps), nt)).join(",") || r.keys(et._typeMaps).join(",")]);
        }
        if (process.env.NODE_ENV === "development") {
          const Fe = At.value, He = R.value, et = _e.value;
          if (e.id || (e.customConfig ? fn(Fe) : Fe.enabled) && Fe.storage && Ut("vxe.error.reqProp", ["id"]), e.treeConfig && Me.range && Ut("vxe.error.noTree", ["checkbox-config.range"]), et.height && !e.showOverflow && rn("vxe.error.notProp", ["table.show-overflow"]), !U.handleMousedownCellAreaEvent && (e.areaConfig && rn("vxe.error.notProp", ["area-config"]), e.clipConfig && rn("vxe.error.notProp", ["clip-config"]), e.fnrConfig && rn("vxe.error.notProp", ["fnr-config"]), He.area)) {
            Ut("vxe.error.notProp", ["mouse-config.area"]);
            return;
          }
          e.dragConfig && rn("vxe.error.delProp", ["drag-config", "row-drag-config"]), e.treeConfig && he.children && rn("vxe.error.delProp", ["tree-config.children", "tree-config.childrenField"]), e.treeConfig && he.line && rn("vxe.error.delProp", ["tree-config.line", "tree-config.showLine"]), He.area && He.selected && rn("vxe.error.errConflicts", ["mouse-config.area", "mouse-config.selected"]), He.area && e.treeConfig && !he.transform && Ut("vxe.error.noTree", ["mouse-config.area"]), e.editConfig && te.activeMethod && rn("vxe.error.delProp", ["edit-config.activeMethod", "edit-config.beforeEditMethod"]), e.treeConfig && Me.isShiftKey && Ut("vxe.error.errConflicts", ["tree-config", "checkbox-config.isShiftKey"]), Me.halfField && rn("vxe.error.delProp", ["checkbox-config.halfField", "checkbox-config.indeterminateField"]);
        }
        if (process.env.NODE_ENV === "development" && (e.editConfig && !U.insert && Ut("vxe.error.reqModule", ["Edit"]), e.editRules && !U.validate && Ut("vxe.error.reqModule", ["Validator"]), (Me.range || e.keyboardConfig || e.mouseConfig) && !U.triggerCellMousedownEvent && Ut("vxe.error.reqModule", ["Keyboard"]), (e.printConfig || e.importConfig || e.exportConfig) && !U.exportData && Ut("vxe.error.reqModule", ["Export"])), Object.assign(W, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0,
          adaptive: ie.adaptive !== !1
        }), Object.assign(k, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        }), To(f || []).then(() => {
          f && f.length && (d.inited = !0, d.initStatus = !0, vo(), go()), Kn();
        }), e.autoResize) {
          const Fe = dt.value, { refreshDelay: He } = Fe, et = v.value, Xe = w.getParentElem(), nt = He ? r.throttle(() => p.recalculate(!0), He, { leading: !0, trailing: !0 }) : null;
          oi = KN.create(nt ? () => {
            e.autoResize && nt();
          } : () => {
            e.autoResize && p.recalculate(!0);
          }), et && oi.observe(et), Xe && oi.observe(Xe);
        }
      }), An.on(U, "paste", vn), An.on(U, "copy", qn), An.on(U, "cut", Ro), An.on(U, "mousedown", Kt), An.on(U, "blur", Ft), An.on(U, "mousewheel", Je), An.on(U, "keydown", un), An.on(U, "resize", Ko), An.on(U, "contextmenu", U.handleGlobalContextmenuEvent), w.preventEvent(null, "mounted", { $table: U });
    }), window.aaaa = U, Us(() => {
      oi && oi.disconnect(), p.closeFilter(), U.closeMenu && U.closeMenu(), w.preventEvent(null, "beforeUnmount", { $table: U });
    }), $n(() => {
      An.off(U, "paste"), An.off(U, "copy"), An.off(U, "cut"), An.off(U, "mousedown"), An.off(U, "blur"), An.off(U, "mousewheel"), An.off(U, "keydown"), An.off(U, "resize"), An.off(U, "contextmenu"), w.preventEvent(null, "unmounted", { $table: U });
    }), process.env.NODE_ENV === "development" && me(() => {
      e.loading && !l && !n.loading && Ut("vxe.error.reqComp", ["vxe-loading"]), (e.showOverflow === !0 || e.showOverflow === "tooltip" || e.showHeaderOverflow === !0 || e.showHeaderOverflow === "tooltip" || e.showFooterOverflow === !0 || e.showFooterOverflow === "tooltip" || e.tooltipConfig || e.editRules) && (a || Ut("vxe.error.reqComp", ["vxe-tooltip"]));
    }), bn("$xeColgroup", null), bn("$xeTable", U), U.renderVN = db, U;
  },
  render() {
    return this.renderVN();
  }
});
function ZN(e) {
  const t = _(() => {
    const { renderParams: l } = e;
    return l.column;
  }), n = _(() => {
    const { renderParams: l } = e;
    return l.row;
  }), s = _(() => {
    const { renderOpts: l } = e;
    return l.props || {};
  }), i = _({
    get() {
      const { renderParams: l } = e, { row: a, column: c } = l;
      return r.get(a, c.field);
    },
    set(l) {
      const { renderParams: a } = e, { row: c, column: m } = a;
      return r.set(c, m.field, l);
    }
  });
  return {
    currColumn: t,
    currRow: n,
    cellModel: i,
    cellOptions: s
  };
}
const { renderer: Bp, hooks: JN } = Ce, QN = ["openFilter", "setFilter", "clearFilter", "saveFilterPanel", "resetFilterPanel", "getCheckedFilters", "updateFilterOptionStatus"];
JN.add("tableFilterModule", {
  setupTable(e) {
    const { props: t, reactData: n, internalData: s } = e, { refTableHeader: i, refTableBody: l, refTableFilter: a } = e.getRefMaps(), { computeFilterOpts: c, computeMouseOpts: m } = e.getComputeMaps(), u = (S) => {
      const { filterStore: x } = n;
      x.options.forEach((h) => {
        h.checked = h._checked;
      }), e.confirmFilterEvent(S);
    }, d = (S, x, h) => {
      const { filterStore: O } = n;
      O.options.forEach((g) => {
        g._checked = !1;
      }), h._checked = x, e.checkFilterOptions(), u(S);
    }, p = (S, x, h) => {
      h._checked = x, e.checkFilterOptions();
    }, w = (S) => {
      const { filterStore: x } = n;
      e.handleClearFilter(x.column), e.confirmFilterEvent(S);
    }, v = {
      checkFilterOptions() {
        const { filterStore: S } = n;
        S.isAllSelected = S.options.every((x) => x._checked), S.isIndeterminate = !S.isAllSelected && S.options.some((x) => x._checked);
      },
      /**
       * 点击筛选事件
       * 当筛选图标被点击时触发
       * 更新选项是否全部状态
       * 打开筛选面板
       * @param {Event} evnt 事件
       * @param {ColumnInfo} column 列配置
       * @param {Object} params 参数
       */
      triggerFilterEvent(S, x, h) {
        const { initStore: O, filterStore: g } = n;
        if (g.column === x && g.visible)
          g.visible = !1;
        else {
          const { target: b, pageX: E } = S, { visibleWidth: C } = qc(), { filters: V, filterMultiple: Q, filterRender: Z } = x, G = fn(Z) ? Bp.get(Z.name) : null, ue = x.filterRecoverMethod || (G ? G.tableFilterRecoverMethod || G.filterRecoverMethod : null);
          s._currFilterParams = h, Object.assign(g, {
            multiple: Q,
            options: V,
            column: x,
            style: null
          }), g.options.forEach((Y) => {
            const { _checked: K, checked: L } = Y;
            Y._checked = L, !L && K !== L && ue && ue({ option: Y, column: x, $table: e });
          }), this.checkFilterOptions(), g.visible = !0, O.filter = !0, me(() => {
            const Y = i.value, K = l.value, L = Y ? Y.$el : null, ye = K.$el;
            if (!ye)
              return;
            const se = a.value, P = se ? se.$el : null;
            if (!P)
              return;
            const M = P.offsetWidth, I = P.offsetHeight, B = P.querySelector(".vxe-table--filter-header"), H = P.querySelector(".vxe-table--filter-footer"), ce = M / 2, A = 10, j = ye.clientWidth - M - A;
            let fe, pe;
            const ne = {
              top: `${b.offsetTop + b.offsetParent.offsetTop + b.offsetHeight}px`
            };
            let $ = null;
            const J = ye.clientHeight - (L ? L.clientHeight / 2 : 0);
            if (I >= J && ($ = Math.max(40, J - (H ? H.offsetHeight : 0) - (B ? B.offsetHeight : 0))), x.fixed === "left" ? fe = b.offsetLeft + b.offsetParent.offsetLeft - ce : x.fixed === "right" ? pe = b.offsetParent.offsetWidth - b.offsetLeft + (b.offsetParent.offsetParent.offsetWidth - b.offsetParent.offsetLeft) - x.renderWidth - ce : fe = b.offsetLeft + b.offsetParent.offsetLeft - ce - ye.scrollLeft, fe) {
              const ge = E + M - ce + A - C;
              ge > 0 && (fe -= ge), ne.left = `${Math.min(j, Math.max(A, fe))}px`;
            } else if (pe) {
              const ge = E + M - ce + A - C;
              ge > 0 && (pe += ge), ne.right = `${Math.max(A, pe)}px`;
            }
            g.style = ne, g.maxHeight = $;
          });
        }
        e.dispatchEvent("filter-visible", { column: x, field: x.field, property: x.field, filterList: e.getCheckedFilters(), visible: g.visible }, S);
      },
      handleClearFilter(S) {
        if (S) {
          const { filters: x, filterRender: h } = S;
          if (x) {
            const O = fn(h) ? Bp.get(h.name) : null, g = S.filterResetMethod || (O ? O.tableFilterResetMethod || O.filterResetMethod : null);
            x.forEach((b) => {
              b._checked = !1, b.checked = !1, g || (b.data = r.clone(b.resetValue, !0));
            }), g && g({ options: x, column: S, $table: e });
          }
        }
      },
      /**
       * 确认筛选
       * 当筛选面板中的确定按钮被按下时触发
       * @param {Event} evnt 事件
       */
      confirmFilterEvent(S) {
        const { mouseConfig: x } = t, { filterStore: h, scrollXLoad: O, scrollYLoad: g } = n, b = c.value, E = m.value, { column: C } = h, { field: V } = C, Q = [], Z = [];
        C.filters.forEach((Y) => {
          Y.checked && (Q.push(Y.value), Z.push(Y.data));
        });
        const G = e.getCheckedFilters(), ue = { $table: e, $event: S, column: C, field: V, property: V, values: Q, datas: Z, filters: G, filterList: G };
        b.remote || (e.handleTableData(!0), e.checkSelectionStatus()), x && E.area && e.handleFilterEvent && e.handleFilterEvent(S, ue), S && e.dispatchEvent("filter-change", ue, S), e.closeFilter(), e.updateFooter().then(() => {
          const { scrollXLoad: Y, scrollYLoad: K } = n;
          if (O || Y || g || K)
            return (O || Y) && e.updateScrollXSpace(), (g || K) && e.updateScrollYSpace(), e.refreshScroll();
        }).then(() => (e.updateCellAreas(), e.recalculate(!0))).then(() => {
          setTimeout(() => e.recalculate(), 50);
        });
      },
      handleFilterChangeRadioOption: d,
      handleFilterChangeMultipleOption: p,
      // 筛选发生改变
      handleFilterChangeOption(S, x, h) {
        const { filterStore: O } = n;
        O.multiple ? p(S, x, h) : d(S, x, h);
      },
      handleFilterConfirmFilter: u,
      handleFilterResetFilter: w
    };
    return Object.assign(Object.assign({}, {
      /**
       * 手动弹出筛选面板
       * @param column
       */
      openFilter(S) {
        const x = io(e, S);
        if (x && x.filters) {
          const { elemStore: h } = s, { fixed: O } = x;
          return e.scrollToColumn(x).then(() => {
            const g = Ho(h[`${O || "main"}-header-wrapper`] || h["main-header-wrapper"]);
            if (g) {
              const b = g.querySelector(`.vxe-header--column.${x.id} .vxe-filter--btn`);
              wN(b, "click");
            }
          });
        }
        return me();
      },
      /**
       * 修改筛选条件列表
       * @param {ColumnInfo} fieldOrColumn 列或字段名
       * @param {Array} options 选项
       */
      setFilter(S, x) {
        const h = io(e, S);
        return h && h.filters && (h.filters = zh(x || [])), me();
      },
      /**
       * 清空指定列的筛选条件
       * 如果为空则清空所有列的筛选条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearFilter(S) {
        const { filterStore: x } = n, { tableFullColumn: h } = s, O = c.value;
        let g;
        return S ? (g = io(e, S), g && v.handleClearFilter(g)) : h.forEach(v.handleClearFilter), (!S || g !== x.column) && Object.assign(x, {
          isAllSelected: !1,
          isIndeterminate: !1,
          style: null,
          options: [],
          column: null,
          multiple: !1,
          visible: !1
        }), O.remote ? me() : e.updateData();
      },
      saveFilterPanel() {
        return u(null), me();
      },
      resetFilterPanel() {
        return w(null), me();
      },
      getCheckedFilters() {
        const { tableFullColumn: S } = s, x = [];
        return S.forEach((h) => {
          const { field: O, filters: g } = h, b = [], E = [];
          g && g.length && (g.forEach((C) => {
            C.checked && (b.push(C.value), E.push(C.data));
          }), b.length && x.push({ column: h, field: O, property: O, values: b, datas: E }));
        }), x;
      },
      updateFilterOptionStatus(S, x) {
        return S._checked = x, S.checked = x, me();
      }
    }), v);
  },
  setupGrid(e) {
    return e.extendTableMethods(QN);
  }
});
const { menus: eF, hooks: tF, globalEvents: ya, GLOBAL_EVENT_KEYS: Ca } = Ce, nF = ["closeMenu"];
tF.add("tableMenuModule", {
  setupTable(e) {
    const { xID: t, props: n, reactData: s, internalData: i } = e, { refElem: l, refTableFilter: a, refTableMenu: c } = e.getRefMaps(), { computeMouseOpts: m, computeIsMenu: u, computeMenuOpts: d } = e.getComputeMaps();
    let p = {}, w = {};
    const v = (D, S, x) => {
      const { ctxMenuStore: h } = s, O = u.value, g = d.value, b = g[S], E = g.visibleMethod;
      if (b) {
        const { options: C, disabled: V } = b;
        V ? D.preventDefault() : O && C && C.length && (x.options = C, e.preventEvent(D, "event.showMenu", x, () => {
          if (!E || E(x)) {
            D.preventDefault(), e.updateZindex();
            const { scrollTop: Q, scrollLeft: Z, visibleHeight: G, visibleWidth: ue } = qc();
            let Y = D.clientY + Q, K = D.clientX + Z;
            const L = () => {
              i._currMenuParams = x, Object.assign(h, {
                visible: !0,
                list: C,
                selected: null,
                selectChild: null,
                showChild: !1,
                style: {
                  zIndex: i.tZindex,
                  top: `${Y}px`,
                  left: `${K}px`
                }
              }), me(() => {
                const I = c.value.getRefMaps().refElem.value, B = I.clientHeight, H = I.clientWidth, { boundingTop: ce, boundingLeft: A } = Pa(I), j = ce + B - G, fe = A + H - ue;
                j > -10 && (h.style.top = `${Math.max(Q + 2, Y - B - 2)}px`), fe > -10 && (h.style.left = `${Math.max(Z + 2, K - H - 2)}px`);
              });
            }, { keyboard: ye, row: se, column: P } = x;
            ye && se && P ? e.scrollToRow(se, P).then(() => {
              const M = e.getCellElement(se, P);
              if (M) {
                const { boundingTop: I, boundingLeft: B } = Pa(M);
                Y = I + Q + Math.floor(M.offsetHeight / 2), K = B + Z + Math.floor(M.offsetWidth / 2);
              }
              L();
            }) : L();
          } else
            p.closeMenu();
        }));
      }
      e.closeFilter();
    };
    return p = {
      /**
       * 关闭快捷菜单
       */
      closeMenu() {
        return Object.assign(s.ctxMenuStore, {
          visible: !1,
          selected: null,
          selectChild: null,
          showChild: !1
        }), me();
      }
    }, w = {
      /**
       * 处理菜单的移动
       */
      moveCtxMenu(D, S, x, h, O, g) {
        let b;
        const E = r.findIndexOf(g, (C) => S[x] === C);
        if (h)
          O && Tl(S.selected) ? S.showChild = !0 : (S.showChild = !1, S.selectChild = null);
        else if (ya.hasKey(D, Ca.ARROW_UP)) {
          for (let C = E - 1; C >= 0; C--)
            if (g[C].visible !== !1) {
              b = g[C];
              break;
            }
          S[x] = b || g[g.length - 1];
        } else if (ya.hasKey(D, Ca.ARROW_DOWN)) {
          for (let C = E + 1; C < g.length; C++)
            if (g[C].visible !== !1) {
              b = g[C];
              break;
            }
          S[x] = b || g[0];
        } else S[x] && (ya.hasKey(D, Ca.ENTER) || ya.hasKey(D, Ca.SPACEBAR)) && w.ctxMenuLinkEvent(D, S[x]);
      },
      handleOpenMenuEvent: v,
      /**
       * 快捷菜单事件处理
       */
      handleGlobalContextmenuEvent(D) {
        const { mouseConfig: S, menuConfig: x } = n, { editStore: h, ctxMenuStore: O } = s, { visibleColumn: g } = i, b = a.value, E = c.value, C = m.value, V = d.value, Q = l.value, { selected: Z } = h, G = ["header", "body", "footer"];
        if (fn(x)) {
          if (O.visible && E && kn(D, E.getRefMaps().refElem.value).flag) {
            D.preventDefault();
            return;
          }
          if (i._keyCtx) {
            const ue = "body", Y = { type: ue, $table: e, keyboard: !0, columns: g.slice(0), $event: D };
            if (S && C.area) {
              const K = e.getActiveCellArea();
              if (K && K.row && K.column) {
                Y.row = K.row, Y.column = K.column, v(D, ue, Y);
                return;
              }
            } else if (S && C.selected && Z.row && Z.column) {
              Y.row = Z.row, Y.column = Z.column, v(D, ue, Y);
              return;
            }
          }
          for (let ue = 0; ue < G.length; ue++) {
            const Y = G[ue], K = kn(D, Q, `vxe-${Y}--column`, (ye) => ye.parentNode.parentNode.parentNode.getAttribute("xid") === t), L = { type: Y, $table: e, columns: g.slice(0), $event: D };
            if (K.flag) {
              const ye = K.targetElem, se = e.getColumnNode(ye), P = se ? se.item : null;
              let M = `${Y}-`;
              if (P && Object.assign(L, { column: P, columnIndex: e.getColumnIndex(P), cell: ye }), Y === "body") {
                const B = e.getRowNode(ye.parentNode), H = B ? B.item : null;
                M = "", H && (L.row = H, L.rowIndex = e.getRowIndex(H));
              }
              const I = `${M}cell-menu`;
              v(D, Y, L), e.dispatchEvent(I, L, D);
              return;
            } else if (kn(D, Q, `vxe-table--${Y}-wrapper`, (ye) => ye.getAttribute("xid") === t).flag) {
              V.trigger === "cell" ? D.preventDefault() : v(D, Y, L);
              return;
            }
          }
        }
        b && !kn(D, b.$el).flag && e.closeFilter(), p.closeMenu();
      },
      ctxMenuMouseoverEvent(D, S, x) {
        const h = D.currentTarget, { ctxMenuStore: O } = s;
        D.preventDefault(), D.stopPropagation(), O.selected = S, O.selectChild = x, x || (O.showChild = Tl(S), O.showChild && me(() => {
          const g = h.nextElementSibling;
          if (g) {
            const { boundingTop: b, boundingLeft: E, visibleHeight: C, visibleWidth: V } = Pa(h), Q = b + h.offsetHeight, Z = E + h.offsetWidth;
            let G = "", ue = "";
            Z + g.offsetWidth > V - 10 && (G = "auto", ue = `${h.offsetWidth}px`);
            let Y = "", K = "";
            Q + g.offsetHeight > C - 10 && (Y = "auto", K = "0"), g.style.left = G, g.style.right = ue, g.style.top = Y, g.style.bottom = K;
          }
        }));
      },
      ctxMenuMouseoutEvent(D, S) {
        const { ctxMenuStore: x } = s;
        S.children || (x.selected = null), x.selectChild = null;
      },
      /**
       * 快捷菜单点击事件
       */
      ctxMenuLinkEvent(D, S) {
        if (!S.disabled && (S.code || !S.children || !S.children.length)) {
          const x = eF.get(S.code), h = Object.assign({}, i._currMenuParams, { menu: S, $table: e, $grid: e.xegrid, $event: D }), O = x ? x.tableMenuMethod || x.menuMethod : null;
          O && O(h, D), e.dispatchEvent("menu-click", h, D), p.closeMenu();
        }
      }
    }, Object.assign(Object.assign({}, p), w);
  },
  setupGrid(e) {
    return e.extendTableMethods(nF);
  }
});
const { getConfig: oF, renderer: sF, hooks: rF, getI18n: _p } = Ce, lF = ["insert", "insertAt", "insertNextAt", "remove", "removeCheckboxRow", "removeRadioRow", "removeCurrentRow", "getRecordset", "getInsertRecords", "getRemoveRecords", "getUpdateRecords", "getEditRecord", "getActiveRecord", "getSelectedCell", "clearEdit", "clearActived", "clearSelected", "isEditByRow", "isActiveByRow", "setEditRow", "setActiveRow", "setEditCell", "setActiveCell", "setSelectCell"];
rF.add("tableEditModule", {
  setupTable(e) {
    const { props: t, reactData: n, internalData: s } = e, { refElem: i } = e.getRefMaps(), { computeMouseOpts: l, computeEditOpts: a, computeCheckboxOpts: c, computeTreeOpts: m, computeValidOpts: u } = e.getComputeMaps();
    let d = {}, p = {};
    const w = (g, b) => {
      const { model: E, editRender: C } = b;
      C && (E.value = Do(g, b), E.update = !1);
    }, v = (g, b) => {
      const { model: E, editRender: C } = b;
      C && E.update && (js(g, b, E.value), E.update = !1, E.value = null);
    }, D = () => {
      const g = i.value;
      if (g) {
        const b = g.querySelector(".col--selected");
        b && jo(b, "col--selected");
      }
    };
    function S() {
      const { editStore: g, tableColumn: b } = n, E = a.value, { actived: C } = g, { row: V, column: Q } = C;
      (V || Q) && (E.mode === "row" ? b.forEach((Z) => v(V, Z)) : v(V, Q));
    }
    function x(g, b) {
      const { tableFullTreeData: E, afterFullData: C, fullDataRowIdData: V, fullAllDataRowIdData: Q } = s, Z = m.value, { rowField: G, parentField: ue, mapChildrenField: Y } = Z, K = Z.children || Z.childrenField, L = b ? "push" : "unshift";
      g.forEach((ye) => {
        const se = ye[ue], P = yt(e, ye), M = se ? r.findTree(E, (I) => se === I[G], { children: Y }) : null;
        if (M) {
          const { item: I } = M, B = Q[yt(e, I)], H = B ? B.level : 0;
          let ce = I[K], A = I[Y];
          r.isArray(ce) || (ce = I[K] = []), r.isArray(A) || (A = I[K] = []), ce[L](ye), A[L](ye);
          const j = { row: ye, rowid: P, seq: -1, index: -1, _index: -1, $index: -1, items: ce, parent: I, level: H + 1, height: 0 };
          V[P] = j, Q[P] = j;
        } else {
          process.env.NODE_ENV === "development" && se && rn("vxe.error.unableInsert"), C[L](ye), E[L](ye);
          const I = { row: ye, rowid: P, seq: -1, index: -1, _index: -1, $index: -1, items: E, parent: null, level: 0, height: 0 };
          V[P] = I, Q[P] = I;
        }
      });
    }
    const h = (g, b, E) => {
      const { treeConfig: C } = t, { mergeList: V, editStore: Q } = n, { tableFullTreeData: Z, afterFullData: G, tableFullData: ue, fullDataRowIdData: Y, fullAllDataRowIdData: K } = s, L = m.value, { transform: ye, rowField: se, mapChildrenField: P } = L, M = L.children || L.childrenField;
      r.isArray(g) || (g = [g]);
      const I = Rt(e.defineField(g.map((H) => Object.assign(C && ye ? { [P]: [], [M]: [] } : {}, H))));
      if (r.eqNull(b))
        C && ye ? x(I, !1) : (I.forEach((H) => {
          const ce = yt(e, H), A = { row: H, rowid: ce, seq: -1, index: -1, _index: -1, $index: -1, items: G, parent: null, level: 0, height: 0 };
          Y[ce] = A, K[ce] = A, G.unshift(H), ue.unshift(H);
        }), V.forEach((H) => {
          const { row: ce } = H;
          ce > 0 && (H.row = ce + I.length);
        }));
      else if (b === -1)
        C && ye ? x(I, !0) : (I.forEach((H) => {
          const ce = yt(e, H), A = { row: H, rowid: ce, seq: -1, index: -1, _index: -1, $index: -1, items: G, parent: null, level: 0, height: 0 };
          Y[ce] = A, K[ce] = A, G.push(H), ue.push(H);
        }), V.forEach((H) => {
          const { row: ce, rowspan: A } = H;
          ce + A > G.length && (H.rowspan = A + I.length);
        }));
      else if (C && ye) {
        const H = r.findTree(Z, (ce) => b[se] === ce[se], { children: P });
        if (H) {
          const { parent: ce } = H, A = ce ? ce[P] : Z, j = K[yt(e, ce)], fe = j ? j.level : 0;
          if (I.forEach((pe, ne) => {
            const $ = yt(e, pe);
            process.env.NODE_ENV === "development" && pe[L.parentField] && ce && pe[L.parentField] !== ce[se] && Ut("vxe.error.errProp", [`${L.parentField}=${pe[L.parentField]}`, `${L.parentField}=${ce[se]}`]), ce && (pe[L.parentField] = ce[se]);
            let J = H.index + ne;
            E && (J = J + 1), A.splice(J, 0, pe);
            const ge = { row: pe, rowid: $, seq: -1, index: -1, _index: -1, $index: -1, items: A, parent: ce, level: fe + 1, height: 0 };
            Y[$] = ge, K[$] = ge;
          }), ce) {
            const pe = r.findTree(Z, (ne) => b[se] === ne[se], { children: M });
            if (pe) {
              const ne = pe.items;
              let $ = pe.index;
              E && ($ = $ + 1), ne.splice($, 0, ...I);
            }
          }
        } else
          process.env.NODE_ENV === "development" && rn("vxe.error.unableInsert"), x(I, !0);
      } else {
        if (C)
          throw new Error(_p("vxe.error.noTree", ["insert"]));
        let H = -1;
        if (r.isNumber(b) ? b < G.length && (H = b) : H = e.findRowIndexOf(G, b), E && (H = Math.min(G.length, H + 1)), H === -1)
          throw new Error(_p("vxe.error.unableInsert"));
        G.splice(H, 0, ...I), ue.splice(e.findRowIndexOf(ue, b), 0, ...I), V.forEach((ce) => {
          const { row: A, rowspan: j } = ce;
          A > H ? ce.row = A + I.length : A + j > H && (ce.rowspan = j + I.length);
        });
      }
      const { insertMaps: B } = Q;
      return I.forEach((H) => {
        const ce = yt(e, H);
        B[ce] = H;
      }), e.cacheRowMap(), e.updateScrollYStatus(), e.handleTableData(C && ye), C && ye || e.updateAfterDataIndex(), e.updateFooter(), e.checkSelectionStatus(), n.scrollYLoad && e.updateScrollYSpace(), me().then(() => (e.updateCellAreas(), e.recalculate())).then(() => ({
        row: I.length ? I[I.length - 1] : null,
        rows: I
      }));
    }, O = (g, b) => {
      const { mouseConfig: E } = t, { editStore: C } = n, { actived: V, focused: Q } = C, { row: Z, column: G } = V, ue = u.value, Y = l.value;
      if (Z || G) {
        if (b && yt(e, b) !== yt(e, Z))
          return me();
        S(), V.args = null, V.row = null, V.column = null, e.updateFooter(), e.dispatchEvent("edit-closed", {
          row: Z,
          rowIndex: e.getRowIndex(Z),
          $rowIndex: e.getVMRowIndex(Z),
          column: G,
          columnIndex: e.getColumnIndex(G),
          $columnIndex: e.getVMColumnIndex(G)
        }, g || null);
      }
      return me(() => {
        if (E && Y.area && e.handleRecalculateCellAreas)
          return e.handleRecalculateCellAreas();
      }), ue.autoClear && (ue.msgMode !== "full" || oF().cellVaildMode === "obsolete") && e.clearValidate ? e.clearValidate() : (Q.row = null, Q.column = null, me());
    };
    return d = {
      /**
       * 往表格中插入临时数据
       *
       * @param {*} records
       */
      insert(g) {
        return h(g, null);
      },
      /**
       * 往表格指定行中插入临时数据
       * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部
       * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部
       * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置
       * @param {Object/Array} records 新的数据
       * @param {Row} row 指定行
       */
      insertAt(g, b) {
        return h(g, b);
      },
      insertNextAt(g, b) {
        return h(g, b, !0);
      },
      /**
       * 删除指定行数据
       * 如果传 row 则删除一行
       * 如果传 rows 则删除多行
       * 如果为空则删除所有
       */
      remove(g) {
        const { treeConfig: b } = t, { mergeList: E, editStore: C, selectCheckboxMaps: V } = n, { tableFullTreeData: Q, afterFullData: Z, tableFullData: G } = s, ue = c.value, Y = m.value, { transform: K, mapChildrenField: L } = Y, ye = Y.children || Y.childrenField, { actived: se, removeMaps: P, insertMaps: M } = C, { checkField: I } = ue;
        let B = [];
        if (g ? r.isArray(g) || (g = [g]) : g = G, g.forEach((H) => {
          if (!e.isInsertByRow(H)) {
            const ce = yt(e, H);
            P[ce] = H;
          }
        }), !I) {
          const H = Object.assign({}, V);
          g.forEach((ce) => {
            const A = yt(e, ce);
            H[A] && delete H[A];
          }), n.selectCheckboxMaps = H;
        }
        return G === g ? (g = B = G.slice(0), s.tableFullData = [], s.afterFullData = [], e.clearMergeCells()) : b && K ? g.forEach((H) => {
          const ce = yt(e, H), A = r.findTree(Q, (pe) => ce === yt(e, pe), { children: L });
          if (A) {
            const pe = A.items.splice(A.index, 1);
            B.push(pe[0]);
          }
          const j = r.findTree(Q, (pe) => ce === yt(e, pe), { children: ye });
          j && j.items.splice(j.index, 1);
          const fe = e.findRowIndexOf(Z, H);
          fe > -1 && Z.splice(fe, 1);
        }) : g.forEach((H) => {
          const ce = e.findRowIndexOf(G, H);
          if (ce > -1) {
            const j = G.splice(ce, 1);
            B.push(j[0]);
          }
          const A = e.findRowIndexOf(Z, H);
          A > -1 && (E.forEach((j) => {
            const { row: fe, rowspan: pe } = j;
            fe > A ? j.row = fe - 1 : fe + pe > A && (j.rowspan = pe - 1);
          }), Z.splice(A, 1));
        }), se.row && e.findRowIndexOf(g, se.row) > -1 && d.clearEdit(), g.forEach((H) => {
          const ce = yt(e, H);
          M[ce] && delete M[ce];
        }), e.updateFooter(), e.cacheRowMap(), e.handleTableData(b && K), b && K || e.updateAfterDataIndex(), e.checkSelectionStatus(), n.scrollYLoad && e.updateScrollYSpace(), me().then(() => (e.updateCellAreas(), e.recalculate())).then(() => ({ row: B.length ? B[B.length - 1] : null, rows: B }));
      },
      /**
       * 删除复选框选中的数据
       */
      removeCheckboxRow() {
        return d.remove(e.getCheckboxRecords()).then((g) => (e.clearCheckboxRow(), g));
      },
      /**
       * 删除单选框选中的数据
       */
      removeRadioRow() {
        const g = e.getRadioRecord();
        return d.remove(g || []).then((b) => (e.clearRadioRow(), b));
      },
      /**
       * 删除当前行选中的数据
       */
      removeCurrentRow() {
        const g = e.getCurrentRecord();
        return d.remove(g || []).then((b) => (e.clearCurrentRow(), b));
      },
      /**
       * 获取表格数据集，包含新增、删除、修改、标记
       */
      getRecordset() {
        const g = d.getRemoveRecords(), b = e.getPendingRecords(), E = g.concat(b), C = d.getUpdateRecords().filter((V) => !E.some((Q) => e.eqRow(Q, V)));
        return {
          insertRecords: d.getInsertRecords(),
          removeRecords: g,
          updateRecords: C,
          pendingRecords: b
        };
      },
      /**
       * 获取新增的临时数据
       */
      getInsertRecords() {
        const { editStore: g } = n, { fullAllDataRowIdData: b } = s, { insertMaps: E } = g, C = [];
        return r.each(E, (V, Q) => {
          b[Q] && C.push(V);
        }), C;
      },
      /**
       * 获取已删除的数据
       */
      getRemoveRecords() {
        const { editStore: g } = n, { removeMaps: b } = g, E = [];
        return r.each(b, (C) => {
          E.push(C);
        }), E;
      },
      /**
       * 获取更新数据
       * 只精准匹配 row 的更改
       * 如果是树表格，子节点更改状态不会影响父节点的更新状态
       */
      getUpdateRecords() {
        const { keepSource: g, treeConfig: b } = t, { tableFullData: E } = s, C = m.value;
        return g ? (S(), b ? r.filterTree(E, (V) => e.isUpdateByRow(V), C) : E.filter((V) => e.isUpdateByRow(V))) : [];
      },
      getActiveRecord() {
        return process.env.NODE_ENV === "development" && rn("vxe.error.delFunc", ["getActiveRecord", "getEditRecord"]), this.getEditRecord();
      },
      getEditRecord() {
        const { editStore: g } = n, { afterFullData: b } = s, E = i.value, { args: C, row: V } = g.actived;
        return C && e.findRowIndexOf(b, V) > -1 && E.querySelectorAll(".vxe-body--column.col--active").length ? Object.assign({}, C) : null;
      },
      /**
       * 获取选中的单元格
       */
      getSelectedCell() {
        const { editStore: g } = n, { args: b, column: E } = g.selected;
        return b && E ? Object.assign({}, b) : null;
      },
      clearActived(g) {
        return process.env.NODE_ENV === "development" && rn("vxe.error.delFunc", ["clearActived", "clearEdit"]), this.clearEdit(g);
      },
      /**
       * 清除激活的编辑
       */
      clearEdit(g) {
        return O(null, g);
      },
      /**
       * 清除所选中源状态
       */
      clearSelected() {
        const { editStore: g } = n, { selected: b } = g;
        return b.row = null, b.column = null, D(), me();
      },
      isActiveByRow(g) {
        return process.env.NODE_ENV === "development" && rn("vxe.error.delFunc", ["isActiveByRow", "isEditByRow"]), this.isEditByRow(g);
      },
      /**
       * 判断行是否为激活编辑状态
       * @param {Row} row 行对象
       */
      isEditByRow(g) {
        const { editStore: b } = n;
        return b.actived.row === g;
      },
      setActiveRow(g) {
        return process.env.NODE_ENV === "development" && rn("vxe.error.delFunc", ["setActiveRow", "setEditRow"]), d.setEditRow(g);
      },
      /**
       * 激活行编辑
       */
      setEditRow(g, b) {
        const { visibleColumn: E } = s;
        let C = r.find(E, (V) => fn(V.editRender));
        return b && (C = r.isString(b) ? e.getColumnByField(b) : b), e.setEditCell(g, C);
      },
      setActiveCell(g, b) {
        return process.env.NODE_ENV === "development" && rn("vxe.error.delFunc", ["setActiveCell", "setEditCell"]), d.setEditCell(g, b);
      },
      /**
       * 激活单元格编辑
       */
      setEditCell(g, b) {
        const { editConfig: E } = t, C = r.isString(b) ? e.getColumnByField(b) : b;
        return g && C && fn(E) && fn(C.editRender) ? e.scrollToRow(g, C).then(() => {
          const V = e.getCellElement(g, C);
          return V && (p.handleEdit({
            row: g,
            rowIndex: e.getRowIndex(g),
            column: C,
            columnIndex: e.getColumnIndex(C),
            cell: V,
            $table: e
          }), s._lastCallTime = Date.now()), me();
        }) : me();
      },
      /**
       * 只对 trigger=dblclick 有效，选中单元格
       */
      setSelectCell(g, b) {
        const { tableData: E } = n, C = a.value, V = r.isString(b) ? e.getColumnByField(b) : b;
        if (g && V && C.trigger !== "manual") {
          const Q = e.findRowIndexOf(E, g);
          if (Q > -1 && V) {
            const Z = e.getCellElement(g, V), G = {
              row: g,
              rowIndex: Q,
              column: V,
              columnIndex: e.getColumnIndex(V),
              cell: Z
            };
            e.handleSelected(G, {});
          }
        }
        return me();
      }
    }, p = {
      /**
       * 处理激活编辑
       */
      handleEdit(g, b) {
        const { editConfig: E, mouseConfig: C } = t, { editStore: V, tableColumn: Q } = n, Z = a.value, { mode: G } = Z, { actived: ue, focused: Y } = V, { row: K, column: L } = g, { editRender: ye } = L, se = g.cell || e.getCellElement(K, L), P = Z.beforeEditMethod || Z.activeMethod;
        if (g.cell = se, se && fn(E) && fn(ye) && !e.isPendingByRow(K)) {
          if (ue.row !== K || G === "cell" && ue.column !== L) {
            let M = "edit-disabled";
            if (!P || P(Object.assign(Object.assign({}, g), { $table: e, $grid: e.xegrid }))) {
              C && (d.clearSelected(), e.clearCellAreas && (e.clearCellAreas(), e.clearCopyCellArea())), e.closeTooltip(), ue.column && O(b), M = "edit-activated", L.renderHeight = se.offsetHeight, ue.args = g, ue.row = K, ue.column = L, G === "row" ? Q.forEach((B) => w(K, B)) : w(K, L);
              const I = Z.afterEditMethod;
              me(() => {
                p.handleFocus(g, b), I && I(Object.assign(Object.assign({}, g), { $table: e, $grid: e.xegrid }));
              });
            }
            e.dispatchEvent(M, {
              row: K,
              rowIndex: e.getRowIndex(K),
              $rowIndex: e.getVMRowIndex(K),
              column: L,
              columnIndex: e.getColumnIndex(L),
              $columnIndex: e.getVMColumnIndex(L)
            }, b), M === "edit-activated" && e.dispatchEvent("edit-actived", {
              row: K,
              rowIndex: e.getRowIndex(K),
              $rowIndex: e.getVMRowIndex(K),
              column: L,
              columnIndex: e.getColumnIndex(L),
              $columnIndex: e.getVMColumnIndex(L)
            }, b);
          } else {
            const { column: M } = ue;
            if (C && (d.clearSelected(), e.clearCellAreas && (e.clearCellAreas(), e.clearCopyCellArea())), M !== L) {
              const { model: I } = M;
              I.update && js(K, M, I.value), e.clearValidate && e.clearValidate(K, L);
            }
            L.renderHeight = se.offsetHeight, ue.args = g, ue.column = L, setTimeout(() => {
              p.handleFocus(g, b);
            });
          }
          Y.column = null, Y.row = null, e.focus();
        }
        return me();
      },
      /**
       * @deprecated
       */
      handleActived(g, b) {
        return p.handleEdit(g, b);
      },
      /**
       * 处理取消编辑
       * @param evnt
       * @returns
       */
      handleClearEdit: O,
      /**
       * 处理聚焦
       */
      handleFocus(g) {
        const { row: b, column: E, cell: C } = g, { editRender: V } = E, Q = a.value;
        if (fn(V)) {
          const Z = sF.get(V.name);
          let G = V.autofocus || V.autoFocus, ue = V.autoSelect || V.autoselect, Y;
          if (Q.autoFocus && (!G && Z && (G = Z.tableAutoFocus || Z.tableAutofocus || Z.autofocus), !ue && Z && (ue = Z.tableAutoSelect || Z.autoselect), r.isFunction(G) ? Y = G(g) : G && (G === !0 ? Y = C.querySelector("input,textarea") : Y = C.querySelector(G), Y && Y.focus())), Y) {
            if (ue)
              Y.select();
            else if (Ml.msie) {
              const K = Y.createTextRange();
              K.collapse(!1), K.select();
            }
          } else
            Q.autoPos && (E.fixed || e.scrollToRow(b, E));
        }
      },
      /**
       * 处理选中源
       */
      handleSelected(g, b) {
        const { mouseConfig: E } = t, { editStore: C } = n, V = l.value, Q = a.value, { actived: Z, selected: G } = C, { row: ue, column: Y } = g, K = E && V.selected;
        return K && (G.row !== ue || G.column !== Y) && (Z.row !== ue || Q.mode === "cell" && Z.column !== Y) && (O(b), d.clearSelected(), e.clearCellAreas && (e.clearCellAreas(), e.clearCopyCellArea()), G.args = g, G.row = ue, G.column = Y, K && p.addCellSelectedClass(), e.focus(), b && e.dispatchEvent("cell-selected", g, b)), me();
      },
      addCellSelectedClass() {
        const { editStore: g } = n, { selected: b } = g, { row: E, column: C } = b;
        if (D(), E && C) {
          const V = e.getCellElement(E, C);
          V && Ms(V, "col--selected");
        }
      }
    }, Object.assign(Object.assign({}, d), p);
  },
  setupGrid(e) {
    return e.extendTableMethods(lF);
  }
});
const iF = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function aF(e, t) {
  return new Blob([e], { type: `text/${t.type};charset=utf-8;` });
}
function cF(e, t) {
  const { style: n } = e;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${e.sheetName}</title>`,
    '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>',
    `<style>${iF}</style>`,
    n ? `<style>${n}</style>` : "",
    "</head>",
    `<body>${t}</body>`,
    "</html>"
  ].join("");
}
const { getI18n: Ws, hooks: uF, renderer: ku } = Ce;
let xl;
const dF = "\uFEFF", Yr = `\r
`;
function Wp(e) {
  return e.property || ["seq", "checkbox", "radio"].indexOf(e.type) > -1;
}
const Xh = (e) => {
  const t = [];
  return e.forEach((n) => {
    n.childNodes && n.childNodes.length ? (t.push(n), t.push(...Xh(n.childNodes))) : t.push(n);
  }), t;
}, fF = (e) => {
  let t = 1;
  const n = (l, a) => {
    if (a && (l._level = a._level + 1, t < l._level && (t = l._level)), l.childNodes && l.childNodes.length) {
      let c = 0;
      l.childNodes.forEach((m) => {
        n(m, l), c += m._colSpan;
      }), l._colSpan = c;
    } else
      l._colSpan = 1;
  };
  e.forEach((l) => {
    l._level = 1, n(l);
  });
  const s = [];
  for (let l = 0; l < t; l++)
    s.push([]);
  return Xh(e).forEach((l) => {
    l.childNodes && l.childNodes.length ? l._rowSpan = 1 : l._rowSpan = t - l._level + 1, s[l._level - 1].push(l);
  }), s;
};
function pF(e) {
  return e === !0 ? "full" : e || "default";
}
function yl(e) {
  return e === "TRUE" || e === "true" || e === !0;
}
function wa(e, t) {
  const { footerFilterMethod: n } = e;
  return n ? t.filter((s, i) => n({ items: s, $rowIndex: i })) : t;
}
function mF(e, t) {
  if (t) {
    if (e.type === "seq")
      return `	${t}`;
    switch (e.cellType) {
      case "string":
        if (!isNaN(t))
          return `	${t}`;
        break;
      case "number":
        break;
      default:
        if (t.length >= 12 && !isNaN(t))
          return `	${t}`;
        break;
    }
  }
  return t;
}
function Cl(e) {
  return /[",\s\n]/.test(e) ? `"${e.replace(/"/g, '""')}"` : e;
}
function is(e, t) {
  return e.getElementsByTagName(t);
}
function zp(e) {
  return `#${e}@${r.uniqueId()}`;
}
function Zh(e, t) {
  return e.replace(/#\d+@\d+/g, (n) => r.hasOwnProp(t, n) ? t[n] : n);
}
function Hp(e, t) {
  return Zh(e, t).replace(/^"+$/g, (s) => '"'.repeat(Math.ceil(s.length / 2)));
}
function Jh(e, t, n) {
  const s = t.split(Yr), i = [];
  let l = [];
  if (s.length) {
    const a = {}, c = Date.now();
    s.forEach((m) => {
      if (m) {
        const u = {};
        m = m.replace(/("")|(\n)/g, (p, w) => {
          const v = zp(c);
          return a[v] = w ? '"' : `
`, v;
        }).replace(/"(.*?)"/g, (p, w) => {
          const v = zp(c);
          return a[v] = Zh(w, a), v;
        });
        const d = m.split(n);
        l.length ? (d.forEach((p, w) => {
          w < l.length && (u[l[w]] = Hp(p.trim(), a));
        }), i.push(u)) : l = d.map((p) => Hp(p.trim(), a));
      }
    });
  }
  return { fields: l, rows: i };
}
function gF(e, t) {
  return Jh(e, t, ",");
}
function hF(e, t) {
  return Jh(e, t, "	");
}
function vF(e, t) {
  const s = new DOMParser().parseFromString(t, "text/html"), i = is(s, "body"), l = [], a = [];
  if (i.length) {
    const c = is(i[0], "table");
    if (c.length) {
      const m = is(c[0], "thead");
      if (m.length) {
        r.arrayEach(is(m[0], "tr"), (d) => {
          r.arrayEach(is(d, "th"), (p) => {
            a.push(p.textContent);
          });
        });
        const u = is(c[0], "tbody");
        u.length && r.arrayEach(is(u[0], "tr"), (d) => {
          const p = {};
          r.arrayEach(is(d, "td"), (w, v) => {
            a[v] && (p[a[v]] = w.textContent || "");
          }), l.push(p);
        });
      }
    }
  }
  return { fields: a, rows: l };
}
function bF(e, t) {
  const s = new DOMParser().parseFromString(t, "application/xml"), i = is(s, "Worksheet"), l = [], a = [];
  if (i.length) {
    const c = is(i[0], "Table");
    if (c.length) {
      const m = is(c[0], "Row");
      m.length && (r.arrayEach(is(m[0], "Cell"), (u) => {
        a.push(u.textContent);
      }), r.arrayEach(m, (u, d) => {
        if (d) {
          const p = {}, w = is(u, "Cell");
          r.arrayEach(w, (v, D) => {
            a[D] && (p[a[D]] = v.textContent);
          }), l.push(p);
        }
      }));
    }
  }
  return { fields: a, rows: l };
}
function jp(e) {
  r.eachTree(e, (t) => {
    delete t._level, delete t._colSpan, delete t._rowSpan, delete t._children, delete t.childNodes;
  }, { children: "children" });
}
function xF(e, t) {
  const n = [];
  return e.forEach((s) => {
    const i = s.property;
    i && n.push(i);
  }), t.some((s) => n.indexOf(s) > -1);
}
const yF = ["exportData", "importByFile", "importData", "saveFile", "readFile", "print", "getPrintHtml", "openImport", "closeImport", "openExport", "closeExport", "openPrint", "closePrint"];
uF.add("tableExportModule", {
  setupTable(e) {
    const { props: t, reactData: n, internalData: s } = e, { computeTreeOpts: i, computePrintOpts: l, computeExportOpts: a, computeImportOpts: c, computeCustomOpts: m, computeSeqOpts: u, computeRadioOpts: d, computeCheckboxOpts: p, computeColumnOpts: w } = e.getComputeMaps(), v = mt("$xeGrid", null), D = (M) => {
      const I = i.value, B = I.children || I.childrenField;
      return M[B] && M[B].length;
    }, S = (M, I, B, H, ce) => {
      const j = u.value.seqMethod || H.seqMethod;
      return j ? j({
        row: I,
        rowIndex: e.getRowIndex(I),
        $rowIndex: B,
        column: H,
        columnIndex: e.getColumnIndex(H),
        $columnIndex: ce
      }) : M;
    };
    function x(M, I) {
      const B = w.value, H = I.headerExportMethod || B.headerExportMethod;
      return H ? H({ column: I, options: M, $table: e }) : (M.original ? I.property : I.getTitle()) || "";
    }
    const h = (M) => r.isBoolean(M) ? M ? "TRUE" : "FALSE" : M, O = (M, I, B) => {
      const { isAllExpand: H, mode: ce } = M, { treeConfig: A } = t, j = d.value, fe = p.value, pe = i.value, ne = w.value;
      if (xl || (xl = document.createElement("div")), A) {
        const $ = pe.children || pe.childrenField, J = [], ge = /* @__PURE__ */ new Map();
        return r.eachTree(B, (Oe, Se, de, Ie, je, Ue) => {
          const Ae = Oe._row || Oe, _e = je && je._row ? je._row : je;
          if (H || !_e || ge.has(_e) && e.isTreeExpandByRow(_e)) {
            const it = D(Ae), vt = {
              _row: Ae,
              _level: Ue.length - 1,
              _hasChild: it,
              _expand: it && e.isTreeExpandByRow(Ae)
            };
            I.forEach((dt, at) => {
              let Et = "";
              const Qe = dt.editRender || dt.cellRender;
              let De = dt.exportMethod || ne.exportMethod;
              if (!De && Qe && Qe.name) {
                const Re = ku.get(Qe.name);
                Re && (De = Re.tableExportMethod || Re.exportMethod);
              }
              if (De || (De = ne.exportMethod), De)
                Et = De({ $table: e, row: Ae, column: dt, options: M });
              else
                switch (dt.type) {
                  case "seq": {
                    const Re = Ie.map((Be, ve) => ve % 2 === 0 ? Number(Be) + 1 : ".").join("");
                    Et = ce === "all" ? Re : S(Re, Ae, Se, dt, at);
                    break;
                  }
                  case "checkbox":
                    Et = h(e.isCheckedByCheckboxRow(Ae)), vt._checkboxLabel = fe.labelField ? r.get(Ae, fe.labelField) : "", vt._checkboxDisabled = fe.checkMethod && !fe.checkMethod({ row: Ae });
                    break;
                  case "radio":
                    Et = h(e.isCheckedByRadioRow(Ae)), vt._radioLabel = j.labelField ? r.get(Ae, j.labelField) : "", vt._radioDisabled = j.checkMethod && !j.checkMethod({ row: Ae });
                    break;
                  default:
                    if (M.original)
                      Et = Do(Ae, dt);
                    else if (Et = `${e.getCellLabel(Ae, dt)}`, dt.type === "html")
                      xl.innerHTML = Et, Et = xl.innerText.trim();
                    else {
                      const Re = e.getCellElement(Ae, dt);
                      Re && (Et = Re.innerText.trim());
                    }
                }
              vt[dt.id] = r.toValueString(Et);
            }), ge.set(Ae, 1), J.push(Object.assign(vt, Ae));
          }
        }, { children: $ }), J;
      }
      return B.map(($, J) => {
        const ge = {
          _row: $
        };
        return I.forEach((Oe, Se) => {
          let de = "";
          const Ie = Oe.editRender || Oe.cellRender;
          let je = Oe.exportMethod || ne.exportMethod;
          if (!je && Ie && Ie.name) {
            const Ue = ku.get(Ie.name);
            Ue && (je = Ue.exportMethod);
          }
          if (je)
            de = je({ $table: e, row: $, column: Oe, options: M });
          else
            switch (Oe.type) {
              case "seq": {
                const Ue = J + 1;
                de = ce === "all" ? Ue : S(Ue, $, J, Oe, Se);
                break;
              }
              case "checkbox":
                de = h(e.isCheckedByCheckboxRow($)), ge._checkboxLabel = fe.labelField ? r.get($, fe.labelField) : "", ge._checkboxDisabled = fe.checkMethod && !fe.checkMethod({ row: $ });
                break;
              case "radio":
                de = h(e.isCheckedByRadioRow($)), ge._radioLabel = j.labelField ? r.get($, j.labelField) : "", ge._radioDisabled = j.checkMethod && !j.checkMethod({ row: $ });
                break;
              default:
                if (M.original)
                  de = Do($, Oe);
                else if (de = `${e.getCellLabel($, Oe)}`, Oe.type === "html")
                  xl.innerHTML = de, de = xl.innerText.trim();
                else {
                  const Ue = e.getCellElement($, Oe);
                  Ue && (de = Ue.innerText.trim());
                }
            }
          ge[Oe.id] = r.toValueString(de);
        }), ge;
      });
    }, g = (M) => {
      const { columns: I, dataFilterMethod: B } = M;
      let H = M.data;
      return B && (H = H.filter((ce, A) => B({ row: ce, $rowIndex: A }))), O(M, I, H);
    }, b = (M, I, B) => {
      const H = w.value, ce = B.editRender || B.cellRender;
      let A = B.footerExportMethod;
      if (!A && ce && ce.name) {
        const fe = ku.get(ce.name);
        fe && (A = fe.tableFooterExportMethod || fe.footerExportMethod);
      }
      A || (A = H.footerExportMethod);
      const j = e.getVTColumnIndex(B);
      return A ? A({ $table: e, items: I, itemIndex: j, row: I, _columnIndex: j, column: B, options: M }) : r.isArray(I) ? r.toValueString(I[j]) : r.get(I, B.field);
    }, E = (M, I, B) => {
      let H = dF;
      if (M.isHeader && (H += I.map((ce) => Cl(x(M, ce))).join(",") + Yr), B.forEach((ce) => {
        H += I.map((A) => Cl(mF(A, ce[A.id]))).join(",") + Yr;
      }), M.isFooter) {
        const { footerTableData: ce } = n;
        wa(M, ce).forEach((j) => {
          H += I.map((fe) => Cl(b(M, j, fe))).join(",") + Yr;
        });
      }
      return H;
    }, C = (M, I, B) => {
      let H = "";
      if (M.isHeader && (H += I.map((ce) => Cl(x(M, ce))).join("	") + Yr), B.forEach((ce) => {
        H += I.map((A) => Cl(ce[A.id])).join("	") + Yr;
      }), M.isFooter) {
        const { footerTableData: ce } = n;
        wa(M, ce).forEach((j) => {
          H += I.map((fe) => Cl(b(M, j, fe))).join("	") + Yr;
        });
      }
      return H;
    }, V = (M, I, B) => {
      const H = M[I], ce = r.isUndefined(H) || r.isNull(H) ? B : H;
      let pe = ce === "title" || (ce === !0 || ce === "tooltip") || ce === "ellipsis";
      const { scrollXLoad: ne, scrollYLoad: $ } = n;
      return (ne || $) && !pe && (pe = !0), pe;
    }, Q = (M, I, B) => {
      const { id: H, border: ce, treeConfig: A, headerAlign: j, align: fe, footerAlign: pe, showOverflow: ne, showHeaderOverflow: $ } = t, { isAllSelected: J, isIndeterminate: ge, mergeList: Oe } = n, Se = i.value, { print: de, isHeader: Ie, isFooter: je, isColgroup: Ue, isMerge: Ae, colgroups: _e, original: it } = M, vt = "check-all", at = [
        `<table class="${[
          "vxe-table",
          `border--${pF(ce)}`,
          de ? "is--print" : "",
          Ie ? "is--header" : ""
        ].filter((Qe) => Qe).join(" ")}" border="0" cellspacing="0" cellpadding="0">`,
        `<colgroup>${I.map((Qe) => `<col style="width:${Qe.renderWidth}px">`).join("")}</colgroup>`
      ];
      if (Ie && (at.push("<thead>"), Ue && !it ? _e.forEach((Qe) => {
        at.push(`<tr>${Qe.map((De) => {
          const Re = De.headerAlign || De.align || j || fe, Be = V(De, "showHeaderOverflow", $) ? ["col--ellipsis"] : [], ve = x(M, De);
          let Ne = 0, q = 0;
          r.eachTree([De], (R) => {
            (!R.childNodes || !De.childNodes.length) && q++, Ne += R.renderWidth;
          }, { children: "childNodes" });
          const z = Ne - q;
          return Re && Be.push(`col--${Re}`), De.type === "checkbox" ? `<th class="${Be.join(" ")}" colspan="${De._colSpan}" rowspan="${De._rowSpan}"><div ${de ? "" : `style="width: ${z}px"`}><input type="checkbox" class="${vt}" ${J ? "checked" : ""}><span>${ve}</span></div></th>` : `<th class="${Be.join(" ")}" colspan="${De._colSpan}" rowspan="${De._rowSpan}" title="${ve}"><div ${de ? "" : `style="width: ${z}px"`}><span>${po(ve, !0)}</span></div></th>`;
        }).join("")}</tr>`);
      }) : at.push(`<tr>${I.map((Qe) => {
        const De = Qe.headerAlign || Qe.align || j || fe, Re = V(Qe, "showHeaderOverflow", $) ? ["col--ellipsis"] : [], Be = x(M, Qe);
        return De && Re.push(`col--${De}`), Qe.type === "checkbox" ? `<th class="${Re.join(" ")}"><div ${de ? "" : `style="width: ${Qe.renderWidth}px"`}><input type="checkbox" class="${vt}" ${J ? "checked" : ""}><span>${Be}</span></div></th>` : `<th class="${Re.join(" ")}" title="${Be}"><div ${de ? "" : `style="width: ${Qe.renderWidth}px"`}><span>${po(Be, !0)}</span></div></th>`;
      }).join("")}</tr>`), at.push("</thead>")), B.length && (at.push("<tbody>"), A ? B.forEach((Qe) => {
        at.push("<tr>" + I.map((De) => {
          const Re = De.align || fe, Be = V(De, "showOverflow", ne) ? ["col--ellipsis"] : [], ve = Qe[De.id];
          if (Re && Be.push(`col--${Re}`), De.treeNode) {
            let Ne = "";
            return Qe._hasChild && (Ne = `<i class="${Qe._expand ? "vxe-table--tree-fold-icon" : "vxe-table--tree-unfold-icon"}"></i>`), Be.push("vxe-table--tree-node"), De.type === "radio" ? `<td class="${Be.join(" ")}" title="${ve}"><div ${de ? "" : `style="width: ${De.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${Qe._level * Se.indent}px"><div class="vxe-table--tree-icon-wrapper">${Ne}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${H}" ${Qe._radioDisabled ? "disabled " : ""}${yl(ve) ? "checked" : ""}><span>${Qe._radioLabel}</span></div></div></div></td>` : De.type === "checkbox" ? `<td class="${Be.join(" ")}" title="${ve}"><div ${de ? "" : `style="width: ${De.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${Qe._level * Se.indent}px"><div class="vxe-table--tree-icon-wrapper">${Ne}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${Qe._checkboxDisabled ? "disabled " : ""}${yl(ve) ? "checked" : ""}><span>${Qe._checkboxLabel}</span></div></div></div></td>` : `<td class="${Be.join(" ")}" title="${ve}"><div ${de ? "" : `style="width: ${De.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${Qe._level * Se.indent}px"><div class="vxe-table--tree-icon-wrapper">${Ne}</div><div class="vxe-table--tree-cell">${ve}</div></div></div></td>`;
          }
          return De.type === "radio" ? `<td class="${Be.join(" ")}"><div ${de ? "" : `style="width: ${De.renderWidth}px"`}><input type="radio" name="radio_${H}" ${Qe._radioDisabled ? "disabled " : ""}${yl(ve) ? "checked" : ""}><span>${Qe._radioLabel}</span></div></td>` : De.type === "checkbox" ? `<td class="${Be.join(" ")}"><div ${de ? "" : `style="width: ${De.renderWidth}px"`}><input type="checkbox" ${Qe._checkboxDisabled ? "disabled " : ""}${yl(ve) ? "checked" : ""}><span>${Qe._checkboxLabel}</span></div></td>` : `<td class="${Be.join(" ")}" title="${ve}"><div ${de ? "" : `style="width: ${De.renderWidth}px"`}>${po(ve, !0)}</div></td>`;
        }).join("") + "</tr>");
      }) : B.forEach((Qe) => {
        at.push("<tr>" + I.map((De) => {
          const Re = De.align || fe, Be = V(De, "showOverflow", ne) ? ["col--ellipsis"] : [], ve = Qe[De.id];
          let Ne = 1, q = 1;
          if (Ae && Oe.length) {
            const z = e.getVTRowIndex(Qe._row), R = e.getVTColumnIndex(De), le = Uh(Oe, z, R);
            if (le) {
              const { rowspan: F, colspan: re } = le;
              if (!F || !re)
                return "";
              F > 1 && (Ne = F), re > 1 && (q = re);
            }
          }
          return Re && Be.push(`col--${Re}`), De.type === "radio" ? `<td class="${Be.join(" ")}" rowspan="${Ne}" colspan="${q}"><div ${de ? "" : `style="width: ${De.renderWidth}px"`}><input type="radio" name="radio_${H}" ${Qe._radioDisabled ? "disabled " : ""}${yl(ve) ? "checked" : ""}><span>${Qe._radioLabel}</span></div></td>` : De.type === "checkbox" ? `<td class="${Be.join(" ")}" rowspan="${Ne}" colspan="${q}"><div ${de ? "" : `style="width: ${De.renderWidth}px"`}><input type="checkbox" ${Qe._checkboxDisabled ? "disabled " : ""}${yl(ve) ? "checked" : ""}><span>${Qe._checkboxLabel}</span></div></td>` : `<td class="${Be.join(" ")}" rowspan="${Ne}" colspan="${q}" title="${ve}"><div ${de ? "" : `style="width: ${De.renderWidth}px"`}>${po(ve, !0)}</div></td>`;
        }).join("") + "</tr>");
      }), at.push("</tbody>")), je) {
        const { footerTableData: Qe } = n, De = wa(M, Qe);
        De.length && (at.push("<tfoot>"), De.forEach((Re) => {
          at.push(`<tr>${I.map((Be) => {
            const ve = Be.footerAlign || Be.align || pe || fe, Ne = V(Be, "showOverflow", ne) ? ["col--ellipsis"] : [], q = b(M, Re, Be);
            return ve && Ne.push(`col--${ve}`), `<td class="${Ne.join(" ")}" title="${q}"><div ${de ? "" : `style="width: ${Be.renderWidth}px"`}>${po(q, !0)}</div></td>`;
          }).join("")}</tr>`);
        }), at.push("</tfoot>"));
      }
      const Et = !J && ge ? `<script>(function(){var a=document.querySelector(".${vt}");if(a){a.indeterminate=true}})()<\/script>` : "";
      return at.push("</table>", Et), de ? at.join("") : cF(M, at.join(""));
    }, Z = (M, I, B) => {
      let H = [
        '<?xml version="1.0"?>',
        '<?mso-application progid="Excel.Sheet"?>',
        '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">',
        '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">',
        "<Version>16.00</Version>",
        "</DocumentProperties>",
        '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">',
        "<WindowHeight>7920</WindowHeight>",
        "<WindowWidth>21570</WindowWidth>",
        "<WindowTopX>32767</WindowTopX>",
        "<WindowTopY>32767</WindowTopY>",
        "<ProtectStructure>False</ProtectStructure>",
        "<ProtectWindows>False</ProtectWindows>",
        "</ExcelWorkbook>",
        `<Worksheet ss:Name="${M.sheetName}">`,
        "<Table>",
        I.map((ce) => `<Column ss:Width="${ce.renderWidth}"/>`).join("")
      ].join("");
      if (M.isHeader && (H += `<Row>${I.map((ce) => `<Cell><Data ss:Type="String">${x(M, ce)}</Data></Cell>`).join("")}</Row>`), B.forEach((ce) => {
        H += "<Row>" + I.map((A) => `<Cell><Data ss:Type="String">${ce[A.id]}</Data></Cell>`).join("") + "</Row>";
      }), M.isFooter) {
        const { footerTableData: ce } = n;
        wa(M, ce).forEach((j) => {
          H += `<Row>${I.map((fe) => `<Cell><Data ss:Type="String">${b(M, j, fe)}</Data></Cell>`).join("")}</Row>`;
        });
      }
      return `${H}</Table></Worksheet></Workbook>`;
    }, G = (M, I, B) => {
      if (I.length)
        switch (M.type) {
          case "csv":
            return E(M, I, B);
          case "txt":
            return C(M, I, B);
          case "html":
            return Q(M, I, B);
          case "xml":
            return Z(M, I, B);
        }
      return "";
    }, ue = (M, I) => {
      const { filename: B, type: H, download: ce } = M;
      if (!ce) {
        const A = aF(I, M);
        return Promise.resolve({ type: H, content: I, blob: A });
      }
      Ce.saveFile && Ce.saveFile({ filename: B, type: H, content: I }).then(() => {
        M.message !== !1 && Ce.modal && Ce.modal.message({ content: Ws("vxe.table.expSuccess"), status: "success" });
      });
    }, Y = (M) => {
      const { remote: I, columns: B, colgroups: H, exportMethod: ce, afterExportMethod: A } = M;
      return new Promise((j) => {
        if (I) {
          const fe = { options: M, $table: e, $grid: v };
          j(ce ? ce(fe) : fe);
        } else {
          const fe = g(M);
          j(e.preventEvent(null, "event.export", { options: M, columns: B, colgroups: H, datas: fe }, () => ue(M, G(M, B, fe))));
        }
      }).then((j) => (jp(B), M.print || A && A({ status: !0, options: M, $table: e, $grid: v }), Object.assign({ status: !0 }, j))).catch(() => {
        jp(B), M.print || A && A({ status: !1, options: M, $table: e, $grid: v });
        const j = { status: !1 };
        return Promise.reject(j);
      });
    }, K = (M, I) => {
      const { tableFullColumn: B, _importResolve: H, _importReject: ce } = s;
      let A = { fields: [], rows: [] };
      switch (I.type) {
        case "csv":
          A = gF(B, M);
          break;
        case "txt":
          A = hF(B, M);
          break;
        case "html":
          A = vF(B, M);
          break;
        case "xml":
          A = bF(B, M);
          break;
      }
      const { fields: j, rows: fe } = A;
      xF(B, j) ? e.createData(fe).then((ne) => {
        let $;
        return (I.mode === "insert" || I.mode === "insertBottom") && ($ = e.insertAt(ne, -1)), I.mode === "insertTop" ? $ = e.insert(ne) : $ = e.reloadData(ne), I.message !== !1 && Ce.modal && Ce.modal.message({ content: Ws("vxe.table.impSuccess", [fe.length]), status: "success" }), $.then(() => {
          H && H({ status: !0 });
        });
      }) : I.message !== !1 && (Ce.modal && Ce.modal.message({ content: Ws("vxe.error.impFields"), status: "error" }), ce && ce({ status: !1 }));
    }, L = (M, I) => {
      const { importMethod: B, afterImportMethod: H } = I, { type: ce, filename: A } = $h(M), j = c.value;
      if (!B && !r.includes(r.keys(j._typeMaps), ce)) {
        I.message !== !1 && Ce.modal && Ce.modal.message({ content: Ws("vxe.error.notType", [ce]), status: "error" });
        const pe = { status: !1 };
        return Promise.reject(pe);
      }
      return new Promise((pe, ne) => {
        const $ = (ge) => {
          pe(ge), s._importResolve = null, s._importReject = null;
        }, J = (ge) => {
          ne(ge), s._importResolve = null, s._importReject = null;
        };
        if (s._importResolve = $, s._importReject = J, window.FileReader) {
          const ge = Object.assign({ mode: "insertTop" }, I, { type: ce, filename: A });
          if (ge.remote)
            B ? Promise.resolve(B({ file: M, options: ge, $table: e })).then(() => {
              $({ status: !0 });
            }).catch(() => {
              $({ status: !0 });
            }) : $({ status: !0 });
          else {
            const { tableFullColumn: Oe } = s;
            e.preventEvent(null, "event.import", { file: M, options: ge, columns: Oe }, () => {
              const Se = new FileReader();
              Se.onerror = () => {
                Ut("vxe.error.notType", [ce]), J({ status: !1 });
              }, Se.onload = (de) => {
                K(de.target.result, ge);
              }, Se.readAsText(M, ge.encoding || "UTF-8");
            });
          }
        } else
          process.env.NODE_ENV === "development" && Ut("vxe.error.notExp"), $({ status: !0 });
      }).then(() => {
        H && H({ status: !0, options: I, $table: e });
      }).catch((pe) => (H && H({ status: !1, options: I, $table: e }), Promise.reject(pe)));
    }, ye = (M, I) => {
      const { treeConfig: B, showHeader: H, showFooter: ce } = t, { initStore: A, mergeList: j, isGroup: fe, footerTableData: pe, exportStore: ne, exportParams: $ } = n, { collectColumn: J } = s, ge = a.value, Oe = B, Se = m.value, de = e.getCheckboxRecords(), Ie = v ? v.getComputeMaps().computeProxyOpts.value : {}, je = !!pe.length, Ue = !Oe && j.length, Ae = Object.assign({
        message: !0,
        isHeader: H,
        isFooter: ce,
        current: "current",
        modes: ["current", "selected"].concat(Ie.ajax && Ie.ajax.queryAll ? ["all"] : [])
      }, M), _e = Ae.types || r.keys(ge._typeMaps), it = Ae.modes || [], vt = Se.checkMethod, dt = J.slice(0), { columns: at } = Ae, Et = _e.map((De) => ({
        value: De,
        label: Ws(`vxe.export.types.${De}`)
      })), Qe = it.map((De) => De && De.value ? {
        value: De.value,
        label: De.label || De.value
      } : {
        value: De,
        label: Ws(`vxe.export.modes.${De}`)
      });
      return r.eachTree(dt, (De, Re, Be, ve, Ne) => {
        (De.children && De.children.length || Wp(De)) && (De.checked = at ? at.some((z) => {
          if (ka(z))
            return De === z;
          if (r.isString(z))
            return De.field === z;
          {
            const R = z.id || z.colId, le = z.type, F = z.property || z.field;
            if (R)
              return De.id === R;
            if (F && le)
              return De.property === F && De.type === le;
            if (F)
              return De.property === F;
            if (le)
              return De.type === le;
          }
          return !1;
        }) : De.visible, De.halfChecked = !1, De.disabled = Ne && Ne.disabled || (vt ? !vt({ column: De }) : !1));
      }), Object.assign(ne, {
        columns: dt,
        typeList: Et,
        modeList: Qe,
        hasFooter: je,
        hasMerge: Ue,
        hasTree: Oe,
        isPrint: I,
        hasColgroup: fe,
        visible: !0
      }), Object.assign($, {
        mode: de.length ? "selected" : "current"
      }, Ae), Qe.some((De) => De.value === $.mode) || ($.mode = Qe[0].value), Et.some((De) => De.value === $.type) || ($.type = Et[0].value), A.export = !0, me();
    }, se = () => Ce.modal ? Ce.modal.close("VXE_EXPORT_MODAL") : Promise.resolve(), P = {
      /**
       * 导出文件，支持 csv/html/xml/txt
       * 如果是树表格，则默认是导出所有节点
       * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据
       * @param {Object} options 参数
       */
      exportData(M) {
        const { treeConfig: I } = t, { isGroup: B, tableGroupColumn: H } = n, { tableFullColumn: ce, afterFullData: A } = s, j = a.value, fe = i.value, pe = Object.assign({
          // filename: '',
          // sheetName: '',
          // original: false,
          // message: false,
          isHeader: !0,
          isFooter: !0,
          isColgroup: !0,
          // isMerge: false,
          // isAllExpand: false,
          download: !0,
          type: "csv",
          mode: "current"
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, j, {
          print: !1
        }, M), { type: ne, mode: $, columns: J, original: ge, beforeExportMethod: Oe } = pe;
        let Se = [];
        const de = J && J.length ? J : null;
        let Ie = pe.columnFilterMethod;
        !de && !Ie && (Ie = ge ? ({ column: Ue }) => Ue.property : ({ column: Ue }) => Wp(Ue)), de ? (pe._isCustomColumn = !0, Se = r.searchTree(r.mapTree(de, (Ue) => {
          let Ae;
          if (Ue) {
            if (ka(Ue))
              Ae = Ue;
            else if (r.isString(Ue))
              Ae = e.getColumnByField(Ue);
            else {
              const _e = Ue.id || Ue.colId, it = Ue.type, vt = Ue.property || Ue.field;
              _e ? Ae = e.getColumnById(_e) : vt && it ? Ae = ce.find((dt) => dt.property === vt && dt.type === it) : vt ? Ae = e.getColumnByField(vt) : it && (Ae = ce.find((dt) => dt.type === it));
            }
            return Ae || {};
          }
        }, {
          children: "childNodes",
          mapChildren: "_children"
        }), (Ue, Ae) => ka(Ue) && (!Ie || Ie({ column: Ue, $columnIndex: Ae })), {
          children: "_children",
          mapChildren: "childNodes",
          original: !0
        })) : Se = r.searchTree(B ? H : ce, (Ue, Ae) => Ue.visible && (!Ie || Ie({ column: Ue, $columnIndex: Ae })), { children: "children", mapChildren: "childNodes", original: !0 });
        const je = [];
        if (r.eachTree(Se, (Ue) => {
          Ue.children && Ue.children.length || je.push(Ue);
        }, { children: "childNodes" }), pe.columns = je, pe.colgroups = fF(Se), pe.filename || (pe.filename = Ws(pe.original ? "vxe.table.expOriginFilename" : "vxe.table.expFilename", [r.toDateString(Date.now(), "yyyyMMddHHmmss")])), pe.sheetName || (pe.sheetName = document.title), !pe.exportMethod && !r.includes(r.keys(j._typeMaps), ne)) {
          Ut("vxe.error.notType", [ne]), process.env.NODE_ENV === "development" && ["xlsx", "pdf"].includes(ne) && rn("vxe.error.reqPlugin", [4, "plugin-export-xlsx"]);
          const Ue = { status: !1 };
          return Promise.reject(Ue);
        }
        if (pe.print || Oe && Oe({ options: pe, $table: e, $grid: v }), !pe.data)
          if (pe.data = [], $ === "selected") {
            const Ue = e.getCheckboxRecords();
            ["html", "pdf"].indexOf(ne) > -1 && I ? pe.data = r.searchTree(e.getTableData().fullData, (Ae) => e.findRowIndexOf(Ue, Ae) > -1, Object.assign({}, fe, { data: "_row" })) : pe.data = Ue;
          } else if ($ === "all") {
            if (process.env.NODE_ENV === "development" && (v || rn("vxe.error.errProp", ["all", "mode=current,selected"])), v && !pe.remote) {
              const { reactData: Ue } = v, { computeProxyOpts: Ae } = v.getComputeMaps(), { sortData: _e } = Ue, it = Ae.value, { beforeQueryAll: vt, afterQueryAll: dt, ajax: at = {}, props: Et = {} } = it, Qe = at.queryAll, De = at.queryAllSuccess, Re = at.queryAllError;
              if (process.env.NODE_ENV === "development" && (Qe || rn("vxe.error.notFunc", ["proxy-config.ajax.queryAll"])), Qe) {
                const Be = {
                  $table: e,
                  $grid: v,
                  sort: _e.length ? _e[0] : {},
                  sorts: _e,
                  filters: Ue.filterData,
                  form: Ue.formData,
                  options: pe
                };
                return Promise.resolve((vt || Qe)(Be)).then((ve) => (pe.data = (Et.list ? r.get(ve, Et.list) : ve) || [], dt && dt(Be), De && De(Object.assign(Object.assign({}, Be), { response: ve })), Y(pe))).catch((ve) => {
                  Re && Re(Object.assign(Object.assign({}, Be), { response: ve }));
                });
              }
            }
          } else $ === "current" && (pe.data = A);
        return Y(pe);
      },
      importByFile(M, I) {
        const B = Object.assign({}, I), { beforeImportMethod: H } = B;
        return H && H({ options: B, $table: e }), L(M, B);
      },
      importData(M) {
        const I = c.value, B = Object.assign({
          types: r.keys(I._typeMaps)
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, I, M), { beforeImportMethod: H, afterImportMethod: ce } = B;
        return H && H({ options: B, $table: e }), Ce.readFile(B).catch((A) => (ce && ce({ status: !1, options: B, $table: e }), Promise.reject(A))).then((A) => {
          const { file: j } = A;
          return L(j, B);
        });
      },
      saveFile(M) {
        return Ce.saveFile(M);
      },
      readFile(M) {
        return Ce.readFile(M);
      },
      print(M) {
        const I = l.value, B = Object.assign({
          original: !1
          // beforePrintMethod
        }, I, M, {
          type: "html",
          download: !1,
          remote: !1,
          print: !0
        });
        B.sheetName || (B.sheetName = document.title);
        const H = B.beforePrintMethod, ce = B.html || B.content;
        return new Promise((A, j) => {
          Ce.print ? A(ce ? Ce.print({
            title: B.sheetName,
            html: ce,
            customStyle: B.style,
            beforeMethod: H ? ({ html: fe }) => H({
              html: fe,
              content: fe,
              options: B,
              $table: e
            }) : void 0
          }) : P.exportData(B).then(({ content: fe }) => Ce.print({
            title: B.sheetName,
            html: fe,
            customStyle: B.style,
            beforeMethod: H ? ({ html: pe }) => H({
              html: pe,
              content: pe,
              options: B,
              $table: e
            }) : void 0
          }))) : j({ status: !1 });
        });
      },
      getPrintHtml(M) {
        const I = l.value, B = Object.assign({
          original: !1
          // beforePrintMethod
        }, I, M, {
          type: "html",
          download: !1,
          remote: !1,
          print: !0
        });
        return P.exportData(B).then(({ content: H }) => ({
          html: H
        }));
      },
      closeImport() {
        return Ce.modal ? Ce.modal.close("VXE_IMPORT_MODAL") : Promise.resolve();
      },
      openImport(M) {
        const { treeConfig: I, importConfig: B } = t, { initStore: H, importStore: ce, importParams: A } = n, j = c.value, fe = Object.assign({
          mode: "insertTop",
          message: !0,
          types: r.keys(j._typeMaps),
          modes: ["insertTop", "covering"]
        }, j, M), pe = fe.types || [], ne = fe.modes || [];
        if (!!I) {
          fe.message && Ce.modal && Ce.modal.message({ content: Ws("vxe.error.treeNotImp"), status: "error" });
          return;
        }
        B || Ut("vxe.error.reqProp", ["import-config"]);
        const J = pe.map((Oe) => ({
          value: Oe,
          label: Ws(`vxe.export.types.${Oe}`)
        })), ge = ne.map((Oe) => Oe && Oe.value ? {
          value: Oe.value,
          label: Oe.label || Oe.value
        } : {
          value: Oe,
          label: Ws(`vxe.import.modes.${Oe}`)
        });
        Object.assign(ce, {
          file: null,
          type: "",
          filename: "",
          modeList: ge,
          typeList: J,
          visible: !0
        }), Object.assign(A, fe), ge.some((Oe) => Oe.value === A.mode) || (A.mode = ge[0].value), H.import = !0;
      },
      closeExport: se,
      openExport(M) {
        const I = a.value, B = Object.assign({
          message: !0,
          types: r.keys(I._typeMaps)
        }, I, M);
        process.env.NODE_ENV === "development" && (t.exportConfig || Ut("vxe.error.reqProp", ["export-config"])), ye(B);
      },
      closePrint: se,
      openPrint(M) {
        const I = l.value, B = Object.assign({
          message: !0
        }, I, M);
        process.env.NODE_ENV === "development" && (t.printConfig || Ut("vxe.error.reqProp", ["print-config"])), ye(B, !0);
      }
    };
    return P;
  },
  setupGrid(e) {
    return e.extendTableMethods(yF);
  }
});
const { hooks: CF } = Ce;
function wF(e, t) {
  let n = 0, s = 0;
  const i = !Ml.firefox && sl(e, "vxe-checkbox--label");
  if (i) {
    const l = getComputedStyle(e);
    n -= r.toNumber(l.paddingTop), s -= r.toNumber(l.paddingLeft);
  }
  for (; e && e !== t; )
    if (n += e.offsetTop, s += e.offsetLeft, e = e.offsetParent, i) {
      const l = getComputedStyle(e);
      n -= r.toNumber(l.paddingTop), s -= r.toNumber(l.paddingLeft);
    }
  return { offsetTop: n, offsetLeft: s };
}
CF.add("tableKeyboardModule", {
  setupTable(e) {
    const { props: t, reactData: n, internalData: s } = e, { refElem: i } = e.getRefMaps(), { computeEditOpts: l, computeCheckboxOpts: a, computeMouseOpts: c, computeTreeOpts: m } = e.getComputeMaps();
    function u(v, D, S, x, h, O) {
      let g = 0, b = [], E = 0;
      const C = O > 0, { scrollYLoad: V } = n, { afterFullData: Q, scrollYStore: Z } = s;
      if (V) {
        C ? E = h + O : E = x.height - h + Math.abs(O);
        const G = e.getVTRowIndex(D.row);
        C ? b = Q.slice(G, G + Math.ceil(E / Z.rowHeight)) : b = Q.slice(G - Math.floor(E / Z.rowHeight), G + 1);
      } else {
        C ? E = v.clientY - x.y : E = x.y - v.clientY + x.height;
        const G = C ? "next" : "previous";
        for (; S && g < E; ) {
          const ue = e.getRowNode(S);
          ue && (b.push(ue.item), g += S.offsetHeight, S = S[`${G}ElementSibling`]);
        }
      }
      return b;
    }
    const d = (v, D) => {
      const { column: S, cell: x } = D;
      if (S.type === "checkbox") {
        const h = i.value, { elemStore: O } = s, g = v.clientX, b = v.clientY, E = Ho(O[`${S.fixed || "main"}-body-wrapper`] || O["main-body-wrapper"]);
        if (!E)
          return;
        const C = E.querySelector(".vxe-table--checkbox-range"), V = document.onmousemove, Q = document.onmouseup, Z = x.parentElement, G = e.getCheckboxRecords();
        let ue = [];
        const Y = 1, K = wF(v.target, E), L = K.offsetTop + v.offsetY, ye = K.offsetLeft + v.offsetX, se = E.scrollTop, P = Z.offsetHeight, M = Z.getBoundingClientRect(), I = b - M.y;
        let B = null, H = !1, ce = 1;
        const A = (ne, $) => {
          e.dispatchEvent(`checkbox-range-${ne}`, { records: e.getCheckboxRecords(), reserves: e.getCheckboxReserveRecords() }, $);
        }, j = (ne) => {
          const { clientX: $, clientY: J } = ne, ge = $ - g, Oe = J - b + (E.scrollTop - se);
          let Se = Math.abs(Oe), de = Math.abs(ge), Ie = L, je = ye;
          Oe < Y ? (Ie += Oe, Ie < Y && (Ie = Y, Se = L)) : Se = Math.min(Se, E.scrollHeight - L - Y), ge < Y ? (je += ge, de > ye && (je = Y, de = ye)) : de = Math.min(de, E.clientWidth - ye - Y), C.style.height = `${Se}px`, C.style.width = `${de}px`, C.style.left = `${je}px`, C.style.top = `${Ie}px`, C.style.display = "block";
          const Ue = u(ne, D, Z, M, I, Oe < Y ? -Se : Se);
          Se > 10 && Ue.length !== ue.length && (ue = Ue, ne.ctrlKey ? Ue.forEach((Ae) => {
            e.handleSelectRow({ row: Ae }, G.indexOf(Ae) === -1);
          }) : (e.setAllCheckboxRow(!1), e.handleCheckedCheckboxRow(Ue, !0, !1)), A("change", ne));
        }, fe = () => {
          clearTimeout(B), B = null;
        }, pe = (ne) => {
          fe(), B = setTimeout(() => {
            if (B) {
              const { scrollLeft: $, scrollTop: J, clientHeight: ge, scrollHeight: Oe } = E, Se = Math.ceil(ce * 50 / P);
              H ? J + ge < Oe ? (e.scrollTo($, J + Se), pe(ne), j(ne)) : fe() : J ? (e.scrollTo($, J - Se), pe(ne), j(ne)) : fe();
            }
          }, 50);
        };
        Ms(h, "drag--range"), document.onmousemove = (ne) => {
          ne.preventDefault(), ne.stopPropagation();
          const { clientY: $ } = ne, { boundingTop: J } = Pa(E);
          $ < J ? (H = !1, ce = J - $, B || pe(ne)) : $ > J + E.clientHeight ? (H = !0, ce = $ - J - E.clientHeight, B || pe(ne)) : B && fe(), j(ne);
        }, document.onmouseup = (ne) => {
          fe(), jo(h, "drag--range"), C.removeAttribute("style"), document.onmousemove = V, document.onmouseup = Q, A("end", ne);
        }, A("start", v);
      }
    }, p = (v, D) => {
      const { editConfig: S, checkboxConfig: x, mouseConfig: h } = t, O = a.value, g = c.value, b = l.value;
      if (h && g.area && e.handleMousedownCellAreaEvent)
        return e.handleMousedownCellAreaEvent(v, D);
      x && O.range && d(v, D), h && g.selected && (!S || b.mode === "cell") && e.handleSelected(D, v);
    };
    return {
      // 处理 Tab 键移动
      moveTabSelected(v, D, S) {
        const { editConfig: x } = t, { afterFullData: h, visibleColumn: O } = s, g = l.value;
        let b, E, C;
        const V = Object.assign({}, v), Q = e.getVTRowIndex(V.row), Z = e.getVTColumnIndex(V.column);
        S.preventDefault(), D ? Z <= 0 ? Q > 0 && (E = Q - 1, b = h[E], C = O.length - 1) : C = Z - 1 : Z >= O.length - 1 ? Q < h.length - 1 && (E = Q + 1, b = h[E], C = 0) : C = Z + 1;
        const G = O[C];
        G && (b ? (V.rowIndex = E, V.row = b) : V.rowIndex = Q, V.columnIndex = C, V.column = G, V.cell = e.getCellElement(V.row, V.column), x ? (g.trigger === "click" || g.trigger === "dblclick") && (g.mode === "row" ? e.handleEdit(V, S) : e.scrollToRow(V.row, V.column).then(() => e.handleSelected(V, S))) : e.scrollToRow(V.row, V.column).then(() => e.handleSelected(V, S)));
      },
      // 处理当前行方向键移动
      moveCurrentRow(v, D, S) {
        const { treeConfig: x } = t, { currentRow: h } = n, { afterFullData: O } = s, g = m.value, b = g.children || g.childrenField;
        let E;
        if (S.preventDefault(), h)
          if (x) {
            const { index: C, items: V } = r.findTree(O, (Q) => Q === h, { children: b });
            v && C > 0 ? E = V[C - 1] : D && C < V.length - 1 && (E = V[C + 1]);
          } else {
            const C = e.getVTRowIndex(h);
            v && C > 0 ? E = O[C - 1] : D && C < O.length - 1 && (E = O[C + 1]);
          }
        else
          E = O[0];
        if (E) {
          const C = {
            $table: e,
            row: E,
            rowIndex: e.getRowIndex(E),
            $rowIndex: e.getVMRowIndex(E)
          };
          e.scrollToRow(E).then(() => e.triggerCurrentRowEvent(S, C));
        }
      },
      // 处理可编辑方向键移动
      moveSelected(v, D, S, x, h, O) {
        const { afterFullData: g, visibleColumn: b } = s, E = Object.assign({}, v), C = e.getVTRowIndex(E.row), V = e.getVTColumnIndex(E.column);
        O.preventDefault(), S && C > 0 ? (E.rowIndex = C - 1, E.row = g[E.rowIndex]) : h && C < g.length - 1 ? (E.rowIndex = C + 1, E.row = g[E.rowIndex]) : D && V ? (E.columnIndex = V - 1, E.column = b[E.columnIndex]) : x && V < b.length - 1 && (E.columnIndex = V + 1, E.column = b[E.columnIndex]), e.scrollToRow(E.row, E.column).then(() => {
          E.cell = e.getCellElement(E.row, E.column), e.handleSelected(E, O);
        });
      },
      /**
       * 表头单元格按下事件
       */
      triggerHeaderCellMousedownEvent(v, D) {
        const { mouseConfig: S } = t, x = c.value;
        if (S && x.area && e.handleHeaderCellAreaEvent) {
          const h = v.currentTarget, O = kn(v, h, "vxe-cell--sort").flag, g = kn(v, h, "vxe-cell--filter").flag;
          e.handleHeaderCellAreaEvent(v, Object.assign({ cell: h, triggerSort: O, triggerFilter: g }, D));
        }
        e.focus(), e.closeMenu && e.closeMenu();
      },
      /**
       * 单元格按下事件
       */
      triggerCellMousedownEvent(v, D) {
        const S = v.currentTarget;
        D.cell = S, p(v, D), e.focus(), e.closeFilter(), e.closeMenu && e.closeMenu();
      }
    };
  }
});
const { getConfig: EF, validators: SF, hooks: DF } = Ce;
let vi = class {
  constructor(t) {
    Object.assign(this, {
      $options: t,
      required: t.required,
      min: t.min,
      max: t.max,
      type: t.type,
      pattern: t.pattern,
      validator: t.validator,
      trigger: t.trigger,
      maxWidth: t.maxWidth
    });
  }
  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  get content() {
    return fr(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
const OF = ["fullValidate", "validate", "fullValidateField", "validateField", "clearValidate"];
DF.add("tableValidatorModule", {
  setupTable(e) {
    const { props: t, reactData: n, internalData: s } = e, { refValidTooltip: i } = e.getRefMaps(), { computeValidOpts: l, computeTreeOpts: a, computeEditOpts: c } = e.getComputeMaps();
    let m = {}, u = {}, d;
    const p = (S) => new Promise((x) => {
      l.value.autoPos === !1 ? (e.dispatchEvent("valid-error", S, null), x()) : e.handleEdit(S, { type: "valid-error", trigger: "call" }).then(() => {
        x(u.showValidTooltip(S));
      });
    }), w = (S) => {
      if (l.value.msgMode === "single") {
        const h = Object.keys(S), O = {};
        if (h.length) {
          const g = h[0];
          O[g] = S[g];
        }
        return O;
      }
      return S;
    }, v = (S, x, h, O) => {
      const g = {}, { editRules: b, treeConfig: E } = t, { afterFullData: C, visibleColumn: V } = s, Q = a.value, Z = Q.children || Q.childrenField, G = l.value;
      let ue;
      S === !0 ? ue = C : S && (r.isFunction(S) ? h = S : ue = r.isArray(S) ? S : [S]), ue || (e.getInsertRecords ? ue = e.getInsertRecords().concat(e.getUpdateRecords()) : ue = []);
      const Y = [];
      s._lastCallTime = Date.now(), d = !1, m.clearValidate();
      const K = {};
      if (b) {
        const L = x && x.length ? x : e.getColumns(), ye = (se) => {
          if (O || !d) {
            const P = [];
            L.forEach((M) => {
              const I = r.isString(M) ? M : M.field;
              (O || !d) && r.has(b, I) && P.push(u.validCellRules("all", se, M).catch(({ rule: B, rules: H }) => {
                const ce = {
                  rule: B,
                  rules: H,
                  rowIndex: e.getRowIndex(se),
                  row: se,
                  columnIndex: e.getColumnIndex(M),
                  column: M,
                  field: I,
                  $table: e
                };
                if (g[I] || (g[I] = []), K[`${yt(e, se)}:${M.id}`] = {
                  column: M,
                  row: se,
                  rule: B,
                  content: B.content
                }, g[I].push(ce), !O)
                  return d = !0, Promise.reject(ce);
              }));
            }), Y.push(Promise.all(P));
          }
        };
        return E ? r.eachTree(ue, ye, { children: Z }) : ue.forEach(ye), Promise.all(Y).then(() => {
          const se = Object.keys(g);
          return n.validErrorMaps = w(K), me().then(() => {
            if (se.length)
              return Promise.reject(g[se[0]][0]);
            h && h();
          });
        }).catch((se) => new Promise((P, M) => {
          const I = () => {
            me(() => {
              h ? (h(g), P()) : EF().validToReject === "obsolete" ? M(g) : P(g);
            });
          }, B = () => {
            se.cell = e.getCellElement(se.row, se.column), CN(se.cell), p(se).then(I);
          };
          if (G.autoPos === !1)
            I();
          else {
            const H = se.row, ce = se.column, A = C.indexOf(H), j = V.indexOf(ce), fe = A > 0 ? C[A - 1] : H, pe = j > 0 ? V[j - 1] : ce;
            e.scrollToRow(fe, pe).then(B);
          }
        }));
      } else
        n.validErrorMaps = {};
      return me().then(() => {
        h && h();
      });
    };
    m = {
      /**
       * 完整校验行，和 validate 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidate(S, x) {
        return process.env.NODE_ENV === "development" && r.isFunction(x) && rn("vxe.error.notValidators", ["fullValidate(rows, callback)", "fullValidate(rows)"]), v(S, null, x, !0);
      },
      /**
       * 快速校验行，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validate(S, x) {
        return v(S, null, x);
      },
      /**
       * 完整校验单元格，和 validateField 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidateField(S, x) {
        const h = (r.isArray(x) ? x : x ? [x] : []).map((O) => io(e, O));
        return h.length ? v(S, h, null, !0) : me();
      },
      /**
       * 快速校验单元格，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validateField(S, x) {
        const h = (r.isArray(x) ? x : x ? [x] : []).map((O) => io(e, O));
        return h.length ? v(S, h, null) : me();
      },
      clearValidate(S, x) {
        const { validErrorMaps: h } = n, O = i.value, g = l.value, b = r.isArray(S) ? S : S ? [S] : [], E = (r.isArray(x) ? x : x ? [x] : []).map((V) => io(e, V));
        let C = {};
        if (O && O.reactData.visible && O.close(), g.msgMode === "single")
          return n.validErrorMaps = {}, me();
        if (b.length && E.length)
          C = Object.assign({}, h), b.forEach((V) => {
            E.forEach((Q) => {
              const Z = `${yt(e, V)}:${Q.id}`;
              C[Z] && delete C[Z];
            });
          });
        else if (b.length) {
          const V = b.map((Q) => `${yt(e, Q)}`);
          r.each(h, (Q, Z) => {
            V.indexOf(Z.split(":")[0]) > -1 && (C[Z] = Q);
          });
        } else if (E.length) {
          const V = E.map((Q) => `${Q.id}`);
          r.each(h, (Q, Z) => {
            V.indexOf(Z.split(":")[1]) > -1 && (C[Z] = Q);
          });
        }
        return n.validErrorMaps = C, me();
      }
    };
    const D = (S, x) => {
      const { type: h, min: O, max: g, pattern: b } = S, E = h === "number", C = E ? r.toNumber(x) : r.getSize(x);
      return !!(E && isNaN(x) || !r.eqNull(O) && C < r.toNumber(O) || !r.eqNull(g) && C > r.toNumber(g) || b && !(r.isRegExp(b) ? b : new RegExp(b)).test(x));
    };
    return u = {
      /**
       * 校验数据
       * 按表格行、列顺序依次校验（同步或异步）
       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
       * 如果是传回调方式这返回一个校验不通过列的错误消息
       *
       * rule 配置：
       *  required=Boolean 是否必填
       *  min=Number 最小长度
       *  max=Number 最大长度
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
       */
      validCellRules(S, x, h, O) {
        const { editRules: g } = t, { field: b } = h, E = [], C = [];
        if (b && g) {
          const V = r.get(g, b);
          if (V) {
            const Q = r.isUndefined(O) ? r.get(x, b) : O;
            V.forEach((Z) => {
              const { type: G, trigger: ue, required: Y, validator: K } = Z;
              if (S === "all" || !ue || S === ue)
                if (K) {
                  const L = {
                    cellValue: Q,
                    rule: Z,
                    rules: V,
                    row: x,
                    rowIndex: e.getRowIndex(x),
                    column: h,
                    columnIndex: e.getColumnIndex(h),
                    field: h.field,
                    $table: e,
                    $grid: e.xegrid
                  };
                  let ye;
                  if (r.isString(K)) {
                    const se = SF.get(K);
                    if (se) {
                      const P = se.tableCellValidatorMethod || se.cellValidatorMethod;
                      P ? ye = P(L) : process.env.NODE_ENV === "development" && rn("vxe.error.notValidators", [K]);
                    } else
                      process.env.NODE_ENV === "development" && Ut("vxe.error.notValidators", [K]);
                  } else
                    ye = K(L);
                  ye && (r.isError(ye) ? (d = !0, E.push(new vi({ type: "custom", trigger: ue, content: ye.message, rule: new vi(Z) }))) : ye.catch && C.push(ye.catch((se) => {
                    d = !0, E.push(new vi({ type: "custom", trigger: ue, content: se && se.message ? se.message : Z.content || Z.message, rule: new vi(Z) }));
                  })));
                } else {
                  const L = G === "array", ye = r.isArray(Q);
                  let se = !0;
                  L || ye ? se = !ye || !Q.length : r.isString(Q) ? se = cr(Q.trim()) : se = cr(Q), (Y ? se || D(Z, Q) : !se && D(Z, Q)) && (d = !0, E.push(new vi(Z)));
                }
            });
          }
        }
        return Promise.all(C).then(() => {
          if (E.length) {
            const V = { rules: E, rule: E[0] };
            return Promise.reject(V);
          }
        });
      },
      hasCellRules(S, x, h) {
        const { editRules: O } = t, { field: g } = h;
        if (g && O) {
          const b = r.get(O, g);
          return b && !!r.find(b, (E) => S === "all" || !E.trigger || S === E.trigger);
        }
        return !1;
      },
      /**
       * 触发校验
       */
      triggerValidate(S) {
        const { editConfig: x, editRules: h } = t, { editStore: O } = n, { actived: g } = O, b = c.value, E = l.value;
        if (h && E.msgMode === "single" && (n.validErrorMaps = {}), x && h && g.row) {
          const { row: C, column: V, cell: Q } = g.args;
          if (u.hasCellRules(S, C, V))
            return u.validCellRules(S, C, V).then(() => {
              b.mode === "row" && m.clearValidate(C, V);
            }).catch(({ rule: Z }) => {
              if (!Z.trigger || S === Z.trigger) {
                const G = { rule: Z, row: C, column: V, cell: Q };
                return u.showValidTooltip(G), Promise.reject(G);
              }
              return Promise.resolve();
            });
        }
        return Promise.resolve();
      },
      /**
       * 弹出校验错误提示
       */
      showValidTooltip(S) {
        const { height: x } = t, { tableData: h, validStore: O, validErrorMaps: g } = n, { rule: b, row: E, column: C, cell: V } = S, Q = l.value, Z = i.value, G = b.content;
        return O.visible = !0, Q.msgMode === "single" ? n.validErrorMaps = {
          [`${yt(e, E)}:${C.id}`]: {
            column: C,
            row: E,
            rule: b,
            content: G
          }
        } : n.validErrorMaps = Object.assign({}, g, {
          [`${yt(e, E)}:${C.id}`]: {
            column: C,
            row: E,
            rule: b,
            content: G
          }
        }), e.dispatchEvent("valid-error", S, null), Z && Z && (Q.message === "tooltip" || Q.message === "default" && !x && h.length < 2) ? Z.open(V, G) : me();
      }
    }, Object.assign(Object.assign({}, m), u);
  },
  setupGrid(e) {
    return e.extendTableMethods(OF);
  }
});
const TF = ["openCustom", "closeCustom", "saveCustom", "cancelCustom", "resetCustom", "toggleCustomAllCheckbox", "setCustomAllCheckbox"];
Ce.hooks.add("tableCustomModule", {
  setupTable(e) {
    const { reactData: t, internalData: n } = e, { computeCustomOpts: s } = e.getComputeMaps(), { refElem: i } = e.getRefMaps(), l = e.xegrid, a = () => {
      const { customStore: x } = t, h = i.value;
      let O = 0;
      h && (O = h.clientHeight - 28), x.maxHeight = Math.max(88, O);
    }, c = () => {
      const { initStore: x, customStore: h } = t, { collectColumn: O } = n, g = {}, b = {}, E = {};
      return r.eachTree(O, (C) => {
        const V = C.getKey();
        C.renderFixed = C.fixed, C.renderVisible = C.visible, C.renderResizeWidth = C.renderWidth, g[V] = C.renderSortNumber, b[V] = C.fixed, E[V] = C.visible;
      }, { children: "children" }), h.oldSortMaps = g, h.oldFixedMaps = b, h.oldVisibleMaps = E, t.customColumnList = O.slice(0), h.visible = !0, x.custom = !0, v(), a(), me().then(() => a());
    }, m = () => {
      const { customStore: x } = t, h = s.value;
      return x.visible && (x.visible = !1, h.immediate || e.handleCustom()), me();
    }, u = () => {
      const { customColumnList: x } = t, h = s.value, { allowVisible: O, allowSort: g, allowFixed: b, allowResizable: E } = h;
      return r.eachTree(x, (C, V, Q, Z, G) => {
        if (G)
          C.fixed = G.fixed;
        else {
          if (g) {
            const ue = V + 1;
            C.renderSortNumber = ue;
          }
          b && (C.fixed = C.renderFixed);
        }
        E && C.renderVisible && (!C.children || C.children.length) && C.renderResizeWidth !== C.renderWidth && (C.resizeWidth = C.renderResizeWidth, C.renderWidth = C.renderResizeWidth), O && (C.visible = C.renderVisible);
      }), t.isCustomStatus = !0, t.isDragColMove = !0, setTimeout(() => {
        t.isDragColMove = !1;
      }, 1e3), e.saveCustomStore("confirm");
    }, d = () => {
      const { customColumnList: x, customStore: h } = t, { oldSortMaps: O, oldFixedMaps: g, oldVisibleMaps: b } = h, E = s.value, { allowVisible: C, allowSort: V, allowFixed: Q, allowResizable: Z } = E;
      return r.eachTree(x, (G) => {
        const ue = G.getKey(), Y = !!b[ue], K = g[ue] || "";
        C && (G.renderVisible = Y, G.visible = Y), Q && (G.renderFixed = K, G.fixed = K), V && (G.renderSortNumber = O[ue] || 0), Z && (G.renderResizeWidth = G.renderWidth);
      }, { children: "children" }), me();
    }, p = (x) => {
      const { customStore: h } = t, { customColumnList: O } = t, g = s.value, { checkMethod: b, visibleMethod: E } = g, C = !!x;
      return g.immediate ? (r.eachTree(O, (V) => {
        E && !E({ column: V }) || b && !b({ column: V }) || (V.visible = C, V.renderVisible = C, V.halfVisible = !1);
      }), h.isAll = C, e.handleCustom(), e.saveCustomStore("update:visible")) : (r.eachTree(O, (V) => {
        E && !E({ column: V }) || b && !b({ column: V }) || (V.renderVisible = C, V.halfVisible = !1);
      }), h.isAll = C), e.checkCustomStatus(), me();
    }, w = {
      openCustom: c,
      closeCustom: m,
      saveCustom: u,
      cancelCustom: d,
      resetCustom(x) {
        const { collectColumn: h } = n, O = s.value, { checkMethod: g } = O, b = Object.assign({
          visible: !0,
          resizable: x === !0,
          fixed: x === !0,
          sort: x === !0
        }, x);
        return r.eachTree(h, (E) => {
          b.resizable && (E.resizeWidth = 0), b.fixed && (E.fixed = E.defaultFixed), b.sort && (E.renderSortNumber = E.sortNumber), (!g || g({ column: E })) && (E.visible = E.defaultVisible), E.renderResizeWidth = E.renderWidth;
        }), t.isCustomStatus = !1, e.saveCustomStore("reset"), e.handleCustom();
      },
      toggleCustomAllCheckbox() {
        const { customStore: x } = t, h = !x.isAll;
        return p(h);
      },
      setCustomAllCheckbox: p
    }, v = () => {
      const { customStore: x } = t, { collectColumn: h } = n, O = s.value, { checkMethod: g } = O;
      x.isAll = h.every((b) => (g ? !g({ column: b }) : !1) || b.renderVisible), x.isIndeterminate = !x.isAll && h.some((b) => (!g || g({ column: b })) && (b.renderVisible || b.halfVisible));
    }, D = (x, h) => {
      (l || e).dispatchEvent("custom", { type: x }, h);
    }, S = {
      checkCustomStatus: v,
      emitCustomEvent: D,
      triggerCustomEvent(x) {
        const { customStore: h } = e.reactData;
        h.visible ? (m(), D("close", x)) : (h.btnEl = x.target, c(), D("open", x));
      },
      customOpenEvent(x) {
        const { customStore: h } = t;
        h.visible || (h.activeBtn = !0, h.btnEl = x.target, e.openCustom(), e.emitCustomEvent("open", x));
      },
      customCloseEvent(x) {
        const { customStore: h } = t;
        h.visible && (h.activeBtn = !1, e.closeCustom(), e.emitCustomEvent("close", x));
      }
    };
    return Object.assign(Object.assign({}, w), S);
  },
  setupGrid(e) {
    return e.extendTableMethods(TF);
  }
});
const { getConfig: $u, renderer: MF, getI18n: IF } = Ce, Qh = "modelValue", ev = {};
function VF(e, t) {
  return e && t.valueFormat ? r.toStringDate(e, t.valueFormat) : e;
}
function PF(e, t, n) {
  const { dateConfig: s = {} } = t;
  return r.toDateString(VF(e, t), s.labelFormat || n);
}
function Ru(e, t) {
  return PF(e, t, IF(`vxe.input.date.labelFormat.${t.type || "date"}`));
}
function kF(e) {
  return `vxe-${e.replace("$", "")}`;
}
function Is({ name: e }) {
  return qo(e);
}
function Uc({ name: e }) {
  return qo(kF(e));
}
function tv(e, t, n) {
  const { $panel: s } = e;
  s.changeOption({}, t, n);
}
function Gc(e) {
  let { name: t, attrs: n } = e;
  return t === "input" && (n = Object.assign({ type: "text" }, n)), n;
}
function nv(e) {
  const { name: t, immediate: n, props: s } = e;
  if (!n) {
    if (t === "VxeInput" || t === "$input") {
      const { type: i } = s || {};
      return !(!i || i === "text" || i === "number" || i === "integer" || i === "float");
    }
    return !(t === "input" || t === "textarea" || t === "$textarea");
  }
  return n;
}
function vr(e, t, n, s) {
  return r.assign({ immediate: nv(e) }, ev, s, e.props, { [Qh]: n });
}
function Mc(e, t, n, s) {
  return r.assign({}, ev, s, e.props, { [Qh]: n });
}
function Kc(e, t) {
  return t.$type === "cell" || nv(e);
}
function zs(e, t, n) {
  const { placeholder: s } = e;
  return [
    o("span", {
      class: "vxe-cell--label"
    }, s && kh(n) ? [
      o("span", {
        class: "vxe-cell--placeholder"
      }, po(fr(s), 1))
    ] : po(n, 1))
  ];
}
function ov(e, t, n, s) {
  const { events: i } = e, l = Gh(e), a = Kh(e), c = a === l, m = {};
  return i && r.objectEach(i, (u, d) => {
    m[$l(d)] = function(...p) {
      u(t, ...p);
    };
  }), n && (m[$l(l)] = function(u) {
    n(u), c && s && s(u), i && i[l] && i[l](t, u);
  }), !c && s && (m[$l(a)] = function(...u) {
    s(...u), i && i[a] && i[a](t, ...u);
  }), m;
}
function ea(e, t, n, s) {
  const { events: i } = e, l = Gh(e), a = Kh(e), c = {};
  return r.objectEach(i, (m, u) => {
    c[$l(u)] = function(...d) {
      process.env.NODE_ENV === "development" && (r.isFunction(m) || Ut("vxe.error.errFunc", [m])), m(t, ...d);
    };
  }), n && (c[$l(l)] = function(m) {
    n(m), i && i[l] && i[l](t, m);
  }), s && (c[$l(a)] = function(...m) {
    s(...m), i && i[a] && i[a](t, ...m);
  }), c;
}
function dr(e, t) {
  const { $table: n, row: s, column: i } = t, { name: l } = e, { model: a } = i, c = Kc(e, t);
  return ea(e, t, (m) => {
    a.update = !0, a.value = m, c && js(s, i, m);
  }, (m) => {
    if (!c && ["VxeInput", "VxeNumberInput", "VxeTextarea", "$input", "$textarea"].includes(l)) {
      const u = m.value;
      a.update = !0, a.value = u, n.updateStatus(t, u);
    } else
      n.updateStatus(t);
  });
}
function Ic(e, t, n) {
  return ea(e, t, (s) => {
    n.data = s;
  }, () => {
    tv(t, !r.eqNull(n.data), n);
  });
}
function sv(e, t) {
  const { $table: n, row: s, column: i } = t, { model: l } = i;
  return ov(e, t, (a) => {
    const c = a.target.value;
    Kc(e, t) ? js(s, i, c) : (l.update = !0, l.value = c);
  }, (a) => {
    const c = a.target.value;
    n.updateStatus(t, c);
  });
}
function rv(e, t, n) {
  return ov(e, t, (s) => {
    n.data = s.target.value;
  }, () => {
    tv(t, !r.eqNull(n.data), n);
  });
}
function Nu(e, t) {
  const { row: n, column: s } = t, { name: i } = e, l = Kc(e, t) ? Do(n, s) : s.model.value;
  return [
    o(i, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${i}` }, Gc(e)), { value: l }), sv(e, t)))
  ];
}
function $F(e, t) {
  return [
    o(Is(e), Object.assign(Object.assign({}, vr(e, t, null)), ea(e, t)))
  ];
}
function zo(e, t) {
  const { row: n, column: s } = t, i = Do(n, s);
  return [
    o(Is(e), Object.assign(Object.assign({}, vr(e, t, i)), dr(e, t)))
  ];
}
function qp(e, t) {
  const { options: n } = e, { row: s, column: i } = t, l = Do(s, i);
  return [
    o(Is(e), Object.assign(Object.assign({ options: n }, vr(e, t, l)), dr(e, t)))
  ];
}
function Ea(e, t) {
  const { row: n, column: s } = t, i = Do(n, s);
  return [
    o(Uc(e), Object.assign(Object.assign({}, vr(e, t, i)), dr(e, t)))
  ];
}
function lv(e, t) {
  return [
    o(qo("vxe-button"), Object.assign(Object.assign({}, vr(e, t, null)), ea(e, t)))
  ];
}
function RF(e, t) {
  return e.children.map((n) => lv(n, t)[0]);
}
function iv(e, t, n) {
  const { optionGroups: s, optionGroupProps: i = {} } = e, l = i.options || "options", a = i.label || "label";
  return s.map((c, m) => o("optgroup", {
    key: m,
    label: c[a]
  }, n(c[l], e, t)));
}
function Vc(e, t, n) {
  const { optionProps: s = {} } = t, { row: i, column: l } = n, a = s.label || "label", c = s.value || "value", m = s.disabled || "disabled", u = Kc(t, n) ? Do(i, l) : l.model.value;
  return e.map((d, p) => o("option", {
    key: p,
    value: d[c],
    disabled: d[m],
    /* eslint-disable eqeqeq */
    selected: d[c] == u
  }, d[a]));
}
function NF(e, t) {
  const { column: n } = t, { name: s } = e, i = Gc(e);
  return n.filters.map((l, a) => o(s, Object.assign(Object.assign(Object.assign({ key: a, class: `vxe-default-${s}` }, i), { value: l.data }), rv(e, t, l))));
}
function Fu(e, t) {
  const { column: n } = t;
  return n.filters.map((s, i) => {
    const l = s.data;
    return o(Is(e), Object.assign(Object.assign({ key: i }, Mc(e, e, l)), Ic(e, t, s)));
  });
}
function FF(e, t) {
  const { column: n } = t;
  return n.filters.map((s, i) => {
    const l = s.data;
    return o(Uc(e), Object.assign(Object.assign({ key: i }, Mc(e, e, l)), Ic(e, t, s)));
  });
}
function Sa({ option: e, row: t, column: n }) {
  const { data: s } = e;
  return r.get(t, n.field) == s;
}
function Da({ option: e, row: t, column: n }) {
  const { data: s } = e, i = r.get(t, n.field);
  return r.toValueString(i).indexOf(s) > -1;
}
function Up(e, t) {
  return [
    o("select", Object.assign(Object.assign({ class: "vxe-default-select" }, Gc(e)), sv(e, t)), e.optionGroups ? iv(e, t, Vc) : Vc(e.options, e, t))
  ];
}
function Gp(e, t) {
  const { row: n, column: s } = t, { options: i, optionProps: l, optionGroups: a, optionGroupProps: c } = e, m = Do(n, s);
  return [
    o(Is(e), Object.assign(Object.assign({}, vr(e, t, m, { options: i, optionProps: l, optionGroups: a, optionGroupProps: c })), dr(e, t)))
  ];
}
function Kp(e, t) {
  const { row: n, column: s } = t, { options: i, optionProps: l } = e, a = Do(n, s);
  return [
    o(Is(e), Object.assign(Object.assign({}, vr(e, t, a, { options: i, optionProps: l })), dr(e, t)))
  ];
}
function Yp(e, t) {
  const { row: n, column: s } = t, { options: i, optionProps: l, optionGroups: a, optionGroupProps: c } = e, m = Do(n, s);
  return [
    o(Uc(e), Object.assign(Object.assign({}, vr(e, t, m, { options: i, optionProps: l, optionGroups: a, optionGroupProps: c })), dr(e, t)))
  ];
}
function $a(e, { row: t, column: n }) {
  const { options: s, optionGroups: i, optionProps: l = {}, optionGroupProps: a = {} } = e, c = r.get(t, n.field);
  let m;
  const u = l.label || "label", d = l.value || "value";
  return c != null ? r.map(r.isArray(c) ? c : [c], i ? (p) => {
    const w = a.options || "options";
    for (let v = 0; v < i.length && (m = r.find(i[v][w], (D) => D[d] == p), !m); v++)
      ;
    return m ? m[u] : p;
  } : (p) => (m = r.find(s, (w) => w[d] == p), m ? m[u] : p)).join(", ") : "";
}
function Lu(e) {
  const { row: t, column: n, options: s } = e;
  return s.original ? Do(t, n) : $a(n.editRender || n.cellRender, e);
}
function nd(e, { row: t, column: n }) {
  const { options: s, optionProps: i = {} } = e, l = r.get(t, n.field), a = i.label || "label", c = i.value || "value", m = i.children || "children";
  if (l != null) {
    const u = {};
    return r.eachTree(s, (d) => {
      u[r.get(d, c)] = d;
    }, { children: m }), r.map(r.isArray(l) ? l : [l], (d) => {
      const p = u[d];
      return p && r.get(p, a);
    }).join(", ");
  }
  return "";
}
function Xp(e) {
  const { row: t, column: n, options: s } = e;
  return s.original ? Do(t, n) : nd(n.editRender || n.cellRender, e);
}
MF.mixin({
  input: {
    tableAutoFocus: "input",
    renderTableEdit: Nu,
    renderTableDefault: Nu,
    renderTableFilter: NF,
    tableFilterDefaultMethod: Da
  },
  textarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: Nu
  },
  select: {
    renderTableEdit: Up,
    renderTableDefault: Up,
    renderTableCell(e, t) {
      return zs(e, t, $a(e, t));
    },
    renderTableFilter(e, t) {
      const { column: n } = t;
      return n.filters.map((s, i) => o("select", Object.assign(Object.assign({ key: i, class: "vxe-default-select" }, Gc(e)), rv(e, t, s)), e.optionGroups ? iv(e, t, Vc) : Vc(e.options, e, t)));
    },
    tableFilterDefaultMethod: Sa,
    tableExportMethod: Lu
  },
  VxeInput: {
    tableAutoFocus: "input",
    renderTableEdit: zo,
    renderTableCell(e, t) {
      var n;
      const { props: s = {} } = e, { row: i, column: l } = t, a = s.digits || ((n = $u().input) === null || n === void 0 ? void 0 : n.digits) || 2;
      let c = r.get(i, l.field);
      if (c)
        switch (s.type) {
          case "date":
          case "week":
          case "month":
          case "quarter":
          case "year":
            c = Ru(c, s);
            break;
          case "float":
            c = r.toFixed(r.floor(c, a), a);
            break;
        }
      return zs(e, t, c);
    },
    renderTableDefault: zo,
    renderTableFilter: Fu,
    tableFilterDefaultMethod: Da
  },
  VxeNumberInput: {
    tableAutoFocus: "input",
    renderTableEdit: zo,
    renderTableCell(e, t) {
      var n;
      const { props: s = {} } = e, { row: i, column: l } = t, a = s.digits || ((n = $u().numberInput) === null || n === void 0 ? void 0 : n.digits) || 2;
      let c = r.get(i, l.field);
      if (c)
        switch (s.type) {
          case "float":
            c = r.toFixed(r.floor(c, a), a);
            break;
        }
      return zs(e, t, c);
    },
    renderTableDefault: zo,
    renderTableFilter: Fu,
    tableFilterDefaultMethod: Da
  },
  VxeDatePicker: {
    tableAutoFocus: "input",
    renderTableEdit: zo,
    renderTableCell(e, t) {
      const { props: n = {} } = e, { row: s, column: i } = t;
      let l = r.get(s, i.field);
      return l && (l = Ru(l, n)), zs(e, t, l);
    },
    renderTableDefault: zo,
    renderTableFilter: Fu,
    tableFilterDefaultMethod: Sa
  },
  VxeTextarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: zo,
    renderTableCell(e, t) {
      const { row: n, column: s } = t, i = r.get(n, s.field);
      return zs(e, t, i);
    }
  },
  VxeButton: {
    renderTableDefault: $F
  },
  VxeButtonGroup: {
    renderTableDefault(e, t) {
      const { options: n } = e;
      return [
        o(Is(e), Object.assign(Object.assign({ options: n }, vr(e, t, null)), ea(e, t)))
      ];
    }
  },
  VxeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: Gp,
    renderTableDefault: Gp,
    renderTableCell(e, t) {
      return zs(e, t, $a(e, t));
    },
    renderTableFilter(e, t) {
      const { column: n } = t, { options: s, optionProps: i, optionGroups: l, optionGroupProps: a } = e;
      return n.filters.map((c, m) => {
        const u = c.data;
        return o(Is(e), Object.assign(Object.assign({ key: m }, Mc(e, t, u, { options: s, optionProps: i, optionGroups: l, optionGroupProps: a })), Ic(e, t, c)));
      });
    },
    tableFilterDefaultMethod: Sa,
    tableExportMethod: Lu
  },
  VxeTreeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: Kp,
    renderTableCell(e, t) {
      return zs(e, t, nd(e, t));
    },
    tableExportMethod: Xp
  },
  VxeTableSelect: {
    tableAutoFocus: "input",
    renderTableEdit: Kp,
    renderTableCell(e, t) {
      return zs(e, t, nd(e, t));
    },
    tableExportMethod: Xp
  },
  VxeIconPicker: {
    tableAutoFocus: "input",
    renderTableEdit: zo,
    renderTableCell(e, t) {
      const { row: n, column: s } = t, i = r.get(n, s.field);
      return o("i", {
        class: i
      });
    }
  },
  VxeRadioGroup: {
    renderTableDefault: qp
  },
  VxeCheckboxGroup: {
    renderTableDefault: qp
  },
  VxeSwitch: {
    tableAutoFocus: "button",
    renderTableEdit: zo,
    renderTableDefault: zo
  },
  VxeUpload: {
    renderTableEdit: zo,
    renderTableCell: zo,
    renderTableDefault: zo
  },
  VxeImage: {
    renderTableDefault(e, t) {
      const { row: n, column: s } = t, { props: i } = e, l = Do(n, s);
      return [
        o(Is(e), Object.assign(Object.assign(Object.assign({}, i), { src: l }), dr(e, t)))
      ];
    }
  },
  VxeImageGroup: {
    renderTableDefault(e, t) {
      const { row: n, column: s } = t, { props: i } = e, l = Do(n, s);
      return [
        o(Is(e), Object.assign(Object.assign(Object.assign({}, i), { urlList: l }), dr(e, t)))
      ];
    }
  },
  VxeTextEllipsis: {
    renderTableDefault(e, t) {
      const { row: n, column: s } = t, { props: i } = e, l = Do(n, s);
      return [
        o(Is(e), Object.assign(Object.assign(Object.assign({}, i), { content: l }), dr(e, t)))
      ];
    }
  },
  VxeRate: {
    renderTableDefault: zo
  },
  VxeSlider: {
    renderTableDefault: zo
  },
  // 以下已废弃
  $input: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: Ea,
    renderTableCell(e, t) {
      var n;
      const { props: s = {} } = e, { row: i, column: l } = t, a = s.digits || ((n = $u().input) === null || n === void 0 ? void 0 : n.digits) || 2;
      let c = r.get(i, l.field);
      if (c)
        switch (s.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            c = Ru(c, s);
            break;
          case "float":
            c = r.toFixed(r.floor(c, a), a);
            break;
        }
      return zs(e, t, c);
    },
    renderTableDefault: Ea,
    renderTableFilter: FF,
    tableFilterDefaultMethod: Da
  },
  $textarea: {
    tableAutoFocus: ".vxe-textarea--inner"
  },
  $button: {
    renderTableDefault: lv
  },
  $buttons: {
    renderTableDefault: RF
  },
  $select: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: Yp,
    renderTableDefault: Yp,
    renderTableCell(e, t) {
      return zs(e, t, $a(e, t));
    },
    renderTableFilter(e, t) {
      const { column: n } = t, { options: s, optionProps: i, optionGroups: l, optionGroupProps: a } = e;
      return n.filters.map((c, m) => {
        const u = c.data;
        return o(Uc(e), Object.assign(Object.assign({ key: m }, Mc(e, t, u, { options: s, optionProps: i, optionGroups: l, optionGroupProps: a })), Ic(e, t, c)));
      });
    },
    tableFilterDefaultMethod: Sa,
    tableExportMethod: Lu
  },
  $radio: {
    tableAutoFocus: ".vxe-radio--input"
  },
  $checkbox: {
    tableAutoFocus: ".vxe-checkbox--input"
  },
  $switch: {
    tableAutoFocus: ".vxe-switch--button",
    renderTableEdit: Ea,
    renderTableDefault: Ea
  }
  // 以上已废弃
});
const av = Object.assign({}, Rl, {
  install(e) {
    e.component(Rl.name, Rl);
  }
}), LF = {
  useCellView: ZN
};
Ce.dynamicApp && Ce.dynamicApp.component(Rl.name, Rl);
Ce.component(Rl);
Ce.tableHandle = LF;
const { getConfig: Ts, getIcon: Ir, getI18n: wl, renderer: Zp, commands: Jp, createEvent: AF, useFns: BF } = Ce, Nl = pt({
  name: "VxeToolbar",
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: {
      type: Array,
      default: () => Ts().toolbar.buttons
    },
    tools: {
      type: Array,
      default: () => Ts().toolbar.tools
    },
    perfect: {
      type: Boolean,
      default: () => Ts().toolbar.perfect
    },
    size: {
      type: String,
      default: () => Ts().toolbar.size || Ts().size
    },
    className: [String, Function]
  },
  emits: [
    "button-click",
    "tool-click"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = Ce.getComponent("VxeButton"), { computeSize: a } = BF.useSize(e), c = Rt({
      isRefresh: !1,
      connectFlag: 0,
      columns: []
    }), m = {
      connectTable: null
    }, u = ke(), d = {
      refElem: u
    }, p = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      internalData: m,
      getRefMaps: () => d
    };
    let w = {};
    const v = mt("$xeGrid", null), D = _(() => Object.assign({}, r.clone(Ts().toolbar.refresh, !0), e.refresh)), S = _(() => Object.assign({}, r.clone(Ts().toolbar.import, !0), e.import)), x = _(() => Object.assign({}, r.clone(Ts().toolbar.export, !0), e.export)), h = _(() => Object.assign({}, r.clone(Ts().toolbar.print, !0), e.print)), O = _(() => Object.assign({}, r.clone(Ts().toolbar.zoom, !0), e.zoom)), g = _(() => Object.assign({}, r.clone(Ts().toolbar.custom, !0), e.custom)), b = _(() => {
      const { connectTable: $ } = m, J = $;
      if ((c.connectFlag || J) && J) {
        const { computeCustomOpts: ge } = J.getComputeMaps();
        return ge.value;
      }
      return { trigger: "" };
    }), E = _(() => b.value.trigger), C = () => {
      const { connectTable: $ } = m;
      if ($)
        return !0;
      Ut("vxe.error.barUnableLink");
    }, V = ({ $event: $ }) => {
      const { connectTable: J } = m, ge = J;
      ge && (ge.triggerCustomEvent ? ge.triggerCustomEvent($) : Ut("vxe.error.reqModule", ["VxeTableCustomModule"]));
    }, Q = ({ $event: $ }) => {
      const { connectTable: J } = m, ge = J;
      ge ? ge.customOpenEvent($) : Ut("vxe.error.reqModule", ["VxeTableCustomModule"]);
    }, Z = ({ $event: $ }) => {
      const { connectTable: J } = m, ge = J;
      if (ge) {
        const { customStore: Oe } = ge.reactData;
        Oe.activeBtn = !1, setTimeout(() => {
          !Oe.activeBtn && !Oe.activeWrapper && ge.customCloseEvent($);
        }, 350);
      }
    }, G = ({ $event: $ }) => {
      const { isRefresh: J } = c, ge = D.value;
      if (!J) {
        const Oe = ge.queryMethod || ge.query;
        if (Oe) {
          c.isRefresh = !0;
          try {
            Promise.resolve(Oe({})).catch((Se) => Se).then(() => {
              c.isRefresh = !1;
            });
          } catch {
            c.isRefresh = !1;
          }
        } else v && (c.isRefresh = !0, v.triggerToolbarCommitEvent({ code: ge.code || "reload" }, $).catch((Se) => Se).then(() => {
          c.isRefresh = !1;
        }));
      }
    }, ue = ({ $event: $ }) => {
      v && v.triggerZoomEvent($);
    }, Y = ($, J) => {
      const { connectTable: ge } = m, Oe = ge, { code: Se } = J;
      if (Se)
        if (v)
          v.triggerToolbarBtnEvent(J, $);
        else {
          const de = Jp.get(Se), Ie = { code: Se, button: J, $table: Oe, $grid: v, $event: $ };
          if (de) {
            const je = de.tableCommandMethod || de.commandMethod;
            je ? je(Ie) : process.env.NODE_ENV === "development" && Ut("vxe.error.notCommands", [Se]);
          }
          p.dispatchEvent("button-click", Ie, $);
        }
    }, K = ($, J) => {
      const { connectTable: ge } = m, Oe = ge, { code: Se } = J;
      if (Se)
        if (v)
          v.triggerToolbarTolEvent(J, $);
        else {
          const de = Jp.get(Se), Ie = { code: Se, tool: J, $table: Oe, $grid: v, $event: $ };
          if (de) {
            const je = de.tableCommandMethod || de.commandMethod;
            je ? je(Ie) : process.env.NODE_ENV === "development" && Ut("vxe.error.notCommands", [Se]);
          }
          p.dispatchEvent("tool-click", Ie, $);
        }
    }, L = () => {
      if (C()) {
        const { connectTable: $ } = m, J = $;
        J && J.openImport();
      }
    }, ye = () => {
      if (C()) {
        const { connectTable: $ } = m, J = $;
        J && J.openExport();
      }
    }, se = () => {
      if (C()) {
        const { connectTable: $ } = m, J = $;
        J && J.openPrint();
      }
    };
    w = {
      dispatchEvent: ($, J, ge) => {
        s($, AF(ge, { $toolbar: p }, J));
      },
      syncUpdate($) {
        m.connectTable = $.$table, c.columns = $.collectColumn, c.connectFlag++;
      }
    }, Object.assign(p, w);
    const M = ($, J) => {
      const { dropdowns: ge } = $, Oe = [];
      return ge ? ge.map((Se, de) => Se.visible === !1 ? Ve() : l ? o(l, {
        key: de,
        disabled: Se.disabled,
        loading: Se.loading,
        type: Se.type,
        mode: Se.mode,
        icon: Se.icon,
        circle: Se.circle,
        round: Se.round,
        status: Se.status,
        content: Se.name,
        title: Se.title,
        routerLink: Se.routerLink,
        permissionCode: Se.permissionCode,
        prefixTooltip: Se.prefixTooltip,
        suffixTooltip: Se.suffixTooltip,
        onClick: ({ $event: Ie }) => J ? Y(Ie, Se) : K(Ie, Se)
      }) : Ve()) : Oe;
    }, I = () => {
      const { buttons: $ } = e, { connectTable: J } = m, ge = J, Oe = [];
      return $ && $.forEach((Se) => {
        const { dropdowns: de, buttonRender: Ie } = Se;
        if (Se.visible !== !1) {
          const je = Ie ? Zp.get(Ie.name) : null;
          if (Ie && je && je.renderToolbarButton) {
            const Ue = je.toolbarButtonClassName, Ae = { $grid: v, $table: ge, button: Se };
            Oe.push(o("span", {
              class: ["vxe-button--item", Ue ? r.isFunction(Ue) ? Ue(Ae) : Ue : ""]
            }, cs(je.renderToolbarButton(Ie, Ae))));
          } else
            l && Oe.push(o(l, {
              disabled: Se.disabled,
              loading: Se.loading,
              type: Se.type,
              mode: Se.mode,
              icon: Se.icon,
              circle: Se.circle,
              round: Se.round,
              status: Se.status,
              content: Se.name,
              title: Se.title,
              routerLink: Se.routerLink,
              permissionCode: Se.permissionCode,
              prefixTooltip: Se.prefixTooltip,
              suffixTooltip: Se.suffixTooltip,
              destroyOnClose: Se.destroyOnClose,
              placement: Se.placement,
              transfer: Se.transfer,
              onClick: ({ $event: Ue }) => Y(Ue, Se)
            }, de && de.length ? {
              dropdowns: () => M(Se, !0)
            } : {}));
        }
      }), Oe;
    }, B = () => {
      const { tools: $ } = e, { connectTable: J } = m, ge = J, Oe = [];
      return $ && $.forEach((Se, de) => {
        const { dropdowns: Ie, toolRender: je } = Se;
        if (Se.visible !== !1) {
          const Ue = je ? je.name : null, Ae = je ? Zp.get(Ue) : null;
          if (je && Ae && Ae.renderToolbarTool) {
            const _e = Ae.toolbarToolClassName, it = { $grid: v, $table: ge, tool: Se };
            Oe.push(o("span", {
              key: Ue,
              class: ["vxe-tool--item", _e ? r.isFunction(_e) ? _e(it) : _e : ""]
            }, cs(Ae.renderToolbarTool(je, it))));
          } else
            l && Oe.push(o(l, {
              key: de,
              disabled: Se.disabled,
              loading: Se.loading,
              type: Se.type,
              mode: Se.mode,
              icon: Se.icon,
              circle: Se.circle,
              round: Se.round,
              status: Se.status,
              content: Se.name,
              title: Se.title,
              routerLink: Se.routerLink,
              permissionCode: Se.permissionCode,
              prefixTooltip: Se.prefixTooltip,
              suffixTooltip: Se.suffixTooltip,
              destroyOnClose: Se.destroyOnClose,
              placement: Se.placement,
              transfer: Se.transfer,
              onClick: ({ $event: _e }) => K(_e, Se)
            }, Ie && Ie.length ? {
              dropdowns: () => M(Se, !1)
            } : {}));
        }
      }), Oe;
    }, H = () => {
      const $ = S.value;
      return l ? o(l, {
        key: "import",
        circle: !0,
        icon: $.icon || Ir().TOOLBAR_TOOLS_IMPORT,
        title: wl("vxe.toolbar.import"),
        onClick: L
      }) : Ve();
    }, ce = () => {
      const $ = x.value;
      return l ? o(l, {
        key: "export",
        circle: !0,
        icon: $.icon || Ir().TOOLBAR_TOOLS_EXPORT,
        title: wl("vxe.toolbar.export"),
        onClick: ye
      }) : Ve();
    }, A = () => {
      const $ = h.value;
      return l ? o(l, {
        key: "print",
        circle: !0,
        icon: $.icon || Ir().TOOLBAR_TOOLS_PRINT,
        title: wl("vxe.toolbar.print"),
        onClick: se
      }) : Ve();
    }, j = () => {
      const $ = D.value;
      return l ? o(l, {
        key: "refresh",
        circle: !0,
        icon: c.isRefresh ? $.iconLoading || Ir().TOOLBAR_TOOLS_REFRESH_LOADING : $.icon || Ir().TOOLBAR_TOOLS_REFRESH,
        title: wl("vxe.toolbar.refresh"),
        onClick: G
      }) : Ve();
    }, fe = () => {
      const $ = O.value;
      return v && l ? o(l, {
        key: "zoom",
        circle: !0,
        icon: v.isMaximized() ? $.iconOut || Ir().TOOLBAR_TOOLS_MINIMIZE : $.iconIn || Ir().TOOLBAR_TOOLS_FULLSCREEN,
        title: wl(`vxe.toolbar.zoom${v.isMaximized() ? "Out" : "In"}`),
        onClick: ue
      }) : Ve();
    }, pe = () => {
      const $ = g.value, J = E.value, ge = {};
      return J === "manual" || (J === "hover" ? (ge.onMouseenter = Q, ge.onMouseleave = Z) : ge.onClick = V), l ? o(l, Object.assign({ key: "custom", circle: !0, icon: $.icon || Ir().TOOLBAR_TOOLS_CUSTOM, title: wl("vxe.toolbar.custom"), className: "vxe-toolbar-custom-target" }, ge)) : Ve();
    }, ne = () => {
      const { perfect: $, loading: J, refresh: ge, zoom: Oe, custom: Se, className: de } = e, { connectTable: Ie } = m, je = a.value, Ue = n.tools, Ae = n.buttons, _e = Ie;
      return o("div", {
        ref: u,
        class: ["vxe-toolbar", de ? r.isFunction(de) ? de({ $toolbar: p }) : de : "", {
          [`size--${je}`]: je,
          "is--perfect": $,
          "is--loading": J
        }]
      }, [
        o("div", {
          class: "vxe-buttons--wrapper"
        }, Ae ? Ae({ $grid: v, $table: _e }) : I()),
        o("div", {
          class: "vxe-tools--wrapper"
        }, Ue ? Ue({ $grid: v, $table: _e }) : B()),
        o("div", {
          class: "vxe-tools--operate"
        }, [
          e.import ? H() : Ve(),
          e.export ? ce() : Ve(),
          e.print ? A() : Ve(),
          ge ? j() : Ve(),
          Oe && v ? fe() : Ve(),
          Se ? pe() : Ve()
        ])
      ]);
    };
    return p.renderVN = ne, me(() => {
      const { refresh: $ } = e, J = D.value, ge = J.queryMethod || J.query;
      $ && !v && !ge && rn("vxe.error.notFunc", ["queryMethod"]);
      const Oe = g.value;
      process.env.NODE_ENV === "development" && (Oe.isFooter && rn("vxe.error.delProp", ["toolbar.custom.isFooter", "table.custom-config.showFooter"]), Oe.showFooter && rn("vxe.error.delProp", ["toolbar.custom.showFooter", "table.custom-config.showFooter"]), Oe.immediate && rn("vxe.error.delProp", ["toolbar.custom.immediate", "table.custom-config.immediate"]), Oe.trigger && rn("vxe.error.delProp", ["toolbar.custom.trigger", "table.custom-config.trigger"])), process.env.NODE_ENV === "development" && (e.refresh || e.import || e.export || e.print || e.zoom) && (l || Ut("vxe.error.reqComp", ["vxe-button"]));
    }), p;
  },
  render() {
    return this.renderVN();
  }
}), cv = Object.assign({}, Nl, {
  install(e) {
    e.component(Nl.name, Nl);
  }
});
Ce.dynamicApp && Ce.dynamicApp.component(Nl.name, Nl);
Ce.component(Nl);
const { getConfig: or, getI18n: El, commands: _F, hooks: WF, useFns: zF, createEvent: HF, globalEvents: Au, GLOBAL_EVENT_KEYS: jF } = Ce, qF = Object.keys(Sd), Qp = ["clearAll", "syncData", "updateData", "loadData", "reloadData", "reloadRow", "loadColumn", "reloadColumn", "getRowNode", "getColumnNode", "getRowIndex", "getVTRowIndex", "getVMRowIndex", "getColumnIndex", "getVTColumnIndex", "getVMColumnIndex", "setRow", "createData", "createRow", "revertData", "clearData", "isInsertByRow", "isUpdateByRow", "getColumns", "getColumnById", "getColumnByField", "getTableColumn", "getFullColumns", "getData", "getCheckboxRecords", "getParentRow", "getTreeParentRow", "getRowSeq", "getRowById", "getRowid", "getTableData", "getFullData", "setColumnFixed", "clearColumnFixed", "setColumnWidth", "getColumnWidth", "hideColumn", "showColumn", "resetColumn", "refreshColumn", "refreshScroll", "recalculate", "closeTooltip", "isAllCheckboxChecked", "isAllCheckboxIndeterminate", "getCheckboxIndeterminateRecords", "setCheckboxRow", "isCheckedByCheckboxRow", "isIndeterminateByCheckboxRow", "toggleCheckboxRow", "setAllCheckboxRow", "getRadioReserveRecord", "clearRadioReserve", "getCheckboxReserveRecords", "clearCheckboxReserve", "toggleAllCheckboxRow", "clearCheckboxRow", "setCurrentRow", "isCheckedByRadioRow", "setRadioRow", "clearCurrentRow", "clearRadioRow", "getCurrentRecord", "getRadioRecord", "getCurrentColumn", "setCurrentColumn", "clearCurrentColumn", "setPendingRow", "togglePendingRow", "getPendingRecords", "clearPendingRow", "sort", "clearSort", "isSort", "getSortColumns", "closeFilter", "isFilter", "isActiveFilterByColumn", "isRowExpandLoaded", "clearRowExpandLoaded", "reloadRowExpand", "reloadRowExpand", "toggleRowExpand", "setAllRowExpand", "setRowExpand", "isExpandByRow", "isRowExpandByRow", "clearRowExpand", "clearRowExpandReserve", "getRowExpandRecords", "getTreeExpandRecords", "isTreeExpandLoaded", "clearTreeExpandLoaded", "reloadTreeExpand", "reloadTreeChilds", "toggleTreeExpand", "setAllTreeExpand", "setTreeExpand", "isTreeExpandByRow", "clearTreeExpand", "clearTreeExpandReserve", "getScroll", "scrollTo", "scrollToRow", "scrollToColumn", "clearScroll", "updateFooter", "updateStatus", "setMergeCells", "removeInsertRow", "removeMergeCells", "getMergeCells", "clearMergeCells", "setMergeFooterItems", "removeMergeFooterItems", "getMergeFooterItems", "clearMergeFooterItems", "getCustomStoreData", "openTooltip", "getCellLabel", "getCellElement", "focus", "blur", "connect"], UF = [
  ...Dd,
  "page-change",
  "form-submit",
  "form-submit-invalid",
  "form-reset",
  "form-collapse",
  "form-toggle-collapse",
  "proxy-query",
  "proxy-delete",
  "proxy-save",
  "toolbar-button-click",
  "toolbar-tool-click",
  "zoom"
], Fl = pt({
  name: "VxeGrid",
  props: Object.assign(Object.assign({}, Sd), { layouts: Array, columns: Array, pagerConfig: Object, proxyConfig: Object, toolbarConfig: Object, formConfig: Object, zoomConfig: Object, size: {
    type: String,
    default: () => or().grid.size || or().size
  } }),
  emits: UF,
  setup(e, t) {
    var n;
    const { slots: s, emit: i } = t, l = r.uniqueId(), a = Ce.getComponent("VxeForm"), c = Ce.getComponent("VxePager"), { computeSize: m } = zF.useSize(e), u = Rt({
      tableLoading: !1,
      proxyInited: !1,
      isZMax: !1,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: ((n = or().pager) === null || n === void 0 ? void 0 : n.pageSize) || 10,
        currentPage: 1
      }
    }), d = ke(), p = ke(), w = ke(), v = ke(), D = ke(), S = ke(), x = ke(), h = ke(), O = ke(), g = ke(), b = (R) => {
      const le = {};
      return R.forEach((F) => {
        le[F] = (...re) => {
          const N = p.value;
          if (N && N[F])
            return N[F](...re);
        };
      }), le;
    }, E = b(Qp);
    Qp.forEach((R) => {
      E[R] = (...le) => {
        const F = p.value;
        if (F && F[R])
          return F && F[R](...le);
      };
    });
    const C = _(() => r.merge({}, r.clone(or().grid.proxyConfig, !0), e.proxyConfig)), V = _(() => {
      const R = C.value;
      return r.isBoolean(R.message) ? R.message : R.showResponseMsg;
    }), Q = _(() => C.value.showActiveMsg), Z = _(() => Object.assign({}, or().grid.pagerConfig, e.pagerConfig)), G = _(() => Object.assign({}, or().grid.formConfig, e.formConfig)), ue = _(() => Object.assign({}, or().grid.toolbarConfig, e.toolbarConfig)), Y = _(() => Object.assign({}, or().grid.zoomConfig, e.zoomConfig)), K = _(() => u.isZMax ? { zIndex: u.tZindex } : null), L = _(() => {
      const R = {}, le = e;
      return qF.forEach((F) => {
        R[F] = le[F];
      }), R;
    }), ye = _(() => {
      const { seqConfig: R, pagerConfig: le, loading: F, editConfig: re, proxyConfig: N } = e, { isZMax: ee, tableLoading: be, tablePage: we, tableData: Te } = u, ze = L.value, st = C.value, ct = Z.value, Ke = Object.assign({}, ze);
      return ee && (ze.maxHeight ? Ke.maxHeight = "100%" : Ke.height = "100%"), N && fn(st) && (Ke.loading = F || be, Ke.data = Te, le && st.seq && fn(ct) && (Ke.seqConfig = Object.assign({}, R, { startIndex: (we.currentPage - 1) * we.pageSize }))), re && (Ke.editConfig = Object.assign({}, re)), Ke;
    }), se = _(() => {
      const { layouts: R } = e;
      return R && R.length ? R : or().grid.layouts || ["Form", "Toolbar", "Top", "Table", "Bottom", "Pager"];
    }), P = {
      refElem: d,
      refTable: p,
      refForm: w,
      refToolbar: v,
      refPager: D
    }, M = {
      computeProxyOpts: C,
      computePagerOpts: Z,
      computeFormOpts: G,
      computeToolbarOpts: ue,
      computeZoomOpts: Y
    }, I = {
      xID: l,
      props: e,
      context: t,
      reactData: u,
      getRefMaps: () => P,
      getComputeMaps: () => M
    }, B = () => {
      const R = ue.value;
      e.toolbarConfig && fn(R) && me(() => {
        const le = p.value, F = v.value;
        le && F && le.connect(F);
      });
    }, H = () => {
      const { proxyConfig: R } = e, { formData: le } = u, F = C.value, re = G.value;
      return R && fn(F) && F.form ? le : re.data;
    }, ce = () => {
      const { tablePage: R } = u, { pagerConfig: le } = e, F = Z.value, { currentPage: re, pageSize: N } = F;
      le && fn(F) && (re && (R.currentPage = re), N && (R.pageSize = N));
    }, A = (R) => {
      const le = Q.value, F = p.value, re = F.getCheckboxRecords();
      re.length ? (F.togglePendingRow(re), E.clearCheckboxRow()) : le && Ce.modal && Ce.modal.message({ id: R, content: El("vxe.grid.selectOneRecord"), status: "warning" });
    }, j = (R, le) => {
      const F = C.value, N = (F.response || F.props || {}).message;
      let ee;
      return R && N && (ee = r.isFunction(N) ? N({ data: R, $grid: I }) : r.get(R, N)), ee || El(le);
    }, fe = (R, le, F) => {
      const re = Q.value, N = E.getCheckboxRecords();
      if (re)
        if (N.length) {
          if (Ce.modal)
            return Ce.modal.confirm({ id: `cfm_${R}`, content: El(le), escClosable: !0 }).then((ee) => {
              if (ee === "confirm")
                return F();
            });
        } else
          Ce.modal && Ce.modal.message({ id: `msg_${R}`, content: El("vxe.grid.selectOneRecord"), status: "warning" });
      else
        N.length && F();
      return Promise.resolve();
    }, pe = (R) => {
      const { proxyConfig: le } = e, { tablePage: F } = u, { $event: re, currentPage: N, pageSize: ee } = R, be = C.value;
      F.currentPage = N, F.pageSize = ee, ve.dispatchEvent("page-change", R, re), le && fn(be) && ve.commitProxy("query").then((we) => {
        ve.dispatchEvent("proxy-query", we, re);
      });
    }, ne = (R) => {
      const le = p.value, { proxyConfig: F } = e, { computeSortOpts: re } = le.getComputeMaps(), N = C.value;
      re.value.remote && (u.sortData = R.sortList, F && fn(N) && (u.tablePage.currentPage = 1, ve.commitProxy("query").then((be) => {
        ve.dispatchEvent("proxy-query", be, R.$event);
      }))), ve.dispatchEvent("sort-change", R, R.$event);
    }, $ = (R) => {
      const le = p.value, { proxyConfig: F } = e, { computeFilterOpts: re } = le.getComputeMaps(), N = C.value;
      re.value.remote && (u.filterData = R.filterList, F && fn(N) && (u.tablePage.currentPage = 1, ve.commitProxy("query").then((be) => {
        ve.dispatchEvent("proxy-query", be, R.$event);
      }))), ve.dispatchEvent("filter-change", R, R.$event);
    }, J = (R) => {
      const { proxyConfig: le } = e, F = C.value;
      le && fn(F) && ve.commitProxy("reload").then((re) => {
        ve.dispatchEvent("proxy-query", Object.assign(Object.assign({}, re), { isReload: !0 }), R.$event);
      }), ve.dispatchEvent("form-submit", R, R.$event);
    }, ge = (R) => {
      const { proxyConfig: le } = e, { $event: F } = R, re = C.value;
      le && fn(re) && ve.commitProxy("reload").then((N) => {
        ve.dispatchEvent("proxy-query", Object.assign(Object.assign({}, N), { isReload: !0 }), F);
      }), ve.dispatchEvent("form-reset", R, F);
    }, Oe = (R) => {
      ve.dispatchEvent("form-submit-invalid", R, R.$event);
    }, Se = (R) => {
      const { $event: le } = R;
      me(() => E.recalculate(!0)), ve.dispatchEvent("form-toggle-collapse", R, le), ve.dispatchEvent("form-collapse", R, le);
    }, de = (R) => {
      const { isZMax: le } = u;
      return (R ? !le : le) && (u.isZMax = !le, u.tZindex < Nh() && (u.tZindex = Rh())), me().then(() => E.recalculate(!0)).then(() => u.isZMax);
    }, Ie = (R, le) => {
      const F = R[le];
      if (F)
        if (r.isString(F)) {
          if (s[F])
            return s[F];
          process.env.NODE_ENV === "development" && Ut("vxe.error.notSlot", [F]);
        } else
          return F;
      return null;
    }, je = () => {
      const { formConfig: R, proxyConfig: le } = e, { formData: F } = u, re = C.value, N = G.value;
      if (R && fn(N) || s.form) {
        let ee = [];
        if (s.form)
          ee = s.form({ $grid: I });
        else if (N.items) {
          const be = {};
          if (!N.inited) {
            N.inited = !0;
            const we = re.beforeItem;
            re && we && N.items.forEach((Te) => {
              we({ $grid: I, item: Te });
            });
          }
          N.items.forEach((we) => {
            r.each(we.slots, (Te) => {
              r.isFunction(Te) || s[Te] && (be[Te] = s[Te]);
            });
          }), a && ee.push(o(a, Object.assign(Object.assign({ ref: w }, Object.assign({}, N, {
            data: le && fn(re) && re.form ? F : N.data
          })), { onSubmit: J, onReset: ge, onSubmitInvalid: Oe, onCollapse: Se }), be));
        }
        return o("div", {
          ref: S,
          key: "form",
          class: "vxe-grid--form-wrapper"
        }, ee);
      }
      return Ve();
    }, Ue = () => {
      const { toolbarConfig: R } = e, le = ue.value;
      if (R && fn(le) || s.toolbar) {
        let F = [];
        if (s.toolbar)
          F = s.toolbar({ $grid: I });
        else {
          const re = le.slots;
          let N, ee;
          const be = {};
          re && (N = Ie(re, "buttons"), ee = Ie(re, "tools"), N && (be.buttons = N), ee && (be.tools = ee)), F.push(o(cv, Object.assign({ ref: v }, le), be));
        }
        return o("div", {
          ref: x,
          key: "toolbar",
          class: "vxe-grid--toolbar-wrapper"
        }, F);
      }
      return Ve();
    }, Ae = () => s.top ? o("div", {
      ref: h,
      key: "top",
      class: "vxe-grid--top-wrapper"
    }, s.top({ $grid: I })) : Ve(), _e = () => {
      const R = s.left;
      return R ? o("div", {
        class: "vxe-grid--left-wrapper"
      }, R({ $grid: I })) : Ve();
    }, it = () => {
      const R = s.right;
      return R ? o("div", {
        class: "vxe-grid--right-wrapper"
      }, R({ $grid: I })) : Ve();
    }, vt = () => {
      const { proxyConfig: R } = e, le = ye.value, F = C.value, re = Object.assign({}, Qe), N = s.empty, ee = s.loading;
      R && fn(F) && (F.sort && (re.onSortChange = ne), F.filter && (re.onFilterChange = $));
      const be = {};
      return N && (be.empty = () => N({ $grid: I })), ee && (be.loading = () => ee({ $grid: I })), o("div", {
        class: "vxe-grid--table-wrapper"
      }, [
        o(av, Object.assign(Object.assign({ ref: p }, le), re), be)
      ]);
    }, dt = () => s.bottom ? o("div", {
      ref: O,
      key: "bottom",
      class: "vxe-grid--bottom-wrapper"
    }, s.bottom({ $grid: I })) : Ve(), at = () => {
      const { proxyConfig: R, pagerConfig: le } = e, F = C.value, re = Z.value;
      if (le && fn(re) || s.pager) {
        let N = [];
        if (s.pager)
          N = s.pager({ $grid: I });
        else {
          const ee = re.slots, be = {};
          let we, Te;
          ee && (we = Ie(ee, "left"), Te = Ie(ee, "right"), we && (be.left = we), Te && (be.right = Te)), c && N.push(o(c, Object.assign(Object.assign(Object.assign({ ref: D }, re), R && fn(F) ? u.tablePage : {}), { onPageChange: pe }), be));
        }
        return o("div", {
          ref: g,
          key: "pager",
          class: "vxe-grid--pager-wrapper"
        }, N);
      }
      return Ve();
    }, Et = () => {
      const R = [];
      return se.value.forEach((F) => {
        switch (F) {
          case "Form":
            R.push(je());
            break;
          case "Toolbar":
            R.push(Ue());
            break;
          case "Top":
            R.push(Ae());
            break;
          case "Table":
            R.push(o("div", {
              key: "table",
              class: "vxe-grid--table-container"
            }, [
              _e(),
              vt(),
              it()
            ]));
            break;
          case "Bottom":
            R.push(dt());
            break;
          case "Pager":
            R.push(at());
            break;
          default:
            process.env.NODE_ENV === "development" && Ut("vxe.error.notProp", [`layouts -> ${F}`]);
            break;
        }
      }), R;
    }, Qe = {};
    Dd.forEach((R) => {
      const le = r.camelCase(`on-${R}`);
      Qe[le] = (...F) => i(R, ...F);
    });
    const De = () => {
      const { proxyConfig: R, formConfig: le } = e, { proxyInited: F } = u, re = C.value, N = G.value;
      if (R && fn(re)) {
        if (le && fn(N) && re.form && N.items) {
          const ee = {};
          N.items.forEach((be) => {
            const { field: we, itemRender: Te } = be;
            if (we) {
              let ze = null;
              if (Te) {
                const { defaultValue: st } = Te;
                r.isFunction(st) ? ze = st({ item: be }) : r.isUndefined(st) || (ze = st);
              }
              ee[we] = ze;
            }
          }), u.formData = ee;
        }
        F || (u.proxyInited = !0, re.autoLoad !== !1 && me().then(() => ve.commitProxy("_init")).then((ee) => {
          ve.dispatchEvent("proxy-query", Object.assign(Object.assign({}, ee), { isInited: !0 }), new Event("init"));
        }));
      }
    }, Re = (R) => {
      const le = Y.value;
      Au.hasKey(R, jF.ESCAPE) && u.isZMax && le.escRestore !== !1 && Ne.triggerZoomEvent(R);
    }, ve = {
      dispatchEvent: (R, le, F) => {
        i(R, HF(F, { $grid: I }, le));
      },
      /**
       * 提交指令，支持 code 或 button
       * @param {String/Object} code 字符串或对象
       */
      commitProxy(R, ...le) {
        const { toolbarConfig: F, pagerConfig: re, editRules: N, validConfig: ee } = e, { tablePage: be } = u, we = Q.value, Te = V.value, ze = C.value, st = Z.value, ct = ue.value, { beforeQuery: Ke, afterQuery: wt, beforeDelete: St, afterDelete: Dt, beforeSave: Wt, afterSave: nn, ajax: zt = {} } = ze, At = ze.response || ze.props || {}, Ee = p.value, Ye = H();
        let rt = null, Ot = null;
        if (r.isString(R)) {
          const { buttons: Bt } = ct, Gt = F && fn(ct) && Bt ? r.findTree(Bt, (Qt) => Qt.code === R, { children: "dropdowns" }) : null;
          rt = Gt ? Gt.item : null, Ot = R;
        } else
          rt = R, Ot = rt.code;
        const Jt = rt ? rt.params : null;
        switch (Ot) {
          case "insert":
            return Ee.insert({});
          case "insert_edit":
            return Ee.insert({}).then(({ row: Bt }) => Ee.setEditRow(Bt));
          case "insert_actived":
            return Ee.insert({}).then(({ row: Bt }) => Ee.setEditRow(Bt));
          case "mark_cancel":
            A(Ot);
            break;
          case "remove":
            return fe(Ot, "vxe.grid.removeSelectRecord", () => Ee.removeCheckboxRow());
          case "import":
            Ee.importData(Jt);
            break;
          case "open_import":
            Ee.openImport(Jt);
            break;
          case "export":
            Ee.exportData(Jt);
            break;
          case "open_export":
            Ee.openExport(Jt);
            break;
          case "reset_custom":
            return Ee.resetCustom(!0);
          case "_init":
          case "reload":
          case "query": {
            const Bt = zt.query, Gt = zt.querySuccess, Qt = zt.queryError;
            if (Bt) {
              const U = Ot === "_init", Lt = Ot === "reload";
              let on = [], en = [], hn = {};
              if (re && ((U || Lt) && (be.currentPage = 1), fn(st) && (hn = Object.assign({}, be))), U) {
                let mn = null;
                if (Ee) {
                  const { computeSortOpts: gn } = Ee.getComputeMaps();
                  mn = gn.value.defaultSort;
                }
                mn && (r.isArray(mn) || (mn = [mn]), on = mn.map((gn) => ({
                  field: gn.field,
                  property: gn.field,
                  order: gn.order
                }))), Ee && (en = Ee.getCheckedFilters());
              } else
                Ee && (Lt ? Ee.clearAll() : (on = Ee.getSortColumns(), en = Ee.getCheckedFilters()));
              const En = {
                code: Ot,
                button: rt,
                isInited: U,
                isReload: Lt,
                $grid: I,
                page: hn,
                sort: on.length ? on[0] : {},
                sorts: on,
                filters: en,
                form: Ye,
                options: Bt
              };
              return u.sortData = on, u.filterData = en, u.tableLoading = !0, Promise.resolve((Ke || Bt)(En, ...le)).then((mn) => {
                if (u.tableLoading = !1, mn)
                  if (re && fn(st)) {
                    const gn = At.total, Sn = (r.isFunction(gn) ? gn({ data: mn, $grid: I }) : r.get(mn, gn || "page.total")) || 0;
                    be.total = r.toNumber(Sn);
                    const Fn = At.result;
                    u.tableData = (r.isFunction(Fn) ? Fn({ data: mn, $grid: I }) : r.get(mn, Fn || "result")) || [];
                    const co = Math.max(Math.ceil(Sn / be.pageSize), 1);
                    be.currentPage > co && (be.currentPage = co);
                  } else {
                    const gn = At.list;
                    u.tableData = (gn ? r.isFunction(gn) ? gn({ data: mn, $grid: I }) : r.get(mn, gn) : mn) || [];
                  }
                else
                  u.tableData = [];
                return wt && wt(En, ...le), Gt && Gt(Object.assign(Object.assign({}, En), { response: mn })), { status: !0 };
              }).catch((mn) => (u.tableLoading = !1, Qt && Qt(Object.assign(Object.assign({}, En), { response: mn })), { status: !1 }));
            } else
              process.env.NODE_ENV === "development" && Ut("vxe.error.notFunc", ["proxy-config.ajax.query"]);
            break;
          }
          case "delete": {
            const Bt = zt.delete, Gt = zt.deleteSuccess, Qt = zt.deleteError;
            if (Bt) {
              const U = E.getCheckboxRecords(), Lt = U.filter((hn) => !Ee.isInsertByRow(hn)), en = { $grid: I, code: Ot, button: rt, body: { removeRecords: Lt }, form: Ye, options: Bt };
              if (U.length)
                return fe(Ot, "vxe.grid.deleteSelectRecord", () => Lt.length ? (u.tableLoading = !0, Promise.resolve((St || Bt)(en, ...le)).then((hn) => (u.tableLoading = !1, Ee.setPendingRow(Lt, !1), Te && Ce.modal && Ce.modal.message({ content: j(hn, "vxe.grid.delSuccess"), status: "success" }), Dt ? Dt(en, ...le) : ve.commitProxy("query"), Gt && Gt(Object.assign(Object.assign({}, en), { response: hn })), { status: !0 })).catch((hn) => (u.tableLoading = !1, Te && Ce.modal && Ce.modal.message({ id: Ot, content: j(hn, "vxe.grid.operError"), status: "error" }), Qt && Qt(Object.assign(Object.assign({}, en), { response: hn })), { status: !1 }))) : Ee.remove(U));
              we && Ce.modal && Ce.modal.message({ id: Ot, content: El("vxe.grid.selectOneRecord"), status: "warning" });
            } else
              process.env.NODE_ENV === "development" && Ut("vxe.error.notFunc", ["proxy-config.ajax.delete"]);
            break;
          }
          case "save": {
            const Bt = zt.save, Gt = zt.saveSuccess, Qt = zt.saveError;
            if (Bt) {
              const U = Ee.getRecordset(), { insertRecords: Lt, removeRecords: on, updateRecords: en, pendingRecords: hn } = U, En = { $grid: I, code: Ot, button: rt, body: U, form: Ye, options: Bt };
              Lt.length && (U.pendingRecords = hn.filter((gn) => Ee.findRowIndexOf(Lt, gn) === -1)), hn.length && (U.insertRecords = Lt.filter((gn) => Ee.findRowIndexOf(hn, gn) === -1));
              let mn = Promise.resolve();
              return N && (mn = Ee[ee && ee.msgMode === "full" ? "fullValidate" : "validate"](U.insertRecords.concat(en))), mn.then((gn) => {
                if (!gn) {
                  if (U.insertRecords.length || on.length || en.length || U.pendingRecords.length)
                    return u.tableLoading = !0, Promise.resolve((Wt || Bt)(En, ...le)).then((Sn) => (u.tableLoading = !1, Ee.clearPendingRow(), Te && Ce.modal && Ce.modal.message({ content: j(Sn, "vxe.grid.saveSuccess"), status: "success" }), nn ? nn(En, ...le) : ve.commitProxy("query"), Gt && Gt(Object.assign(Object.assign({}, En), { response: Sn })), { status: !0 })).catch((Sn) => (u.tableLoading = !1, Te && Ce.modal && Ce.modal.message({ id: Ot, content: j(Sn, "vxe.grid.operError"), status: "error" }), Qt && Qt(Object.assign(Object.assign({}, En), { response: Sn })), { status: !1 }));
                  we && Ce.modal && Ce.modal.message({ id: Ot, content: El("vxe.grid.dataUnchanged"), status: "info" });
                }
              });
            } else
              process.env.NODE_ENV === "development" && Ut("vxe.error.notFunc", ["proxy-config.ajax.save"]);
            break;
          }
          default: {
            const Bt = _F.get(Ot);
            if (Bt) {
              const Gt = Bt.tableCommandMethod || Bt.commandMethod;
              Gt ? Gt({ code: Ot, button: rt, $grid: I, $table: Ee }, ...le) : process.env.NODE_ENV === "development" && Ut("vxe.error.notCommands", [Ot]);
            }
          }
        }
        return me();
      },
      zoom() {
        return u.isZMax ? ve.revert() : ve.maximize();
      },
      isMaximized() {
        return u.isZMax;
      },
      maximize() {
        return de(!0);
      },
      revert() {
        return de();
      },
      getFormData: H,
      getFormItems(R) {
        const le = G.value, { formConfig: F } = e, { items: re } = le, N = [];
        return r.eachTree(F && fn(le) && re ? re : [], (ee) => {
          N.push(ee);
        }, { children: "children" }), r.isUndefined(R) ? N : N[R];
      },
      getProxyInfo() {
        const R = p.value;
        if (e.proxyConfig) {
          const { sortData: le } = u;
          return {
            data: u.tableData,
            filter: u.filterData,
            form: H(),
            sort: le.length ? le[0] : {},
            sorts: le,
            pager: u.tablePage,
            pendingRecords: R ? R.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    process.env.NODE_ENV === "development" && (ve.loadColumn = (R) => {
      const le = p.value;
      return r.eachTree(R, (F) => {
        F.slots && r.each(F.slots, (re) => {
          r.isFunction(re) || s[re] || Ut("vxe.error.notSlot", [re]);
        });
      }), le ? le.loadColumn(R) : me();
    }, ve.reloadColumn = (R) => (E.clearAll(), ve.loadColumn(R)));
    const Ne = {
      extendTableMethods: b,
      callSlot(R, le) {
        return R && (r.isString(R) && (R = s[R] || null), r.isFunction(R)) ? cs(R(le)) : [];
      },
      /**
       * 获取需要排除的高度
       */
      getExcludeHeight() {
        const { height: R } = e, { isZMax: le } = u, F = d.value, re = S.value, N = x.value, ee = h.value, be = O.value, we = g.value;
        return (le || !(R === "auto" || R === "100%") ? 0 : td(F.parentNode)) + td(F) + gi(re) + gi(N) + gi(ee) + gi(be) + gi(we);
      },
      getParentHeight() {
        const R = d.value;
        return R ? (u.isZMax ? qc().visibleHeight : r.toNumber(getComputedStyle(R.parentNode).height)) - Ne.getExcludeHeight() : 0;
      },
      triggerToolbarCommitEvent(R, le) {
        const { code: F } = R;
        return ve.commitProxy(R, le).then((re) => {
          F && re && re.status && ["query", "reload", "delete", "save"].includes(F) && ve.dispatchEvent(F === "delete" || F === "save" ? `proxy-${F}` : "proxy-query", Object.assign(Object.assign({}, re), { isReload: F === "reload" }), le);
        });
      },
      triggerToolbarBtnEvent(R, le) {
        Ne.triggerToolbarCommitEvent(R, le), ve.dispatchEvent("toolbar-button-click", { code: R.code, button: R }, le);
      },
      triggerToolbarTolEvent(R, le) {
        Ne.triggerToolbarCommitEvent(R, le), ve.dispatchEvent("toolbar-tool-click", { code: R.code, tool: R }, le);
      },
      triggerZoomEvent(R) {
        ve.zoom(), ve.dispatchEvent("zoom", { type: u.isZMax ? "max" : "revert" }, R);
      }
    };
    Object.assign(I, E, ve, Ne);
    const q = ke(0);
    lt(() => e.columns ? e.columns.length : -1, () => {
      q.value++;
    }), lt(() => e.columns, () => {
      q.value++;
    }), lt(q, () => {
      me(() => I.loadColumn(e.columns || []));
    }), lt(() => e.toolbarConfig, () => {
      B();
    }), lt(() => e.pagerConfig, () => {
      ce();
    }), lt(() => e.proxyConfig, () => {
      De();
    }), WF.forEach((R) => {
      const { setupGrid: le } = R;
      if (le) {
        const F = le(I);
        F && r.isObject(F) && Object.assign(I, F);
      }
    }), ce(), wn(() => {
      process.env.NODE_ENV === "development" && me(() => {
        e.formConfig && (a || Ut("vxe.error.reqComp", ["vxe-form"])), e.pagerConfig && (c || Ut("vxe.error.reqComp", ["vxe-pager"]));
      }), me(() => {
        const { columns: R } = e;
        R && R.length && I.loadColumn(R), B(), De();
      }), Au.on(I, "keydown", Re);
    }), $n(() => {
      Au.off(I, "keydown");
    });
    const z = () => {
      const R = m.value, le = K.value;
      return o("div", {
        ref: d,
        class: ["vxe-grid", {
          [`size--${R}`]: R,
          "is--animat": !!e.animat,
          "is--round": e.round,
          "is--maximize": u.isZMax,
          "is--loading": e.loading || u.tableLoading
        }],
        style: le
      }, Et());
    };
    return I.renderVN = z, bn("$xeGrid", I), I;
  },
  render() {
    return this.renderVN();
  }
}), uv = Object.assign({}, Fl, {
  install(e) {
    e.component(Fl.name, Fl);
  }
});
Ce.dynamicApp && Ce.dynamicApp.component(Fl.name, Fl);
Ce.component(Fl);
const GF = uv, KF = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择",
      comma: "，",
      fullStop: "。"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      downErr: "下载失败",
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入",
      treeCrossDrag: "只能拖拽第一层级的数据",
      treeDragChild: "父级数据不能拖拽到子级中",
      reqPlugin: '可选扩展插件 "{1}" https://vxeui.com/other{0}/#/{1}/install'
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "序号",
      actionTitle: "操作",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expError: "导出失败",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customClose: "关闭",
      customCancel: "取消",
      customRestore: "恢复默认",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个",
      dragTip: "移动：{0}"
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      gotoTitle: "页数",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整列的排序",
        colTitle: "标题",
        colResizable: "列宽（像素）",
        colVisible: "是否显示",
        colFixed: "冻结列",
        colFixedMax: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖方式（直接覆盖表格数据）",
        insert: "底部追加（在表格的底部追加新数据）",
        insertTop: "顶部追加（在表格的顶部追加新数据）",
        insertBottom: "底部追加（在表格的底部追加新数据）"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impMode: "导入模式",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开层级",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      errTitle: "错误提示",
      zoomMin: "最小化",
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭",
      miniMaxSize: "最小化窗口的数量不能超过 {0} 个",
      footPropErr: "show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用"
    },
    drawer: {
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelFixed: "取消冻结列"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "周",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    imagePreview: {
      popupTitle: "预览",
      operBtn: {
        zoomOut: "缩小",
        zoomIn: "放大",
        pctFull: "等比例缩放",
        pct11: "显示原始尺寸",
        rotateLeft: "向左旋转",
        rotateRight: "向右旋转",
        print: "点击打印图片",
        download: "点击下载图片"
      }
    },
    upload: {
      fileBtnText: "点击或拖拽上传",
      imgBtnText: "点击或拖拽上传",
      dragPlaceholder: "请把文件拖放到这个区域即可上传",
      imgSizeHint: "单张{0}",
      imgCountHint: "最多{0}张",
      fileTypeHint: "支持 {0} 文件类型",
      fileSizeHint: "单个文件大小不超过{0}",
      fileCountHint: "最多可上传{0}个文件",
      uploadTypeErr: "文件类型不匹配！",
      overCountErr: "最多只能选择{0}个文件！",
      overCountExtraErr: "已超出最大数量{0}个，超出的{1}个文件将被忽略！",
      overSizeErr: "文件大小最大不能超过{0}！",
      reUpload: "重新上传",
      uploadProgress: "上传中 {0}%",
      uploadErr: "上传失败",
      uploadSuccess: "上传成功",
      moreBtnText: "更多（{0}）",
      viewItemTitle: "点击查看",
      morePopup: {
        readTitle: "查看列表",
        imageTitle: "上传图片",
        fileTitle: "上传文件"
      }
    },
    empty: {
      defText: "暂无数据"
    },
    formDesign: {
      formName: "表单名称",
      defFormTitle: "未命名的表单",
      widgetPropTab: "控件属性",
      widgetFormTab: "表单属性",
      error: {
        wdFormUni: "该类型的控件在表单中只允许添加一个",
        wdSubUni: "该类型的控件在子表中只允许添加一个"
      },
      styleSetting: {
        btn: "样式设置",
        title: "表单的样式设置",
        layoutTitle: "控件布局",
        verticalLayout: "上下布局",
        horizontalLayout: "横向布局",
        styleTitle: "标题样式",
        boldTitle: "标题加粗",
        fontBold: "加粗",
        fontNormal: "常规",
        colonTitle: "显示冒号",
        colonVisible: "显示",
        colonHidden: "隐藏",
        alignTitle: "对齐方式",
        widthTitle: "标题宽度",
        alignLeft: "居左",
        alignRight: "居右",
        unitPx: "像素",
        unitPct: "百分比"
      },
      widget: {
        group: {
          base: "基础控件",
          layout: "布局控件",
          system: "系统控件",
          module: "模块控件",
          chart: "图表控件",
          advanced: "高级控件"
        },
        copyTitle: "副本_{0}",
        component: {
          input: "输入框",
          textarea: "文本域",
          select: "下拉选择",
          row: "一行多列",
          title: "标题",
          text: "文本",
          subtable: "子表",
          VxeSwitch: "是/否",
          VxeInput: "输入框",
          VxeNumberInput: "数字",
          VxeDatePicker: "日期",
          VxeTextarea: "文本域",
          VxeSelect: "下拉选择",
          VxeTreeSelect: "树形选择",
          VxeRadioGroup: "单选框",
          VxeCheckboxGroup: "复选框",
          VxeUploadFile: "文件",
          VxeUploadImage: "图片",
          VxeRate: "评分",
          VxeSlider: "滑块"
        }
      },
      widgetProp: {
        name: "控件名称",
        placeholder: "提示语",
        required: "必填校验",
        multiple: "允许多选",
        displaySetting: {
          name: "显示设置",
          pc: "电脑端",
          mobile: "手机端",
          visible: "显示",
          hidden: "隐藏"
        },
        dataSource: {
          name: "数据源",
          defValue: "选项{0}",
          addOption: "添加选项",
          batchEditOption: "批量编辑",
          batchEditTip: "每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。",
          batchEditSubTip: "每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。",
          buildOption: "生成选项"
        },
        rowProp: {
          colSize: "列数",
          col2: "两列",
          col3: "三列",
          col4: "四列",
          col6: "六列",
          layout: "布局"
        },
        textProp: {
          name: "内容",
          alignTitle: "对齐方式",
          alignLeft: "居左",
          alignCenter: "居中",
          alignRight: "居右",
          colorTitle: "字体颜色",
          sizeTitle: "字体大小",
          boldTitle: "字体加粗",
          fontNormal: "常规",
          fontBold: "加粗"
        },
        subtableProp: {
          seqTitle: "序号",
          showSeq: "显示序号",
          showCheckbox: "允许多选",
          errSubDrag: "子表不支持该控件，请使用其他控件",
          colPlace: "将控件拖拽进来"
        },
        uploadProp: {
          limitFileCount: "文件数量限制",
          limitFileSize: "文件大小限制",
          multiFile: "允许上传多个文件",
          limitImgCount: "图片数量限制",
          limitImgSize: "图片大小限制",
          multiImg: "允许上传多张图片"
        }
      }
    },
    listDesign: {
      fieldSettingTab: "字段设置",
      listSettingTab: "参数设置",
      searchTitle: "查询条件",
      listTitle: "列表字段",
      searchField: "查询字段",
      listField: "列表字段",
      activeBtn: {
        ActionButtonUpdate: "编辑",
        ActionButtonDelete: "删除"
      },
      search: {
        addBtn: "编辑",
        emptyText: "未配置查询条件",
        editPopupTitle: "编辑查询字段"
      },
      searchPopup: {
        colTitle: "标题",
        saveBtn: "保存"
      }
    },
    text: {
      copySuccess: "已复制到剪贴板",
      copyError: "当前环境不支持该操作"
    },
    countdown: {
      formats: {
        yyyy: "年",
        MM: "月",
        dd: "天",
        HH: "时",
        mm: "分",
        ss: "秒"
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          selectErr: "无法操作指定区域的单元格",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结到左侧",
          fixedRight: "冻结到右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
};
if (!Ce.hasLanguage("zh-CN")) {
  const e = "zh-CN";
  Ce.setI18n(e, KF), Ce.setLanguage(e);
}
Ce.setTheme("light");
const YF = { class: "h-grid-toolbar-left" }, XF = { class: "h-grid-toolbar-right" }, em = {
  __name: "index",
  props: {
    autoLoad: { type: Boolean, default: !0 },
    loading: { type: [Boolean, Object], default: null },
    data: { type: [Array, Function], default: () => [] },
    query: { type: [Object, Function], default: () => ({}) },
    columns: { type: Array, default: () => [] },
    height: { type: [Number, String, Boolean], default: "auto" },
    autoResize: { type: Boolean, default: !0 },
    stripe: { type: Boolean, default: !0 },
    border: { type: [Boolean, String], default: "inner" },
    showHeader: { type: Boolean, default: !0 },
    pagerConfig: { type: [Boolean, Object], default: !0 },
    proxyConfig: { type: Object, default: null },
    treeConfig: { type: Object, default: null },
    editConfig: { type: Object, default: null },
    sortConfig: { type: Object, default: null }
  },
  setup(e, { expose: t, emit: n }) {
    const s = {
      scrollY: {
        enabled: !1
      }
    }, i = {
      total: 0,
      currentPage: 1,
      pageSize: 20,
      pageSizes: [10, 20, 50, 100, 500],
      align: "right",
      layouts: [
        "Total",
        "Sizes",
        "PrevJump",
        "PrevPage",
        "Number",
        "NextPage",
        "NextJump",
        "FullJump"
      ],
      perfect: !0
    }, l = {
      seq: !0,
      sort: !0,
      filter: !0,
      form: !0,
      ajax: {
        query: null
      },
      autoLoad: !0
    }, a = {
      trigger: "cell",
      remote: !0
    }, c = e, m = n, u = ke(null), d = hb(), p = vb(), w = ["toolbar", "toolbar-left", "toolbar-right"], v = _(() => ({
      ...S.value,
      ...x.value,
      ...h.value,
      ...O.value
    })), D = _(() => Object.keys(p).reduce((Y, K) => (K !== "input" && (Y[K] = (...L) => m(K, ...L)), Y), {})), S = _(() => {
      const Y = {
        ...s,
        ...c,
        ...p
      };
      return typeof Y.height == "boolean" && (Y.height = Y.height ? void 0 : "auto"), delete Y.data, delete Y.query, Y;
    }), x = _(() => {
      let Y = null;
      return c.pagerConfig === !0 ? Y = i : c.pagerConfig instanceof Object && (Y = { ...i, ...c.pagerConfig }), { pagerConfig: Y };
    }), h = _(() => {
      var K;
      const Y = { data: null, proxyConfig: null };
      return Array.isArray(c.data) ? Y.data = c.data : typeof c.data == "function" && (Y.proxyConfig = {
        ...l,
        autoLoad: c.autoLoad,
        ...c.proxyConfig,
        ajax: {
          ...l.ajax,
          query: V,
          ...(K = c.proxyConfig) == null ? void 0 : K.ajax
        }
      }), Y;
    }), O = _(() => {
      let Y = null;
      return typeof c.data == "function" && (Y = { ...a, ...c.sortConfig }), { sortConfig: Y };
    }), g = _(
      () => Object.keys(d).filter((Y) => !w.includes(Y))
    ), b = _(
      () => Object.keys(d).filter((Y) => !w.includes(Y))
    ), E = _(() => Object.keys(d).includes("toolbar")), C = _(() => {
      const Y = Object.keys(d);
      return Y.includes("toolbar-left") || Y.includes("toolbar-right");
    }), V = async (Y, K) => {
      var ye;
      (ye = u.value) == null || ye.scrollTo(0, 0);
      const L = !!x.value.pagerConfig;
      try {
        if (typeof c.data == "function") {
          K = Q(Y, K);
          const { data: se } = await Promise.resolve(c.data(K)), P = { total: 0, rows: [], ...se };
          return Z(P), L ? { page: { total: se.total }, result: se.rows } : se.rows;
        }
        return [];
      } catch (se) {
        return console.error(`Error H-Grid: ${se}`), L ? { page: { total: 0 }, result: [] } : [];
      }
    }, Q = (Y, K) => {
      let L = {}, ye = {};
      if (Y)
        ye = Y.sort, L = Y.page;
      else if (u.value) {
        const P = u.value.getProxyInfo();
        ye = P == null ? void 0 : P.sort, L = P == null ? void 0 : P.pager;
      }
      let se = {
        limit: (L == null ? void 0 : L.pageSize) || 0,
        size: (L == null ? void 0 : L.pageSize) || 0,
        offset: L ? (L.currentPage - 1) * L.pageSize : 0,
        current: (L == null ? void 0 : L.currentPage) || 1,
        sort: ye && (ye.sortBy || ye.field || ye.property) || "",
        order: (ye == null ? void 0 : ye.order) || "",
        pageSize: (L == null ? void 0 : L.pageSize) || 0,
        pageIndex: (L == null ? void 0 : L.currentPage) || 1
      };
      return typeof c.query == "function" ? c.query(se) : c.query instanceof Object && Object.assign(se, c.query), { ...se, ...K };
    }, Z = (Y) => {
      if (u.value && Y.rows.length === 0 && Y.total > 0) {
        const K = u.value.getProxyInfo(), L = K == null ? void 0 : K.pager, ye = L ? (L.currentPage - 1) * L.pageSize : 0;
        G({
          limit: (L == null ? void 0 : L.pageSize) || 0,
          size: (L == null ? void 0 : L.pageSize) || 0,
          offset: ye > 0 ? ye - ((L == null ? void 0 : L.pageSize) || 0) : 0,
          current: (L == null ? void 0 : L.currentPage) || 1,
          pageSize: (L == null ? void 0 : L.pageSize) || 0,
          pageIndex: (L == null ? void 0 : L.currentPage) || 1
        });
      }
      return !0;
    }, G = (Y) => {
      v.value.proxyConfig && u.value && u.value.commitProxy("query", Y);
    };
    return t({
      vxeGrid: u,
      httpRequest: V,
      queryParams: Q,
      validatePage: Z,
      refresh: G,
      getSelected: () => u.value ? u.value.getRadioRecord() || u.value.getCheckboxRecords() || [] : []
    }), (Y, K) => (bb(), xb(yb(GF), Cb({
      ref_key: "vxeGrid",
      ref: u,
      class: "h-grid"
    }, v.value, wb(D.value)), Eb({
      toolbar: cu(() => [
        uu("div", {
          class: Sb({
            "h-grid-toolbar": E.value || C.value,
            "--flex": !E.value && C.value
          })
        }, [
          ci(Y.$slots, "toolbar", {}, () => [
            uu("div", YF, [
              ci(Y.$slots, "toolbar-left")
            ]),
            uu("div", XF, [
              ci(Y.$slots, "toolbar-right")
            ])
          ])
        ], 2)
      ]),
      _: 2
    }, [
      Ld(g.value, (L) => ({
        name: L,
        fn: cu(() => [
          ci(Y.$slots, L)
        ])
      })),
      Ld(b.value, (L) => ({
        name: L,
        fn: cu((ye) => [
          ci(Y.$slots, L, Db(Ob(ye)))
        ])
      }))
    ]), 1040));
  }
}, ZF = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择",
      comma: "，",
      fullStop: "。"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      downErr: "下载失败",
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入",
      treeCrossDrag: "只能拖拽第一层级的数据",
      treeDragChild: "父级数据不能拖拽到自己的子级中",
      reqPlugin: '可选扩展插件 "{1}" https://vxeui.com/other{0}/#/{1}/install'
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "序号",
      actionTitle: "操作",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expError: "导出失败",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customClose: "关闭",
      customCancel: "取消",
      customRestore: "恢复默认",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个",
      dragTip: "移动：{0}"
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      gotoTitle: "页数",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整列的排序",
        colTitle: "标题",
        colResizable: "列宽（像素）",
        colVisible: "是否显示",
        colFixed: "冻结列",
        colFixedMax: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖方式（直接覆盖表格数据）",
        insert: "底部追加（在表格的底部追加新数据）",
        insertTop: "顶部追加（在表格的顶部追加新数据）",
        insertBottom: "底部追加（在表格的底部追加新数据）"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impMode: "导入模式",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开层级",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      errTitle: "错误提示",
      zoomMin: "最小化",
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭",
      miniMaxSize: "最小化窗口的数量不能超过 {0} 个",
      footPropErr: "show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用"
    },
    drawer: {
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelFixed: "取消冻结列"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "周",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    imagePreview: {
      popupTitle: "预览",
      operBtn: {
        zoomOut: "缩小",
        zoomIn: "放大",
        pctFull: "等比例缩放",
        pct11: "显示原始尺寸",
        rotateLeft: "向左旋转",
        rotateRight: "向右旋转",
        print: "点击打印图片",
        download: "点击下载图片"
      }
    },
    upload: {
      fileBtnText: "点击或拖拽上传",
      imgBtnText: "点击或拖拽上传",
      dragPlaceholder: "请把文件拖放到这个区域即可上传",
      imgSizeHint: "单张{0}",
      imgCountHint: "最多{0}张",
      fileTypeHint: "支持 {0} 文件类型",
      fileSizeHint: "单个文件大小不超过{0}",
      fileCountHint: "最多可上传{0}个文件",
      uploadTypeErr: "文件类型不匹配！",
      overCountErr: "最多只能选择{0}个文件！",
      overCountExtraErr: "已超出最大数量{0}个，超出的{1}个文件将被忽略！",
      overSizeErr: "文件大小最大不能超过{0}！",
      reUpload: "重新上传",
      uploadProgress: "上传中 {0}%",
      uploadErr: "上传失败",
      uploadSuccess: "上传成功",
      moreBtnText: "更多（{0}）",
      viewItemTitle: "点击查看",
      morePopup: {
        readTitle: "查看列表",
        imageTitle: "上传图片",
        fileTitle: "上传文件"
      }
    },
    empty: {
      defText: "暂无数据"
    },
    formDesign: {
      formName: "表单名称",
      defFormTitle: "未命名的表单",
      widgetPropTab: "控件属性",
      widgetFormTab: "表单属性",
      error: {
        wdFormUni: "该类型的控件在表单中只允许添加一个",
        wdSubUni: "该类型的控件在子表中只允许添加一个"
      },
      styleSetting: {
        btn: "样式设置",
        title: "表单的样式设置",
        layoutTitle: "控件布局",
        verticalLayout: "上下布局",
        horizontalLayout: "横向布局",
        styleTitle: "标题样式",
        boldTitle: "标题加粗",
        fontBold: "加粗",
        fontNormal: "常规",
        colonTitle: "显示冒号",
        colonVisible: "显示",
        colonHidden: "隐藏",
        alignTitle: "对齐方式",
        widthTitle: "标题宽度",
        alignLeft: "居左",
        alignRight: "居右",
        unitPx: "像素",
        unitPct: "百分比"
      },
      widget: {
        group: {
          base: "基础控件",
          layout: "布局控件",
          system: "系统控件",
          module: "模块控件",
          chart: "图表控件",
          advanced: "高级控件"
        },
        copyTitle: "副本_{0}",
        component: {
          input: "输入框",
          textarea: "文本域",
          select: "下拉选择",
          row: "一行多列",
          title: "标题",
          text: "文本",
          subtable: "子表",
          VxeSwitch: "是/否",
          VxeInput: "输入框",
          VxeNumberInput: "数字",
          VxeDatePicker: "日期",
          VxeTextarea: "文本域",
          VxeSelect: "下拉选择",
          VxeTreeSelect: "树形选择",
          VxeRadioGroup: "单选框",
          VxeCheckboxGroup: "复选框",
          VxeUploadFile: "文件",
          VxeUploadImage: "图片",
          VxeRate: "评分",
          VxeSlider: "滑块"
        }
      },
      widgetProp: {
        name: "控件名称",
        placeholder: "提示语",
        required: "必填校验",
        multiple: "允许多选",
        displaySetting: {
          name: "显示设置",
          pc: "电脑端",
          mobile: "手机端",
          visible: "显示",
          hidden: "隐藏"
        },
        dataSource: {
          name: "数据源",
          defValue: "选项{0}",
          addOption: "添加选项",
          batchEditOption: "批量编辑",
          batchEditTip: "每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。",
          batchEditSubTip: "每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。",
          buildOption: "生成选项"
        },
        rowProp: {
          colSize: "列数",
          col2: "两列",
          col3: "三列",
          col4: "四列",
          col6: "六列",
          layout: "布局"
        },
        textProp: {
          name: "内容",
          alignTitle: "对齐方式",
          alignLeft: "居左",
          alignCenter: "居中",
          alignRight: "居右",
          colorTitle: "字体颜色",
          sizeTitle: "字体大小",
          boldTitle: "字体加粗",
          fontNormal: "常规",
          fontBold: "加粗"
        },
        subtableProp: {
          seqTitle: "序号",
          showSeq: "显示序号",
          showCheckbox: "允许多选",
          errSubDrag: "子表不支持该控件，请使用其他控件",
          colPlace: "将控件拖拽进来"
        },
        uploadProp: {
          limitFileCount: "文件数量限制",
          limitFileSize: "文件大小限制",
          multiFile: "允许上传多个文件",
          limitImgCount: "图片数量限制",
          limitImgSize: "图片大小限制",
          multiImg: "允许上传多张图片"
        }
      }
    },
    listDesign: {
      fieldSettingTab: "字段设置",
      listSettingTab: "参数设置",
      searchTitle: "查询条件",
      listTitle: "列表字段",
      searchField: "查询字段",
      listField: "列表字段",
      activeBtn: {
        ActionButtonUpdate: "编辑",
        ActionButtonDelete: "删除"
      },
      search: {
        addBtn: "编辑",
        emptyText: "未配置查询条件",
        editPopupTitle: "编辑查询字段"
      },
      searchPopup: {
        colTitle: "标题",
        saveBtn: "保存"
      }
    },
    text: {
      copySuccess: "已复制到剪贴板",
      copyError: "当前环境不支持该操作"
    },
    countdown: {
      formats: {
        yyyy: "年",
        MM: "月",
        dd: "天",
        HH: "时",
        mm: "分",
        ss: "秒"
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          selectErr: "无法操作指定区域的单元格",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结到左侧",
          fixedRight: "冻结到右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
};
let bi;
const Vs = Rt({
  modals: [],
  drawers: [],
  globalLoading: null,
  globalWatermark: null
}), JF = pt({
  setup() {
    const e = Ce.getComponent("VxeModal"), t = Ce.getComponent("VxeDrawer"), n = Ce.getComponent("VxeLoading"), s = Ce.getComponent("VxeWatermark");
    return () => {
      const { modals: i, drawers: l, globalWatermark: a, globalLoading: c } = Vs;
      return [
        i.length ? o("div", {
          key: 1,
          class: "vxe-dynamics--modal"
        }, i.map((m) => o(e, m))) : Ve(),
        l.length ? o("div", {
          key: 2,
          class: "vxe-dynamics--drawer"
        }, l.map((m) => o(t, m))) : Ve(),
        a ? o(s, a) : Ve(),
        c ? o(n, c) : Ve()
      ];
    };
  }
}), Ht = Tb(JF);
function Yc() {
  bi || (bi = document.createElement("div"), bi.className = "vxe-dynamics", document.body.appendChild(bi), Ht.mount(bi));
}
function xs(e) {
  return e && e.enabled !== !1;
}
function ds() {
  return Zi.getNext();
}
function ws() {
  return Zi.getCurrent();
}
function Bn(e, t) {
  if (e) {
    const n = oe().translate;
    return r.toValueString(n ? n("" + e, t) : e);
  }
  return "";
}
function Ei(e) {
  return e == null || e === "";
}
function tm(e) {
  return r.isBoolean(e) ? e : null;
}
const dv = "ui v4.3.23", Ar = bs.create("warn", dv), Ao = bs.create("error", dv), fv = "4.3.23";
Ce.version = fv;
Ce.uiVersion = fv;
Ce.tableVersion = "";
Ce.t = Ce.getI18n;
Ce._t = Bn;
Ce.dynamicApp = Ht;
function QF(e) {
  return process.env.NODE_ENV === "development" && Ar("vxe.error.delFunc", ["config", "setConfig"]), jc(e);
}
function eL(e) {
  return process.env.NODE_ENV === "development" && Ar("vxe.error.delFunc", ["setup", "setConfig"]), jc(e);
}
Ce.config = QF;
Ce.setup = eL;
jc({
  alert: {},
  anchor: {},
  anchorLink: {},
  avatar: {},
  badge: {},
  breadcrumb: {
    separator: "/"
  },
  breadcrumbItem: {},
  button: {
    trigger: "hover",
    prefixTooltip: {
      enterable: !0
    },
    suffixTooltip: {
      enterable: !0
    }
  },
  buttonGroup: {},
  calendar: {
    minDate: new Date(1900, 0, 1),
    maxDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  card: {
    border: !0,
    padding: !0
  },
  carousel: {
    height: 200,
    loop: !0,
    interval: 5e3
  },
  carouselItem: {},
  checkbox: {},
  checkboxGroup: {},
  col: {},
  collapse: {
    padding: !0,
    expandConfig: {
      showIcon: !0
    }
  },
  collapsePane: {},
  countdown: {},
  datePicker: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  drawer: {
    // size: null,
    position: "right",
    showHeader: !0,
    lockView: !0,
    mask: !0,
    showTitleOverflow: !0,
    showClose: !0,
    padding: !0,
    cancelClosable: !0,
    confirmClosable: !0
  },
  empty: {},
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showMessage: !0,
      autoPos: !0,
      theme: "beautify"
    },
    tooltipConfig: {
      enterable: !0
    },
    titleAsterisk: !0,
    titleOverflow: !1,
    padding: !0
  },
  formDesign: {
    height: 400,
    showHeader: !0,
    showPc: !0
  },
  formGather: {},
  formGroup: {},
  formItem: {},
  formView: {},
  icon: {},
  iconPicker: {
    icons: ["home", "company", "comment", "setting", "send", "envelope", "envelope-open", "bell", "search", "print", "pc", "goods", "chart-line", "edit", "delete", "save", "folder", "microphone", "flag", "link", "location", "sunny", "rmb", "usd", "user", "add-user", "add-users", "star", "unlock", "time", "text", "feedback", "calendar", "association-form", "cloud-download", "cloud-upload", "file", "subtable", "chart-bar-x", "chart-bar-y", "chart-line", "chart-pie", "chart-radar"]
  },
  image: {
    showPreview: !0,
    showPrintButton: !0
  },
  imageGroup: {
    showPreview: !0,
    showPrintButton: !0
  },
  imagePreview: {
    showPrintButton: !0
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: !0
  },
  layoutAside: {},
  layoutBody: {},
  layoutContainer: {},
  layoutFooter: {},
  layoutHeader: {},
  link: {
    underline: !0
  },
  listDesign: {
    height: 400,
    showPc: !0
  },
  listView: {},
  list: {
    // size: null,
    scrollY: {
      enabled: !0,
      gt: 100
      // oSize: 0
    }
  },
  loading: {
    showIcon: !0,
    showText: !0
  },
  modal: {
    // size: null,
    top: 16,
    showHeader: !0,
    minWidth: 340,
    minHeight: 140,
    lockView: !0,
    mask: !0,
    duration: 3e3,
    marginSize: 0,
    dblclickZoom: !0,
    showTitleOverflow: !0,
    animat: !0,
    showClose: !0,
    padding: !0,
    draggable: !0,
    showConfirmButton: null,
    cancelClosable: !0,
    confirmClosable: !0,
    zoomConfig: {
      minimizeMaxSize: 10,
      minimizeVerticalOffset: {
        top: -24,
        left: 0
      },
      minimizeHorizontalOffset: {
        top: 0,
        left: 32
      }
    },
    // storage: false,
    storageKey: "VXE_MODAL_POSITION"
  },
  noticeBar: {},
  numberInput: {
    // size: null,
    // transfer: false
    digits: 2,
    controls: !0
  },
  optgroup: {},
  option: {},
  pager: {
    pageSizePlacement: "top"
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  print: {},
  passwordInput: {
    controls: !0
  },
  printPageBreak: {},
  pulldown: {
    destroyOnClose: !0
  },
  radio: {
    strict: !0
  },
  radioButton: {
    strict: !0
  },
  radioGroup: {
    strict: !0
  },
  rate: {},
  result: {},
  row: {},
  select: {
    multiCharOverflow: 8,
    scrollY: {
      enabled: !0,
      gt: 100,
      oSize: 2
    }
  },
  slider: {
    max: 100,
    min: 0
  },
  steps: {},
  switch: {},
  tabPane: {},
  tableSelect: {
    gridConfig: {
      showOverflow: !0,
      showHeaderOverflow: !0,
      showFooterOverflow: !0,
      rowConfig: {
        isHover: !0
      },
      scrollX: {
        enabled: !0,
        gt: 0
      },
      scrollY: {
        mode: "wheel",
        enabled: !0,
        gt: 0
      }
    }
  },
  tabs: {},
  tag: {},
  textEllipsis: {},
  text: {},
  textarea: {
    resize: "none"
  },
  tip: {},
  tooltip: {
    // size: null,
    // enterable: false,
    trigger: "hover",
    theme: "dark",
    enterDelay: 500,
    leaveDelay: 300,
    isArrow: !0
  },
  tree: {
    indent: 20,
    minHeight: 60,
    radioConfig: {
      strict: !0
    }
  },
  treeSelect: {
    treeConfig: {
      radioConfig: {},
      checkboxConfig: {}
    }
  },
  upload: {
    mode: "all",
    imageTypes: ["jpg", "jpeg", "png", "gif"],
    showList: !0,
    showUploadButton: !0,
    showButtonText: !0,
    showRemoveButton: !0,
    showButtonIcon: !0,
    showPreview: !0,
    dragToUpload: !0,
    imageStyle: {}
  },
  watermark: {
    rotate: -30,
    gap: [100, 100]
  },
  table: {},
  colgroup: {},
  column: {},
  toolbar: {},
  grid: {}
});
const xt = "vxe-icon-";
Ch({
  // loading
  LOADING: xt + "spinner roll vxe-loading--default-icon",
  // button
  BUTTON_DROPDOWN: xt + "arrow-down",
  BUTTON_LOADING: xt + "spinner roll",
  BUTTON_TOOLTIP_ICON: xt + "question-circle-fill",
  // menu
  MENU_ITEM_EXPAND_OPEN: xt + "arrow-down rotate180",
  MENU_ITEM_EXPAND_CLOSE: xt + "arrow-down",
  // select
  SELECT_LOADED: xt + "spinner roll",
  SELECT_OPEN: xt + "caret-down rotate180",
  SELECT_CLOSE: xt + "caret-down",
  // icon-picker
  ICON_PICKER_OPEN: xt + "caret-down rotate180",
  ICON_PICKER_CLOSE: xt + "caret-down",
  // pager
  PAGER_HOME: xt + "home-page",
  PAGER_END: xt + "end-page",
  PAGER_JUMP_PREV: xt + "arrow-double-left",
  PAGER_JUMP_NEXT: xt + "arrow-double-right",
  PAGER_PREV_PAGE: xt + "arrow-left",
  PAGER_NEXT_PAGE: xt + "arrow-right",
  PAGER_JUMP_MORE: xt + "ellipsis-h",
  // radio
  RADIO_CHECKED: xt + "radio-checked-fill",
  RADIO_UNCHECKED: xt + "radio-unchecked",
  // checkbox
  CHECKBOX_INDETERMINATE: xt + "checkbox-indeterminate-fill",
  CHECKBOX_CHECKED: xt + "checkbox-checked-fill",
  CHECKBOX_UNCHECKED: xt + "checkbox-unchecked",
  // input
  INPUT_CLEAR: xt + "error-circle-fill",
  INPUT_SEARCH: xt + "search",
  // number-picker
  NUMBER_INPUT_PREV_NUM: xt + "caret-up",
  NUMBER_INPUT_NEXT_NUM: xt + "caret-down",
  // date-picker
  DATE_PICKER_DATE: xt + "calendar",
  // password-input
  PASSWORD_INPUT_SHOW_PWD: xt + "eye-fill-close",
  PASSWORD_INPUT_HIDE_PWD: xt + "eye-fill",
  // modal
  MODAL_ZOOM_MIN: xt + "minus",
  MODAL_ZOOM_REVERT: xt + "recover",
  MODAL_ZOOM_IN: xt + "square",
  MODAL_ZOOM_OUT: xt + "maximize",
  MODAL_CLOSE: xt + "close",
  MODAL_INFO: xt + "info-circle-fill",
  MODAL_SUCCESS: xt + "success-circle-fill",
  MODAL_WARNING: xt + "warning-circle-fill",
  MODAL_ERROR: xt + "error-circle-fill",
  MODAL_QUESTION: xt + "question-circle-fill",
  MODAL_LOADING: xt + "spinner roll",
  // drawer
  DRAWER_CLOSE: xt + "close",
  // form
  FORM_PREFIX: xt + "question-circle-fill",
  FORM_SUFFIX: xt + "question-circle-fill",
  FORM_FOLDING: xt + "arrow-up rotate180",
  FORM_UNFOLDING: xt + "arrow-up",
  // form-design
  FORM_DESIGN_STYLE_SETTING: xt + "layout",
  FORM_DESIGN_PROPS_PC: xt + "pc",
  FORM_DESIGN_PROPS_MOBILE: xt + "mobile",
  FORM_DESIGN_PROPS_ADD: xt + "add",
  FORM_DESIGN_PROPS_EDIT: xt + "edit",
  FORM_DESIGN_WIDGET_ADD: xt + "square-plus-fill",
  FORM_DESIGN_WIDGET_COPY: xt + "copy",
  FORM_DESIGN_WIDGET_DELETE: xt + "delete",
  FORM_DESIGN_WIDGET_SWAP_LR: xt + "swap",
  FORM_DESIGN_WIDGET_OPTION_DELETE: xt + "delete",
  FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN: xt + "square-plus",
  FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE: xt + "square-minus",
  // list-design
  LIST_DESIGN_FIELD_SETTING: xt + "custom-column",
  LIST_DESIGN_LIST_SETTING: xt + "menu",
  LIST_DESIGN_LIST_SETTING_SEARCH_DELETE: xt + "delete",
  LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE: xt + "delete",
  // upload
  UPLOAD_FILE_ERROR: xt + "warning-circle-fill",
  UPLOAD_FILE_ADD: xt + "upload",
  UPLOAD_FILE_REMOVE: xt + "delete",
  UPLOAD_FILE_DOWNLOAD: xt + "download",
  UPLOAD_IMAGE_RE_UPLOAD: xt + "repeat",
  UPLOAD_IMAGE_ADD: xt + "add",
  UPLOAD_IMAGE_REMOVE: xt + "close",
  UPLOAD_LOADING: xt + "spinner roll vxe-loading--default-icon",
  UPLOAD_FILE_TYPE_DEFAULT: xt + "file",
  UPLOAD_FILE_TYPE_XLSX: xt + "file-excel",
  UPLOAD_FILE_TYPE_XLS: xt + "file-excel",
  UPLOAD_FILE_TYPE_PDF: xt + "file-pdf",
  UPLOAD_FILE_TYPE_PNG: xt + "file-image",
  UPLOAD_FILE_TYPE_GIF: xt + "file-image",
  UPLOAD_FILE_TYPE_JPG: xt + "file-image",
  UPLOAD_FILE_TYPE_JPEG: xt + "file-image",
  UPLOAD_FILE_TYPE_MD: xt + "file-markdown",
  UPLOAD_FILE_TYPE_PPD: xt + "file-ppt",
  UPLOAD_FILE_TYPE_DOCX: xt + "file-word",
  UPLOAD_FILE_TYPE_DOC: xt + "file-word",
  UPLOAD_FILE_TYPE_ZIP: xt + "file-zip",
  UPLOAD_FILE_TYPE_TXT: xt + "file-txt",
  // image-preview
  IMAGE_PREVIEW_CLOSE: xt + "close",
  IMAGE_PREVIEW_PREVIOUS: xt + "arrow-left",
  IMAGE_PREVIEW_NEXT: xt + "arrow-right",
  IMAGE_PREVIEW_PCT_FULL: xt + "pct-full",
  IMAGE_PREVIEW_PCT_1_1: xt + "pct-1-1",
  IMAGE_PREVIEW_ZOOM_OUT: xt + "search-zoom-out",
  IMAGE_PREVIEW_ZOOM_IN: xt + "search-zoom-in",
  IMAGE_PREVIEW_ROTATE_LEFT: xt + "rotate-left",
  IMAGE_PREVIEW_ROTATE_RIGHT: xt + "rotate-right",
  IMAGE_PREVIEW_PRINT: xt + "print",
  IMAGE_PREVIEW_DOWNLOAD: xt + "download",
  // alert
  ALERT_CLOSE: xt + "close",
  ALERT_INFO: xt + "info-circle-fill",
  ALERT_SUCCESS: xt + "success-circle-fill",
  ALERT_WARNING: xt + "warning-circle-fill",
  ALERT_ERROR: xt + "error-circle-fill",
  // tree
  TREE_NODE_OPEN: xt + "caret-right rotate90",
  TREE_NODE_CLOSE: xt + "caret-right",
  TREE_NODE_LOADED: xt + "spinner roll",
  // tree-select
  TREE_SELECT_LOADED: xt + "spinner roll",
  TREE_SELECT_OPEN: xt + "caret-down rotate180",
  TREE_SELECT_CLOSE: xt + "caret-down",
  // table-select
  TABLE_SELECT_LOADED: xt + "spinner roll",
  TABLE_SELECT_OPEN: xt + "caret-down rotate180",
  TABLE_SELECT_CLOSE: xt + "caret-down",
  // tabs
  TABS_TAB_BUTTON_LEFT: xt + "arrow-left",
  TABS_TAB_BUTTON_RIGHT: xt + "arrow-right",
  TABS_TAB_CLOSE: xt + "close",
  TABS_TAB_REFRESH: xt + "refresh",
  TABS_TAB_REFRESH_LOADING: xt + "refresh roll",
  // text
  TEXT_COPY: xt + "copy",
  TEXT_LOADING: xt + "spinner roll",
  // carousel
  CAROUSEL_HORIZONTAL_PREVIOUS: xt + "arrow-left",
  CAROUSEL_HORIZONTAL_NEXT: xt + "arrow-right",
  CAROUSEL_VERTICAL_PREVIOUS: xt + "arrow-up",
  CAROUSEL_VERTICAL_NEXT: xt + "arrow-down",
  // collapse
  COLLAPSE_OPEN: xt + "arrow-right rotate90",
  COLLAPSE_CLOSE: xt + "arrow-right",
  // empty
  EMPTY_DEFAULT: xt + "empty",
  // result
  RESULT_INFO: xt + "info-circle-fill",
  RESULT_SUCCESS: xt + "success-circle-fill",
  RESULT_WARNING: xt + "warning-circle-fill",
  RESULT_ERROR: xt + "error-circle-fill",
  RESULT_QUESTION: xt + "question-circle-fill",
  RESULT_LOADING: xt + "spinner roll",
  // rate
  RATE_CHECKED: xt + "star-fill",
  RATE_UNCHECKED: xt + "star"
});
function Ll(e) {
  return "on" + e.substring(0, 1).toLocaleUpperCase() + e.substring(1);
}
function pv(e) {
  switch (e) {
    case "input":
    case "textarea":
      return "input";
    case "select":
      return "change";
  }
  return "update:modelValue";
}
function mv(e) {
  switch (e) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeTextarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function Nt(e) {
  return r.isArray(e) ? e : e ? [e] : [];
}
const Ra = pt({
  name: "VxeAlert",
  props: {
    title: {
      type: [String, Number],
      default: () => oe().alert.title
    },
    content: [String, Number],
    status: String,
    showIcon: Boolean,
    showClose: Boolean,
    icon: {
      type: String,
      default: () => oe().alert.icon
    }
  },
  emits: [
    "close"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), l = ke(), a = Rt({}), c = {
      refElem: l
    }, m = {}, u = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => m
    }, d = {
      dispatchEvent(D, S, x) {
        n(D, Zt(x, { $alert: u }, S));
      }
    }, p = (D) => {
      d.dispatchEvent("close", {}, D);
    };
    Object.assign(u, d, {});
    const v = () => {
      const { status: D, content: S, icon: x, title: h, showIcon: O, showClose: g } = e, b = s.default, E = s.title, C = s.icon;
      return o("div", {
        ref: l,
        class: ["vxe-alert", {
          [`theme--${D}`]: D
        }]
      }, [
        C || O && D || x ? o("div", {
          class: "vxe-alert--icon"
        }, C ? Nt(C({})) : [
          o("i", {
            class: x || ht()[`ALERT_${D == null ? void 0 : D.toUpperCase()}`]
          })
        ]) : Ve(),
        o("div", {
          class: "vxe-alert--body"
        }, [
          E || h ? o("div", {
            class: "vxe-alert--title"
          }, E ? Nt(E({})) : r.toValueString(h)) : Ve(),
          o("div", {
            class: "vxe-alert--content"
          }, b ? Nt(b({})) : r.toValueString(S))
        ]),
        g ? o("div", {
          class: "vxe-alert--close-btn",
          onClick: p
        }, [
          o("i", {
            class: ht().ALERT_CLOSE
          })
        ]) : Ve()
      ]);
    };
    return u.renderVN = v, u;
  },
  render() {
    return this.renderVN();
  }
}), tL = Object.assign({}, Ra, {
  install(e) {
    e.component(Ra.name, Ra);
  }
});
Ht.use(tL);
Ce.component(Ra);
const nL = r.browse(), Bu = {};
function gv(e) {
  return Bu[e] || (Bu[e] = new RegExp(`(?:^|\\s)${e}(?!\\S)`, "g")), Bu[e];
}
function hv(e, t, n) {
  if (e) {
    const s = e.parentNode;
    if (n.top += e.offsetTop, n.left += e.offsetLeft, s && s !== document.documentElement && s !== document.body && (n.top -= s.scrollTop, n.left -= s.scrollLeft), !(t && (e === t || e.offsetParent === t)) && e.offsetParent)
      return hv(e.offsetParent, t, n);
  }
  return n;
}
function ta(e, t) {
  return e && e.className && e.className.match && e.className.match(gv(t));
}
function Na(e, t) {
  e && ta(e, t) && (e.className = e.className.replace(gv(t), ""));
}
function oL(e, t) {
  e && !ta(e, t) && (Na(e, t), e.className = `${e.className} ${t}`);
}
function cn(e, t = "px") {
  return r.isNumber(e) || /^\d+$/.test(`${e}`) ? `${e}${t}` : `${e || ""}`;
}
function tl() {
  const e = document.documentElement, t = document.body;
  return {
    scrollTop: e.scrollTop || t.scrollTop,
    scrollLeft: e.scrollLeft || t.scrollLeft,
    visibleHeight: e.clientHeight || t.clientHeight,
    visibleWidth: e.clientWidth || t.clientWidth
  };
}
function jn(e, t, n, s) {
  let i, l = e.target.shadowRoot && e.composed && e.composedPath()[0] || e.target;
  for (; l && l.nodeType && l !== document; ) {
    if (n && ta(l, n) && !s)
      i = l;
    else if (l === t)
      return { flag: n ? !!i : !0, container: t, targetElem: i };
    l = l.parentNode;
  }
  return { flag: !1 };
}
function sL(e, t) {
  return hv(e, t, { left: 0, top: 0 });
}
function br(e) {
  const t = e.getBoundingClientRect(), n = t.top, s = t.left, { scrollTop: i, scrollLeft: l, visibleHeight: a, visibleWidth: c } = tl();
  return { boundingTop: n, top: i + n, boundingLeft: s, left: l + s, visibleHeight: a, visibleWidth: c };
}
const nm = "scrollIntoViewIfNeeded", om = "scrollIntoView";
function rL(e) {
  e && (e[nm] ? e[nm]() : e[om] && e[om]());
}
function lL(e, t, n, s) {
  const i = e.reactData.staticLinks, l = t.parentNode, a = s ? s.linkConfig : null, c = a ? a.children : i;
  l && c && (c.splice(r.arrayIndexOf(l.children, t), 0, n), e.reactData.staticLinks = i.slice(0));
}
function iL(e, t) {
  const n = e.reactData.staticLinks, s = r.findTree(n, (i) => i.id === t.id, { children: "children" });
  s && s.items.splice(s.index, 1), e.reactData.staticLinks = n.slice(0);
}
const Al = pt({
  name: "VxeAnchorLink",
  props: {
    content: [String, Number],
    title: [String, Number],
    href: String
  },
  emits: [],
  setup(e, t) {
    const { slots: n } = t, s = mt("$xeAnchor", null), i = mt("$xeAnchorLink", null), l = r.uniqueId(), a = ke(), c = Rt({}), m = Rt({
      id: l,
      href: e.href,
      children: []
    }), u = {
      refElem: a
    }, d = _(() => {
      const { href: S } = e;
      return s ? s.reactData.activeHref === S : null;
    }), p = {}, w = {
      xID: l,
      props: e,
      context: t,
      reactData: c,
      linkConfig: m,
      getRefMaps: () => u,
      getComputeMaps: () => p
    }, v = (S) => {
      const { href: x } = e;
      s && s.handleClickLink(S, x);
    };
    lt(() => e.href, (S) => {
      m.href = S;
    }), wn(() => {
      const S = a.value;
      s && S && lL(s, S, m, i);
    }), $n(() => {
      s && iL(s, m);
    });
    const D = () => {
      const { href: S, content: x, title: h } = e, O = n.default, g = n.sub, b = d.value;
      return o("div", {
        ref: a,
        class: ["vxe-anchor-link", {
          "is--active": b
        }]
      }, [
        o("a", {
          class: "vxe-anchor-link--item",
          href: S,
          title: h,
          onClick: v
        }, O ? O({}) : r.toValueString(x)),
        g ? o("div", {
          class: "vxe-anchor-link--sub-items"
        }, g({})) : Ve()
      ]);
    };
    return bn("$xeAnchorLink", w), w.renderVN = D, w;
  },
  render() {
    return this.renderVN();
  }
}), Fa = pt({
  name: "VxeAnchor",
  props: {
    modelValue: String,
    options: Array,
    container: [String, Object, Function],
    showMarker: {
      type: Boolean,
      default: !0
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), a = ke(), c = Rt({
      activeHref: null,
      staticLinks: [],
      containerElem: null
    }), m = {
      refElem: l
    }, u = _(() => {
      const C = [];
      return r.eachTree(c.staticLinks, (V) => {
        C.push(V.href || "");
      }, { children: "children" }), C;
    }), d = {}, p = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => d
    }, w = {
      dispatchEvent(C, V, Q) {
        s(C, Zt(Q, { $anchor: p }, V));
      }
    }, v = () => {
      const { container: C } = e;
      if (C) {
        if (r.isElement(C))
          return C;
        if (r.isString(C))
          return document.querySelector(C);
        if (r.isFunction(C))
          return C({ $anchor: p });
      }
      return null;
    }, D = (C) => {
      c.activeHref = C, s("update:modelValue", C);
    }, S = () => {
      const C = u.value, { containerElem: V } = c;
      if (V) {
        const Q = V.querySelectorAll(C.map((Z) => `${Z}`).join(","));
        for (let Z = 0; Z < Q.length; Z++) {
          const G = Q[Z];
          if (G.getBoundingClientRect().top > 0) {
            const Y = G.id;
            c.activeHref = `#${Y}`;
            break;
          }
        }
      }
    }, x = () => {
      const { containerElem: C } = c;
      C && C.removeEventListener("scroll", S);
    }, h = () => {
      const C = v();
      c.containerElem = C, C && C.addEventListener("scroll", S, {
        passive: !1
      });
    }, O = () => {
      me(() => {
        const { activeHref: C } = c, V = l.value, Q = a.value;
        if (V && Q && C) {
          const Z = V.querySelector(`[href="${C}"]`);
          if (Z) {
            const { top: G } = sL(Z, V);
            Q.style.top = `${G}px`;
          }
        }
      });
    };
    Object.assign(p, w, {
      handleClickLink(C, V) {
        C.preventDefault();
        const Q = document.getElementById(`${V}`.replace("#", ""));
        Q && Q.scrollIntoView({
          behavior: "smooth"
        }), D(V), w.dispatchEvent("click", { href: V }, C);
      }
    });
    const b = (C) => {
      const V = [];
      return C && C.forEach((Q) => {
        const Z = Q.children;
        Z && Z.length ? V.push(o(Al, {
          content: Q.content,
          title: Q.title,
          href: Q.href
        }, {
          sub: () => b(Z)
        })) : V.push(o(Al, {
          content: Q.content,
          title: Q.title,
          href: Q.href
        }));
      }), V;
    }, E = () => {
      const { options: C, showMarker: V } = e, Q = n.default;
      return o("div", {
        ref: l,
        class: ["vxe-anchor", {
          "is--marker": V
        }]
      }, [
        o("div", {
          class: "vxe-anchor--list"
        }, Q ? Q({}) : b(C)),
        V ? o("div", {
          ref: a,
          class: "vxe-anchor--marker"
        }) : Ve()
      ]);
    };
    return lt(() => e.modelValue, (C) => {
      c.activeHref = C;
    }), lt(() => c.activeHref, () => {
      O();
    }), lt(() => e.container, () => {
      x(), h();
    }), wn(() => {
      me(() => {
        h();
      });
    }), Us(() => {
      x();
    }), bn("$xeAnchor", p), p.renderVN = E, p;
  },
  render() {
    return this.renderVN();
  }
}), aL = Object.assign({}, Fa, {
  install(e) {
    e.component(Fa.name, Fa);
  }
});
Ht.use(aL);
Ce.component(Fa);
const cL = Object.assign({}, Al, {
  install(e) {
    e.component(Al.name, Al);
  }
});
Ht.use(cL);
Ce.component(Al);
const La = pt({
  name: "VxeAvatar",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    icon: String,
    src: String,
    width: [String, Number],
    height: [String, Number],
    circle: {
      type: Boolean,
      default: () => oe().avatar.circle
    },
    status: {
      type: String,
      default: () => oe().avatar.status
    },
    size: {
      type: String,
      default: () => oe().avatar.size || oe().size
    }
  },
  emits: [],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), { computeSize: i } = dn(e), l = ke(), a = Rt({}), c = {
      refElem: l
    }, m = _(() => {
      const { width: h, height: O } = e, g = {};
      return h && (g.width = cn(h)), O && (g.height = cn(O)), g;
    }), u = _(() => {
      const { count: h } = e;
      return h ? r.toNumber(h) : 0;
    }), d = {}, p = {
      xID: s,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => d
    };
    Object.assign(p, {
      dispatchEvent: (h, O, g) => {
        n(h, Zt(g, { $avatar: p }, O));
      }
    }, {});
    const S = () => {
      const { icon: h, content: O, src: g } = e;
      return h ? o("span", {
        class: "vxe-avatar--icon"
      }, [
        o("i", {
          class: h
        })
      ]) : O ? o("span", {
        class: "vxe-avatar--content"
      }, `${O}`) : g ? o("img", {
        class: "vxe-avatar--img",
        src: g
      }) : Yn();
    }, x = () => {
      const { circle: h, dot: O, status: g } = e, b = i.value, E = u.value, C = m.value;
      return o("div", {
        ref: l,
        class: ["vxe-avatar", {
          [`size--${b}`]: b,
          [`theme--${g}`]: g,
          "is--circle": h,
          "is--dot": O
        }],
        style: C
      }, [
        S(),
        E ? o("span", {
          class: "vxe-avatar--count"
        }, E > 99 ? "99+" : `${E}`) : Yn()
      ]);
    };
    return p.renderVN = x, p;
  },
  render() {
    return this.renderVN();
  }
}), uL = Object.assign({}, La, {
  install(e) {
    e.component(La.name, La);
  }
});
Ht.use(uL);
Ce.component(La);
const Aa = pt({
  name: "VxeBadge",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    size: {
      type: String,
      default: () => oe().badge.size || oe().size
    }
  },
  emits: [],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), l = ke(), { computeSize: a } = dn(e), c = Rt({}), m = {
      refElem: l
    }, u = _(() => {
      const { count: x } = e;
      return x ? r.toNumber(x) : 0;
    }), d = {}, p = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => d
    };
    Object.assign(p, {
      dispatchEvent: (x, h, O) => {
        n(x, Zt(O, { $badge: p }, h));
      }
    }, {});
    const S = () => {
      const { dot: x, content: h } = e, O = a.value, g = u.value, b = s.default;
      return o("div", {
        ref: l,
        class: ["vxe-badge", {
          [`size--${O}`]: O,
          "is--dot": x
        }]
      }, [
        b || h ? o("div", {
          class: "vxe-badge--content"
        }, b ? b({}) : `${h || ""}`) : [],
        g ? o("span", {
          class: "vxe-badge--count"
        }, g > 99 ? "99+" : `${g}`) : Yn()
      ]);
    };
    return p.renderVN = S, p;
  },
  render() {
    return this.renderVN();
  }
}), dL = Object.assign({}, Aa, {
  install(e) {
    e.component(Aa.name, Aa);
  }
});
Ht.use(dL);
Ce.component(Aa);
const Si = pt({
  name: "VxeBreadcrumbItem",
  props: {
    title: String,
    routerLink: Object
  },
  emits: [],
  setup(e, t) {
    const { slots: n } = t, s = r.uniqueId(), i = ke(), l = mt("$xeBreadcrumb", null), a = Rt({}), c = {
      refElem: i
    }, m = _(() => l ? l.props.separator : ""), u = (v) => {
      if (l) {
        const D = {
          title: e.title,
          routerLink: e.routerLink
        };
        l.handleClickLink(v, D);
      }
    }, d = {}, p = {
      xID: s,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => d
    }, w = () => {
      const { title: v, routerLink: D } = e, S = m.value, x = n.default;
      return o("span", {
        ref: i,
        class: "vxe-breadcrumb-item",
        onClick: u
      }, [
        o("span", {
          class: "vxe-breadcrumb-item--content"
        }, [
          D ? o(qo("router-link"), {
            class: "vxe-breadcrumb-item--content-link",
            title: v,
            to: D
          }, {
            default() {
              return o("span", {
                class: "vxe-breadcrumb-item--content-text"
              }, x ? x({}) : `${v || ""}`);
            }
          }) : o("span", {
            class: "vxe-breadcrumb-item--content-text"
          }, x ? x({}) : `${v || ""}`)
        ]),
        S ? o("span", {
          class: "vxe-breadcrumb-item--separator"
        }, `${S}`) : Ve()
      ]);
    };
    return p.renderVN = w, p;
  },
  render() {
    return this.renderVN();
  }
}), Ba = pt({
  name: "VxeBreadcrumb",
  props: {
    separator: {
      type: String,
      default: () => oe().breadcrumb.separator
    },
    options: Array
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), l = ke(), a = Rt({}), c = {
      refElem: l
    }, m = {}, u = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => m
    }, d = {
      dispatchEvent(D, S, x) {
        n(D, Zt(x, { $breadcrumb: u }, S));
      }
    };
    Object.assign(u, d, {
      handleClickLink(D, S) {
        d.dispatchEvent("click", { option: S }, D);
      }
    });
    const w = () => {
      const { options: D } = e;
      return D && D.length ? D.map((S) => o(Si, {
        title: S.title,
        routerLink: S.routerLink
      })) : [];
    }, v = () => {
      const D = s.default;
      return o("div", {
        ref: l,
        class: "vxe-breadcrumb"
      }, D ? D({}) : w());
    };
    return bn("$xeBreadcrumb", u), u.renderVN = v, u;
  },
  render() {
    return this.renderVN();
  }
}), fL = Object.assign({}, Ba, {
  install(e) {
    e.component(Ba.name, Ba);
  }
});
Ht.use(fL);
Ce.component(Ba);
const pL = Object.assign({}, Si, {
  install(e) {
    e.component(Si.name, Si);
  }
});
Ht.use(pL);
Ce.component(Si);
const Rr = pt({
  name: "VxeTooltip",
  props: {
    modelValue: Boolean,
    size: {
      type: String,
      default: () => oe().tooltip.size || oe().size
    },
    selector: String,
    trigger: {
      type: String,
      default: () => oe().tooltip.trigger || "hover"
    },
    theme: {
      type: String,
      default: () => oe().tooltip.theme || "dark"
    },
    content: {
      type: [String, Number],
      default: null
    },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: {
      type: Boolean,
      default: () => oe().tooltip.isArrow
    },
    enterable: {
      type: Boolean,
      default: () => oe().tooltip.enterable
    },
    enterDelay: {
      type: Number,
      default: () => oe().tooltip.enterDelay
    },
    leaveDelay: {
      type: Number,
      default: () => oe().tooltip.leaveDelay
    }
  },
  emits: [
    "update:modelValue"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = Rt({
      target: null,
      isUpdate: !1,
      visible: !1,
      tipContent: "",
      tipActive: !1,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: "",
        arrowStyle: {}
      }
    }), c = {}, m = ke(), u = {
      refElem: m
    }, d = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      internalData: c,
      getRefMaps: () => u
    };
    let p = {};
    const w = () => {
      const { tipTarget: G, tipStore: ue } = a;
      if (G) {
        const { scrollTop: Y, scrollLeft: K, visibleWidth: L } = tl(), { top: ye, left: se } = br(G), P = m.value, M = 6, I = P.offsetHeight, B = P.offsetWidth;
        let H = se, ce = ye - I - M;
        H = Math.max(M, se + Math.floor((G.offsetWidth - B) / 2)), H + B + M > K + L && (H = K + L - B - M), ye - I < Y + M && (ue.placement = "bottom", ce = ye + G.offsetHeight + M), ue.style.top = `${ce}px`, ue.style.left = `${H}px`, ue.arrowStyle.left = `${se - H + G.offsetWidth / 2}px`;
      }
    }, v = (G) => {
      G !== a.visible && (a.visible = G, a.isUpdate = !0, s("update:modelValue", G));
    }, D = () => {
      a.tipZindex < ws() && (a.tipZindex = ds());
    }, S = () => {
      a.visible ? p.close() : C(a.target || V(), e.content);
    }, x = () => {
      C(a.target || V(), e.content);
    }, h = () => {
      const { trigger: G, enterable: ue, leaveDelay: Y } = e;
      a.tipActive = !1, ue && G === "hover" ? setTimeout(() => {
        a.tipActive || p.close();
      }, Y) : p.close();
    }, O = () => {
      a.tipActive = !0;
    }, g = () => {
      const { trigger: G, enterable: ue, leaveDelay: Y } = e;
      a.tipActive = !1, ue && G === "hover" && setTimeout(() => {
        a.tipActive || p.close();
      }, Y);
    }, b = () => {
      const { tipStore: G } = a, ue = m.value;
      return ue && (ue.parentNode || document.body.appendChild(ue)), v(!0), D(), G.placement = "top", G.style = { width: "auto", left: 0, top: 0, zIndex: e.zIndex || a.tipZindex }, G.arrowStyle = { left: "50%" }, p.updatePlacement();
    }, E = () => {
      c.showDelayTip = r.debounce(() => {
        a.tipActive && b();
      }, e.enterDelay, { leading: !1, trailing: !0 });
    }, C = (G, ue) => {
      if (!n.content && (ue === "" || r.eqNull(ue)))
        return me();
      if (G) {
        const { showDelayTip: K } = c, { trigger: L, enterDelay: ye } = e;
        if (a.tipActive = !0, a.tipTarget = G, a.tipContent = ue, ye && L === "hover")
          K && K();
        else
          return b();
      }
      return me();
    }, V = () => {
      const { selector: G } = e;
      if (G) {
        if (r.isElement(G))
          return G;
        if (r.isString(G))
          return document.querySelector(G);
      }
      return null;
    };
    p = {
      dispatchEvent(G, ue, Y) {
        s(G, Zt(Y, { $tooltip: d }, ue));
      },
      open(G, ue) {
        return C(G || a.target || V(), ue);
      },
      close() {
        return a.tipTarget = null, a.tipActive = !1, Object.assign(a.tipStore, {
          style: {},
          placement: "",
          arrowStyle: null
        }), v(!1), me();
      },
      toVisible(G, ue) {
        return C(G, ue);
      },
      updatePlacement() {
        return me().then(() => {
          const { tipTarget: G } = a, ue = m.value;
          if (G && ue)
            return w(), me().then(() => {
              w();
            });
        });
      },
      isActived() {
        return a.tipActive;
      },
      setActived(G) {
        a.tipActive = !!G;
      }
    }, Object.assign(d, p);
    const Q = () => {
      const { useHTML: G } = e, { tipContent: ue } = a, Y = n.content;
      return Y ? o("div", {
        key: 1,
        class: "vxe-table--tooltip-content"
      }, Nt(Y({}))) : G ? o("div", {
        key: 2,
        class: "vxe-table--tooltip-content",
        innerHTML: ue
      }) : o("div", {
        key: 3,
        class: "vxe-table--tooltip-content"
      }, `${ue}`);
    }, Z = () => {
      const { popupClassName: G, theme: ue, isArrow: Y, enterable: K } = e, { tipActive: L, visible: ye, tipStore: se } = a, P = n.default, M = l.value;
      let I;
      return K && (I = {
        onMouseenter: O,
        onMouseleave: g
      }), o("div", Object.assign({ ref: m, class: ["vxe-table--tooltip-wrapper", `theme--${ue}`, G ? r.isFunction(G) ? G({ $tooltip: d }) : G : "", {
        [`size--${M}`]: M,
        [`placement--${se.placement}`]: se.placement,
        "is--enterable": K,
        "is--visible": ye,
        "is--arrow": Y,
        "is--active": L
      }], style: se.style }, I), [
        Q(),
        o("div", {
          class: "vxe-table--tooltip-arrow",
          style: se.arrowStyle
        }),
        ...P ? Nt(P({})) : []
      ]);
    };
    return lt(() => e.enterDelay, () => {
      E();
    }), lt(() => e.content, (G) => {
      a.tipContent = G;
    }), lt(() => e.modelValue, (G) => {
      a.isUpdate || (G ? C(a.target || V(), e.content) : p.close()), a.isUpdate = !1;
    }), wn(() => {
      me(() => {
        const { trigger: G, content: ue } = e, Y = m.value;
        if (Y) {
          const K = Y.parentNode;
          if (K) {
            a.tipContent = ue, a.tipZindex = ds(), r.arrayEach(Y.children, (ye, se) => {
              se > 1 && (K.insertBefore(ye, Y), a.target || (a.target = ye));
            }), K.removeChild(Y);
            const { target: L } = a;
            L && (G === "hover" ? (L.onmouseenter = x, L.onmouseleave = h) : G === "click" && (L.onclick = S)), e.modelValue && C(L || V(), ue);
          }
        }
      });
    }), Us(() => {
      const { target: G } = a, ue = m.value;
      if (G && (G.onmouseenter = null, G.onmouseleave = null, G.onclick = null), ue) {
        const Y = ue.parentNode;
        Y && Y.removeChild(ue);
      }
    }), E(), d.renderVN = Z, d;
  },
  render() {
    return this.renderVN();
  }
}), Vn = pt({
  name: "VxeButton",
  props: {
    /**
     * 按钮类型
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 按钮尺寸
     */
    size: {
      type: String,
      default: () => oe().button.size || oe().size
    },
    /**
     * 用来标识这一项
     */
    name: [String, Number],
    routerLink: Object,
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    /**
     * 按钮内容
     */
    content: String,
    /**
     * 固定显示下拉面板的方向
     */
    placement: String,
    /**
     * 按钮状态
     */
    status: String,
    /**
     * 标题
     */
    title: String,
    /**
     * 按钮的图标
     */
    icon: String,
    /**
     * 圆角边框
     */
    round: Boolean,
    /**
     * 圆角按钮
     */
    circle: Boolean,
    /**
     * 是否禁用
     */
    disabled: Boolean,
    /**
     * 是否加载中
     */
    loading: Boolean,
    trigger: {
      type: String,
      default: () => oe().button.trigger
    },
    align: String,
    prefixTooltip: Object,
    suffixTooltip: Object,
    /**
     * 在下拉面板关闭时销毁内容
     */
    destroyOnClose: {
      type: Boolean,
      default: () => oe().button.destroyOnClose
    },
    /**
     * 是否将弹框容器插入于 body 内
     */
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "click",
    "mouseenter",
    "mouseleave",
    "dropdown-click"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeModal", null), l = mt("$xeDrawer", null), a = mt("$xeTable", null), c = mt("$xeForm", null), m = mt("$xeButtonGroup", null), u = r.uniqueId(), { computeSize: d } = dn(e), { computePermissionInfo: p } = Qi(e), w = Rt({
      initialized: !1,
      visiblePanel: !1,
      isAniVisible: !1,
      isActivated: !1,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ""
    }), v = {
      showTime: void 0,
      tooltipTimeout: void 0
    }, D = ke(), S = ke(), x = ke(), h = {
      refElem: D
    }, O = {
      xID: u,
      props: e,
      context: t,
      reactData: w,
      internalData: v,
      getRefMaps: () => h
    };
    let g = {};
    const b = _(() => {
      const { transfer: de } = e;
      if (de === null) {
        const Ie = oe().button.transfer;
        if (r.isBoolean(Ie))
          return Ie;
        if (a || i || l || c)
          return !0;
      }
      return de;
    }), E = _(() => {
      const { disabled: de } = e, Ie = p.value;
      return de || Ie.disabled;
    }), C = _(() => {
      const { type: de } = e;
      return de ? ["submit", "reset", "button"].indexOf(de) > -1 : !1;
    }), V = _(() => {
      const { type: de, mode: Ie } = e;
      return Ie === "text" || de === "text" || m && m.props.mode === "text" ? "text" : "button";
    }), Q = _(() => {
      const { status: de } = e;
      return de || (m ? m.props.status : "");
    }), Z = _(() => {
      const { round: de } = e;
      return de || (m ? m.props.round : !1);
    }), G = _(() => {
      const { circle: de } = e;
      return de || (m ? m.props.circle : !1);
    }), ue = _(() => Object.assign({}, e.prefixTooltip)), Y = _(() => Object.assign({}, e.suffixTooltip)), K = () => {
      w.panelIndex < ws() && (w.panelIndex = ds());
    }, L = () => me().then(() => {
      const { placement: de } = e, { panelIndex: Ie } = w, je = S.value, Ue = x.value, Ae = b.value;
      if (Ue && je) {
        const _e = je.offsetHeight, it = je.offsetWidth, vt = Ue.offsetHeight, dt = Ue.offsetWidth, at = 5, Et = {
          zIndex: Ie
        }, { top: Qe, left: De, boundingTop: Re, visibleHeight: Be, visibleWidth: ve } = br(je);
        let Ne = "bottom";
        if (Ae) {
          let q = De + it - dt, z = Qe + _e;
          de === "top" ? (Ne = "top", z = Qe - vt) : de || (Re + _e + vt + at > Be && (Ne = "top", z = Qe - vt), z < at && (Ne = "bottom", z = Qe + _e)), q + dt + at > ve && (q -= q + dt + at - ve), q < at && (q = at), Object.assign(Et, {
            left: `${q}px`,
            right: "auto",
            top: `${z}px`,
            minWidth: `${it}px`
          });
        } else
          de === "top" ? (Ne = "top", Et.bottom = `${_e}px`) : de || Re + _e + vt > Be && Re - _e - vt > at && (Ne = "top", Et.bottom = `${_e}px`);
        return w.panelStyle = Et, w.panelPlacement = Ne, me();
      }
    }), ye = (de) => {
      m ? m.handleClick({ name: e.name }, de) : J("click", { $event: de }, de);
    }, se = (de) => {
      de.button === 0 && de.stopPropagation();
    }, P = (de) => {
      const Ie = de.currentTarget, je = x.value, { flag: Ue, targetElem: Ae } = jn(de, Ie, "vxe-button");
      Ue && (je && (je.dataset.active = "N"), w.visiblePanel = !1, setTimeout(() => {
        (!je || je.dataset.active !== "Y") && (w.isAniVisible = !1);
      }, 350), J("dropdown-click", { name: Ae.getAttribute("name"), $event: de }, de));
    }, M = () => {
      const de = x.value;
      de && (de.dataset.active = "Y", w.isAniVisible = !0, setTimeout(() => {
        de.dataset.active === "Y" && (w.visiblePanel = !0, K(), L(), setTimeout(() => {
          w.visiblePanel && L();
        }, 50));
      }, 20));
    }, I = (de) => {
      const { loading: Ie } = e;
      E.value || Ie || (j(), H(de));
    }, B = (de) => {
      fe(), ce(de);
    }, H = (de) => {
      J("mouseenter", {}, de);
    }, ce = (de) => {
      J("mouseleave", {}, de);
    }, A = (de) => {
      const { loading: Ie, trigger: je } = e;
      E.value || Ie || (je === "click" && (w.visiblePanel ? fe() : j()), ye(de));
    }, j = () => {
      const { trigger: de } = e, Ie = x.value;
      return Ie && (Ie.dataset.active = "Y", w.initialized || (w.initialized = !0), v.showTime = setTimeout(() => {
        Ie.dataset.active === "Y" ? M() : w.isAniVisible = !1;
      }, de === "click" ? 50 : 250)), me();
    }, fe = () => {
      const de = x.value;
      return clearTimeout(v.showTime), de ? (de.dataset.active = "N", setTimeout(() => {
        de.dataset.active !== "Y" && (w.visiblePanel = !1, setTimeout(() => {
          de.dataset.active !== "Y" && (w.isAniVisible = !1);
        }, 350));
      }, 100)) : (w.isAniVisible = !1, w.visiblePanel = !1), me();
    }, pe = () => {
      fe();
    }, ne = (de, Ie) => o(Rr, {
      useHTML: de.useHTML,
      content: de.content,
      enterable: de.enterable,
      theme: de.theme
    }, {
      default() {
        return o("i", {
          class: [`vxe-button--tooltip-${Ie}-icon`, de.icon || ht().BUTTON_TOOLTIP_ICON]
        });
      }
    }), $ = () => {
      const { content: de, icon: Ie, loading: je, prefixTooltip: Ue, suffixTooltip: Ae } = e, _e = ue.value, it = Y.value, vt = n.icon, dt = n.default, at = [];
      return Ue && at.push(ne(_e, "prefix")), je ? at.push(o("i", {
        class: ["vxe-button--loading-icon", ht().BUTTON_LOADING]
      })) : vt ? at.push(o("span", {
        class: "vxe-button--custom-icon"
      }, vt({}))) : Ie && at.push(o("i", {
        class: ["vxe-button--icon", Ie]
      })), dt ? at.push(o("span", {
        class: "vxe-button--content"
      }, dt({}))) : de && at.push(o("span", {
        class: "vxe-button--content"
      }, Bn(de))), Ae && at.push(ne(it, "suffix")), at;
    }, J = (de, Ie, je) => {
      s(de, Zt(je, { $button: O }, Ie));
    };
    g = {
      dispatchEvent: J,
      openPanel: j,
      closePanel: fe,
      focus() {
        const de = S.value;
        return de && de.focus(), me();
      },
      blur() {
        const de = S.value;
        return de && de.blur(), me();
      }
    };
    const ge = (de) => {
      const Ie = x.value;
      w.visiblePanel && !jn(de, Ie).flag && fe();
    }, Oe = (de) => {
      const Ie = E.value, { visiblePanel: je } = w;
      if (!Ie) {
        const Ue = D.value, Ae = x.value;
        w.isActivated = jn(de, Ue).flag || jn(de, Ae).flag, je && !w.isActivated && fe();
      }
    };
    Object.assign(O, g);
    const Se = () => {
      const { className: de, popupClassName: Ie, align: je, trigger: Ue, title: Ae, routerLink: _e, type: it, destroyOnClose: vt, name: dt, loading: at } = e, { initialized: Et, isAniVisible: Qe, visiblePanel: De } = w, Re = C.value, Be = V.value, ve = Q.value, Ne = Z.value, q = G.value, z = b.value, R = E.value, le = p.value, F = d.value, re = n.dropdowns;
      if (!le.visible)
        return Ve();
      if (re) {
        const N = {}, ee = {};
        return Ue === "hover" && (N.onMouseenter = I, N.onMouseleave = B, ee.onMouseenter = M, ee.onMouseleave = pe), o("div", {
          ref: D,
          class: ["vxe-button--dropdown", de ? r.isFunction(de) ? de({ $button: O }) : de : "", {
            [`size--${F}`]: F,
            "is--active": De
          }]
        }, [
          _e ? o(qo("router-link"), Object.assign({
            ref: S,
            class: ["vxe-button", "vxe-button--link", `type--${Be}`, je ? `align--${je}` : "", de ? r.isFunction(de) ? de({ $button: O }) : de : "", {
              [`size--${F}`]: F,
              [`theme--${ve}`]: ve,
              "is--round": Ne,
              "is--circle": q,
              "is--disabled": R || at,
              "is--loading": at
            }],
            title: Ae,
            name: dt,
            type: Re ? it : "button",
            disabled: R || at,
            to: _e,
            onClick: A
          }, N), {
            default() {
              return $().concat([
                o("i", {
                  class: `vxe-button--dropdown-arrow ${ht().BUTTON_DROPDOWN}`
                })
              ]);
            }
          }) : o("button", Object.assign({
            ref: S,
            class: ["vxe-button", `type--${Be}`, je ? `align--${je}` : "", de ? r.isFunction(de) ? de({ $button: O }) : de : "", {
              [`size--${F}`]: F,
              [`theme--${ve}`]: ve,
              "is--round": Ne,
              "is--circle": q,
              "is--disabled": R || at,
              "is--loading": at
            }],
            title: Ae,
            name: dt,
            type: Re ? it : "button",
            disabled: R || at,
            onClick: A
          }, N), $().concat([
            o("i", {
              class: `vxe-button--dropdown-arrow ${ht().BUTTON_DROPDOWN}`
            })
          ])),
          o(ks, {
            to: "body",
            disabled: z ? !Et : !0
          }, [
            o("div", Object.assign({ ref: x, class: ["vxe-button--dropdown-panel", Ie ? r.isFunction(Ie) ? Ie({ $button: O }) : Ie : "", {
              [`size--${F}`]: F,
              "ani--leave": Qe,
              "ani--enter": De
            }], placement: w.panelPlacement, style: w.panelStyle }, ee), Et && (De || Qe) ? [
              o("div", {
                class: "vxe-button--dropdown-wrapper",
                onMousedown: se,
                onClick: P
              }, vt && !De ? [] : re({}))
            ] : [])
          ])
        ]);
      }
      return _e ? o(qo("router-link"), {
        ref: S,
        class: ["vxe-button", "vxe-button--link", `type--${Be}`, je ? `align--${je}` : "", de ? r.isFunction(de) ? de({ $button: O }) : de : "", {
          [`size--${F}`]: F,
          [`theme--${ve}`]: ve,
          "is--round": Ne,
          "is--circle": q,
          "is--disabled": R || at,
          "is--loading": at
        }],
        title: Ae,
        name: dt,
        type: Re ? it : "button",
        disabled: R || at,
        to: _e,
        onClick: ye,
        onMouseenter: H,
        onMouseleave: ce
      }, {
        default() {
          return $();
        }
      }) : o("button", {
        ref: S,
        class: ["vxe-button", `type--${Be}`, je ? `align--${je}` : "", de ? r.isFunction(de) ? de({ $button: O }) : de : "", {
          [`size--${F}`]: F,
          [`theme--${ve}`]: ve,
          "is--round": Ne,
          "is--circle": q,
          "is--disabled": R || at,
          "is--loading": at
        }],
        title: Ae,
        name: dt,
        type: Re ? it : "button",
        disabled: R || at,
        onClick: ye,
        onMouseenter: H,
        onMouseleave: ce
      }, $());
    };
    return O.renderVN = Se, wn(() => {
      process.env.NODE_ENV === "development" && e.type === "text" && Ar("vxe.error.delProp", ["type=text", "mode=text"]), ut.on(O, "mousewheel", ge), ut.on(O, "mousedown", Oe);
    }), $n(() => {
      ut.off(O, "mousewheel"), ut.off(O, "mousedown");
    }), O;
  },
  render() {
    return this.renderVN();
  }
}), vv = Object.assign({}, Vn, {
  install(e) {
    e.component(Vn.name, Vn);
  }
});
Ht.use(vv);
Ce.component(Vn);
const _a = pt({
  name: "VxeButtonGroup",
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    circle: Boolean,
    className: [String, Function],
    disabled: Boolean,
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => oe().buttonGroup.size || oe().size
    }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = {}, a = {
      xID: i,
      props: e,
      context: t,
      getComputeMaps: () => l
    };
    dn(e);
    const { computePermissionInfo: c } = Qi(e), m = {
      dispatchEvent(p, w, v) {
        s(p, Zt(v, { $buttonGroup: a }, w));
      }
    };
    Object.assign(a, m, {
      handleClick(p, w) {
        const { options: v } = e, { name: D } = p, S = v ? v.find((x) => x.name === D) : null;
        m.dispatchEvent("click", Object.assign(Object.assign({}, p), { option: S }), w);
      }
    });
    const d = () => {
      const { className: p, options: w } = e, v = c.value, D = n.default;
      return v.visible ? o("div", {
        class: ["vxe-button-group", p ? r.isFunction(p) ? p({ $buttonGroup: a }) : p : ""]
      }, D ? D({}) : w ? w.map((S, x) => o(Vn, Object.assign({ key: x }, S))) : []) : Ve();
    };
    return a.renderVN = d, bn("$xeButtonGroup", a), a;
  },
  render() {
    return this.renderVN();
  }
}), bv = Object.assign({}, _a, {
  install(e) {
    e.component(_a.name, _a);
  }
});
Ht.use(bv);
Ce.component(_a);
function xv(e) {
  if (e) {
    const t = /* @__PURE__ */ new Date();
    let n = 0, s = 0, i = 0;
    if (r.isDate(e))
      n = e.getHours(), s = e.getMinutes(), i = e.getSeconds();
    else {
      e = r.toValueString(e);
      const l = e.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      l && (n = r.toNumber(l[1]), s = r.toNumber(l[3]), i = r.toNumber(l[5]));
    }
    return t.setHours(n), t.setMinutes(s), t.setSeconds(i), t;
  }
  return /* @__PURE__ */ new Date("");
}
function ql(e) {
  const t = e.getMonth();
  return t < 3 ? 1 : t < 6 ? 2 : t < 9 ? 3 : 4;
}
const Wa = pt({
  name: "VxeCalendar",
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: "date"
    },
    className: String,
    size: {
      type: String,
      default: () => oe().calendar.size || oe().size
    },
    multiple: Boolean,
    width: [String, Number],
    height: [String, Number],
    // date、week、month、quarter、year
    minDate: {
      type: [String, Number, Date],
      default: () => oe().calendar.minDate
    },
    maxDate: {
      type: [String, Number, Date],
      default: () => oe().calendar.maxDate
    },
    startDay: {
      type: [String, Number],
      default: () => oe().calendar.startDay
    },
    labelFormat: String,
    valueFormat: String,
    festivalMethod: {
      type: Function,
      default: () => oe().calendar.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => oe().calendar.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => oe().calendar.selectDay
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), { computeSize: i } = dn(e), l = Rt({
      selectValue: e.modelValue,
      inputValue: e.modelValue,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    }), a = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8
    }, c = ke(), m = {
      refElem: c
    }, u = {
      xID: s,
      props: e,
      context: t,
      reactData: l,
      internalData: a,
      getRefMaps: () => m
    };
    let d = {};
    const p = _(() => {
      const { height: N, width: ee } = e, be = {};
      return ee && (be.width = cn(ee)), N && (be.height = cn(N)), be;
    }), w = _(() => !1), v = _(() => ["date", "week", "month", "quarter", "year"].indexOf(e.type) > -1), D = _(() => e.minDate ? r.toStringDate(e.minDate) : null), S = _(() => e.maxDate ? r.toStringDate(e.maxDate) : null), x = _(() => ["date", "week", "month", "quarter", "year"].indexOf(e.type) > -1), h = _(() => {
      const { multiple: N } = e, { selectValue: ee } = l, be = v.value, we = b.value;
      return N && ee && be ? r.toValueString(ee).split(",").map((Te) => {
        const ze = j(Te, we);
        return r.isValidDate(ze) ? ze : null;
      }) : [];
    }), O = _(() => {
      const N = h.value, ee = b.value;
      return N.map((be) => r.toDateString(be, ee));
    }), g = _(() => {
      const N = h.value, ee = Z.value;
      return N.map((be) => r.toDateString(be, ee)).join(", ");
    }), b = _(() => {
      const { valueFormat: N } = e;
      return N || "yyyy-MM-dd";
    }), E = _(() => {
      const { selectValue: N } = l, ee = v.value, be = b.value;
      let we = null;
      if (N && ee) {
        const Te = j(N, be);
        r.isValidDate(Te) && (we = Te);
      }
      return we;
    }), C = _(() => {
      const N = D.value, { selectMonth: ee } = l;
      return ee && N ? ee <= N : !1;
    }), V = _(() => {
      const N = S.value, { selectMonth: ee } = l;
      return ee && N ? ee >= N : !1;
    }), Q = _(() => {
      const N = E.value;
      return N ? (N.getHours() * 3600 + N.getMinutes() * 60 + N.getSeconds()) * 1e3 : 0;
    }), Z = _(() => {
      const { labelFormat: N } = e, ee = v.value, be = b.value;
      return ee ? N || be || Pe(`vxe.input.date.labelFormat.${e.type}`) : null;
    }), G = _(() => {
      const { selectMonth: N, currentDate: ee } = l, { yearSize: be } = a, we = [];
      if (N && ee) {
        const Te = ee.getFullYear(), ze = N.getFullYear(), st = new Date(ze - ze % be, 0, 1);
        for (let ct = -4; ct < be + 4; ct++) {
          const Ke = r.getWhatYear(st, ct, "first"), wt = Ke.getFullYear();
          we.push({
            date: Ke,
            isCurrent: !0,
            isPrev: ct < 0,
            isNow: Te === wt,
            isNext: ct >= be,
            year: wt
          });
        }
      }
      return we;
    }), ue = _(() => {
      if (v.value) {
        const { datePanelType: ee, selectMonth: be } = l, we = G.value;
        let Te = "", ze;
        return be && (Te = be.getFullYear(), ze = be.getMonth() + 1), ee === "quarter" ? Pe("vxe.input.date.quarterLabel", [Te]) : ee === "month" ? Pe("vxe.input.date.monthLabel", [Te]) : ee === "year" ? we.length ? `${we[0].year} - ${we[we.length - 1].year}` : "" : Pe("vxe.input.date.dayLabel", [Te, ze ? Pe(`vxe.input.date.m${ze}`) : "-"]);
      }
      return "";
    }), Y = _(() => {
      const { startDay: N } = e;
      return r.toNumber(N);
    }), K = _(() => {
      const N = [];
      if (v.value) {
        let be = Y.value;
        N.push(be);
        for (let we = 0; we < 6; we++)
          be >= 6 ? be = 0 : be++, N.push(be);
      }
      return N;
    }), L = _(() => v.value ? K.value.map((be) => ({
      value: be,
      label: Pe(`vxe.input.date.weeks.w${be}`)
    })) : []), ye = _(() => {
      if (v.value) {
        const ee = L.value;
        return [{ label: Pe("vxe.input.date.weeks.w") }].concat(ee);
      }
      return [];
    }), se = _(() => {
      const N = G.value;
      return r.chunk(N, 4);
    }), P = _(() => {
      const { selectMonth: N, currentDate: ee } = l, { quarterSize: be } = a, we = [];
      if (N && ee) {
        const Te = ee.getFullYear(), ze = ql(ee), st = r.getWhatYear(N, 0, "first"), ct = st.getFullYear();
        for (let Ke = -2; Ke < be - 2; Ke++) {
          const wt = r.getWhatQuarter(st, Ke), St = wt.getFullYear(), Dt = ql(wt), Wt = St < ct;
          we.push({
            date: wt,
            isPrev: Wt,
            isCurrent: St === ct,
            isNow: St === Te && Dt === ze,
            isNext: !Wt && St > ct,
            quarter: Dt
          });
        }
      }
      return we;
    }), M = _(() => {
      const N = P.value;
      return r.chunk(N, 2);
    }), I = _(() => {
      const { selectMonth: N, currentDate: ee } = l, { monthSize: be } = a, we = [];
      if (N && ee) {
        const Te = ee.getFullYear(), ze = ee.getMonth(), st = r.getWhatYear(N, 0, "first").getFullYear();
        for (let ct = -4; ct < be - 4; ct++) {
          const Ke = r.getWhatYear(N, 0, ct), wt = Ke.getFullYear(), St = Ke.getMonth(), Dt = wt < st;
          we.push({
            date: Ke,
            isPrev: Dt,
            isCurrent: wt === st,
            isNow: wt === Te && St === ze,
            isNext: !Dt && wt > st,
            month: St
          });
        }
      }
      return we;
    }), B = _(() => {
      const N = I.value;
      return r.chunk(N, 4);
    }), H = _(() => {
      const { selectMonth: N, currentDate: ee } = l, be = [];
      if (N && ee) {
        const we = Q.value, Te = K.value, ze = ee.getFullYear(), st = ee.getMonth(), ct = ee.getDate(), Ke = N.getFullYear(), wt = N.getMonth(), St = N.getDay(), Dt = -Te.indexOf(St), Wt = new Date(r.getWhatDay(N, Dt).getTime() + we);
        for (let nn = 0; nn < 42; nn++) {
          const zt = r.getWhatDay(Wt, nn), At = zt.getFullYear(), Ee = zt.getMonth(), Ye = zt.getDate(), rt = zt < N;
          be.push({
            date: zt,
            isPrev: rt,
            isCurrent: At === Ke && Ee === wt,
            isNow: At === ze && Ee === st && Ye === ct,
            isNext: !rt && wt !== Ee,
            label: Ye
          });
        }
      }
      return be;
    }), ce = _(() => {
      const N = H.value;
      return r.chunk(N, 7);
    }), A = _(() => {
      const N = ce.value, ee = Y.value;
      return N.map((be) => {
        const we = be[0];
        return [{
          date: we.date,
          isWeekNumber: !0,
          isPrev: !1,
          isCurrent: !1,
          isNow: !1,
          isNext: !1,
          label: r.getYearWeek(we.date, ee)
        }].concat(be);
      });
    }), j = (N, ee) => r.toStringDate(N, ee), fe = (N, ee) => {
      l.inputValue = N, n("update:modelValue", N), r.toValueString(e.modelValue) !== N && d.dispatchEvent("change", { value: N }, ee);
    }, pe = (N) => {
      const { type: ee } = e, be = Z.value, we = b.value, Te = Y.value;
      let ze = null, st = "";
      if (N && (ze = j(N, we)), r.isValidDate(ze)) {
        if (st = r.toDateString(ze, be, { firstDay: Te }), be && ee === "week" && r.getWhatWeek(ze, 0, Te, Te).getFullYear() < ze.getFullYear()) {
          const Ke = be.indexOf("yyyy");
          if (Ke > -1) {
            const wt = Number(st.substring(Ke, Ke + 4));
            wt && !isNaN(wt) && (st = st.replace(`${wt}`, `${wt - 1}`));
          }
        }
      } else
        ze = null;
      l.datePanelValue = ze, l.datePanelLabel = st;
    }, ne = () => {
      const N = v.value, { inputValue: ee } = l;
      N && (pe(ee), l.inputValue = e.multiple ? g.value : l.datePanelLabel);
    }, $ = () => {
      v.value && ne();
    }, J = (N) => {
      const ee = r.getWhatMonth(N, 0, "first");
      r.isEqual(ee, l.selectMonth) || (l.selectMonth = ee);
    }, ge = (N) => {
      const { modelValue: ee, multiple: be } = e, we = b.value, Te = Y.value;
      if (e.type === "week") {
        const st = r.toNumber(e.selectDay);
        N = r.getWhatWeek(N, 0, st, Te);
      }
      const ze = r.toDateString(N, we, { firstDay: Te });
      if (J(N), l.selectValue = N, be) {
        const st = O.value;
        st.some((ct) => r.isEqual(ct, ze)) ? fe(st.filter((ct) => !r.isEqual(ct, ze)).join(","), { type: "update" }) : fe(st.concat([ze]).join(","), { type: "update" });
      } else
        r.isEqual(ee, ze) || fe(ze, { type: "update" });
    }, Oe = (N, ee) => {
      l.selectMonth = r.getWhatMonth(N, ee, "first");
    }, Se = () => {
      const N = r.getWhatDay(Date.now(), 0, "first");
      l.currentDate = N, Oe(N, 0);
    }, de = () => {
      let { datePanelType: N } = l;
      N === "month" || N === "quarter" ? N = "year" : N = "month", l.datePanelType = N;
    }, Ie = (N) => {
      const { type: ee } = e, { datePanelType: be, selectMonth: we } = l, { yearSize: Te } = a;
      C.value || (ee === "year" ? l.selectMonth = r.getWhatYear(we, -Te, "first") : ee === "month" || ee === "quarter" ? be === "year" ? l.selectMonth = r.getWhatYear(we, -Te, "first") : l.selectMonth = r.getWhatYear(we, -1, "first") : be === "year" ? l.selectMonth = r.getWhatYear(we, -Te, "first") : be === "month" ? l.selectMonth = r.getWhatYear(we, -1, "first") : l.selectMonth = r.getWhatMonth(we, -1, "first"), d.dispatchEvent("date-prev", { type: ee }, N));
    }, je = (N) => {
      Se(), e.multiple || ge(l.currentDate), d.dispatchEvent("date-today", { type: e.type }, N);
    }, Ue = (N) => {
      const { type: ee } = e, { datePanelType: be, selectMonth: we } = l, { yearSize: Te } = a;
      V.value || (ee === "year" ? l.selectMonth = r.getWhatYear(we, Te, "first") : ee === "month" || ee === "quarter" ? be === "year" ? l.selectMonth = r.getWhatYear(we, Te, "first") : l.selectMonth = r.getWhatYear(we, 1, "first") : be === "year" ? l.selectMonth = r.getWhatYear(we, Te, "first") : be === "month" ? l.selectMonth = r.getWhatYear(we, 1, "first") : l.selectMonth = r.getWhatMonth(we, 1, "first"), d.dispatchEvent("date-next", { type: ee }, N));
    }, Ae = (N) => {
      const { disabledMethod: ee } = e, { datePanelType: be } = l;
      return ee && ee({ type: be, viewType: be, date: N.date, $calendar: u });
    }, _e = (N) => {
      const { type: ee } = e, { datePanelType: be } = l;
      ee === "month" ? be === "year" ? (l.datePanelType = "month", J(N)) : ge(N) : ee === "year" ? ge(N) : ee === "quarter" ? be === "year" ? (l.datePanelType = "quarter", J(N)) : ge(N) : be === "month" ? (l.datePanelType = ee === "week" ? ee : "day", J(N)) : be === "year" ? (l.datePanelType = "month", J(N)) : ge(N);
    }, it = (N) => {
      Ae(N) || _e(N.date);
    }, vt = (N) => {
      Ae({ date: N }) || (H.value.some((be) => r.isDateSame(be.date, N, "yyyyMMdd")) || J(N), pe(N));
    }, dt = (N) => {
      Ae({ date: N }) || (G.value.some((be) => r.isDateSame(be.date, N, "yyyy")) || J(N), pe(N));
    }, at = (N) => {
      Ae({ date: N }) || (P.value.some((be) => r.isDateSame(be.date, N, "yyyyq")) || J(N), pe(N));
    }, Et = (N) => {
      Ae({ date: N }) || (I.value.some((be) => r.isDateSame(be.date, N, "yyyyMM")) || J(N), pe(N));
    }, Qe = (N) => {
      if (!Ae(N)) {
        const { datePanelType: ee } = l;
        ee === "month" ? Et(N.date) : ee === "quarter" ? at(N.date) : ee === "year" ? dt(N.date) : vt(N.date);
      }
    }, De = () => {
    }, Re = () => {
      const { type: N } = e, ee = E.value;
      ["year", "quarter", "month", "week"].indexOf(N) > -1 ? l.datePanelType = N : l.datePanelType = "day", l.currentDate = r.getWhatDay(Date.now(), 0, "first"), ee ? (Oe(ee, 0), pe(ee)) : Se();
    }, Be = (N, ee) => {
      const { festivalMethod: be } = e;
      if (be) {
        const { datePanelType: we } = l, Te = be({ type: we, viewType: we, date: N.date, $calendar: u }), ze = Te ? r.isString(Te) ? { label: Te } : Te : {}, st = ze.extra ? r.isString(ze.extra) ? { label: ze.extra } : ze.extra : null, ct = [
          o("span", {
            class: ["vxe-calendar--date-label", {
              "is-notice": ze.notice
            }]
          }, st && st.label ? [
            o("span", `${ee || ""}`),
            o("span", {
              class: ["vxe-calendar--date-label--extra", st.important ? "is-important" : "", st.className],
              style: st.style
            }, r.toValueString(st.label))
          ] : [`${ee || ""}`])
        ], Ke = ze.label;
        if (Ke) {
          const wt = r.toValueString(Ke).split(",");
          ct.push(o("span", {
            class: ["vxe-calendar--date-festival", ze.important ? "is-important" : "", ze.className],
            style: ze.style
          }, [
            wt.length > 1 ? o("span", {
              class: ["vxe-calendar--date-festival--overlap", `overlap--${wt.length}`]
            }, wt.map((St) => o("span", St.substring(0, 3)))) : o("span", {
              class: "vxe-calendar--date-festival--label"
            }, wt[0].substring(0, 3))
          ]));
        }
        return ct;
      }
      return `${ee || ""}`;
    }, ve = () => {
      const { multiple: N } = e, { datePanelType: ee, datePanelValue: be } = l, we = E.value, Te = L.value, ze = ce.value, st = h.value, ct = "yyyyMMdd";
      return [
        o("table", {
          class: `vxe-calendar--date-${ee}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tr", Te.map((Ke) => o("th", {
            class: "vxe-calendar--view-th"
          }, Ke.label))),
          ...ze.map((Ke) => o("tr", Ke.map((wt) => o("td", {
            class: ["vxe-calendar--view-td", {
              "is--prev": wt.isPrev,
              "is--current": wt.isCurrent,
              "is--now": wt.isNow,
              "is--next": wt.isNext,
              "is--disabled": Ae(wt),
              "is--selected": N ? st.some((St) => r.isDateSame(St, wt.date, ct)) : r.isDateSame(we, wt.date, ct),
              "is--hover": r.isDateSame(be, wt.date, ct)
            }],
            onClick: () => it(wt),
            onMouseenter: () => Qe(wt)
          }, Be(wt, wt.label)))))
        ])
      ];
    }, Ne = () => {
      const { multiple: N } = e, { datePanelType: ee, datePanelValue: be } = l, we = E.value, Te = ye.value, ze = A.value, st = h.value, ct = "yyyyMMdd";
      return [
        o("table", {
          class: `vxe-calendar--date-${ee}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tr", Te.map((Ke) => o("td", {
            class: "vxe-calendar--view-th"
          }, Ke.label))),
          ...ze.map((Ke) => {
            const wt = N ? Ke.some((Dt) => st.some((Wt) => r.isDateSame(Wt, Dt.date, ct))) : Ke.some((Dt) => r.isDateSame(we, Dt.date, ct)), St = Ke.some((Dt) => r.isDateSame(be, Dt.date, ct));
            return o("tr", Ke.map((Dt) => o("td", {
              class: ["vxe-calendar--view-td", {
                "is--prev": Dt.isPrev,
                "is--current": Dt.isCurrent,
                "is--now": Dt.isNow,
                "is--next": Dt.isNext,
                "is--disabled": Ae(Dt),
                "is--selected": wt,
                "is--hover": St
              }],
              // event
              onClick: () => it(Dt),
              onMouseenter: () => Qe(Dt)
            }, Be(Dt, Dt.label))));
          })
        ])
      ];
    }, q = () => {
      const { multiple: N } = e, { datePanelType: ee, datePanelValue: be } = l, we = E.value, Te = B.value, ze = h.value, st = "yyyyMM";
      return [
        o("table", {
          class: `vxe-calendar--date-${ee}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tbody", Te.map((ct) => o("tr", ct.map((Ke) => o("td", {
            class: ["vxe-calendar--view-td", {
              "is--prev": Ke.isPrev,
              "is--current": Ke.isCurrent,
              "is--now": Ke.isNow,
              "is--next": Ke.isNext,
              "is--disabled": Ae(Ke),
              "is--selected": N ? ze.some((wt) => r.isDateSame(wt, Ke.date, st)) : r.isDateSame(we, Ke.date, st),
              "is--hover": r.isDateSame(be, Ke.date, st)
            }],
            onClick: () => it(Ke),
            onMouseenter: () => Qe(Ke)
          }, Be(Ke, Pe(`vxe.input.date.months.m${Ke.month}`)))))))
        ])
      ];
    }, z = () => {
      const { multiple: N } = e, { datePanelType: ee, datePanelValue: be } = l, we = E.value, Te = M.value, ze = h.value, st = "yyyyq";
      return [
        o("table", {
          class: `vxe-calendar--date-${ee}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tbody", Te.map((ct) => o("tr", ct.map((Ke) => o("td", {
            class: ["vxe-calendar--view-td", {
              "is--prev": Ke.isPrev,
              "is--current": Ke.isCurrent,
              "is--now": Ke.isNow,
              "is--next": Ke.isNext,
              "is--disabled": Ae(Ke),
              "is--selected": N ? ze.some((wt) => r.isDateSame(wt, Ke.date, st)) : r.isDateSame(we, Ke.date, st),
              "is--hover": r.isDateSame(be, Ke.date, st)
            }],
            onClick: () => it(Ke),
            onMouseenter: () => Qe(Ke)
          }, Be(Ke, Pe(`vxe.input.date.quarters.q${Ke.quarter}`)))))))
        ])
      ];
    }, R = () => {
      const { multiple: N } = e, { datePanelType: ee, datePanelValue: be } = l, we = E.value, Te = se.value, ze = h.value, st = "yyyy";
      return [
        o("table", {
          class: `vxe-calendar--date-${ee}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tbody", Te.map((ct) => o("tr", ct.map((Ke) => o("td", {
            class: ["vxe-calendar--view-td", {
              "is--prev": Ke.isPrev,
              "is--current": Ke.isCurrent,
              "is--now": Ke.isNow,
              "is--next": Ke.isNext,
              "is--disabled": Ae(Ke),
              "is--selected": N ? ze.some((wt) => r.isDateSame(wt, Ke.date, st)) : r.isDateSame(we, Ke.date, st),
              "is--hover": r.isDateSame(be, Ke.date, st)
            }],
            onClick: () => it(Ke),
            onMouseenter: () => Qe(Ke)
          }, Be(Ke, Ke.year))))))
        ])
      ];
    }, le = () => {
      const { datePanelType: N } = l;
      switch (N) {
        case "week":
          return Ne();
        case "month":
          return q();
        case "quarter":
          return z();
        case "year":
          return R();
      }
      return ve();
    }, F = () => {
      const { multiple: N } = e, { datePanelType: ee } = l, be = C.value, we = V.value, Te = ue.value;
      return [
        o("div", {
          class: "vxe-calendar--header"
        }, [
          o("div", {
            class: "vxe-calendar--type-wrapper"
          }, [
            o(Vn, {
              disabled: ee === "year",
              content: Te,
              onClick: de
            })
          ]),
          o("div", {
            class: "vxe-calendar--btn-wrapper"
          }, [
            o(Vn, {
              disabled: be,
              icon: "vxe-icon-caret-left",
              onClick: Ie
            }),
            o(Vn, {
              icon: "vxe-icon-dot",
              onClick: je
            }),
            o(Vn, {
              disabled: we,
              icon: "vxe-icon-caret-right",
              onClick: Ue
            }),
            N && x.value ? o("span", {
              class: "vxe-calendar--btn vxe-calendar--confirm-btn"
            }, [
              o("button", {
                class: "vxe-calendar--confirm",
                type: "button",
                onClick: De
              }, Pe("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        o("div", {
          class: "vxe-calendar--body"
        }, le())
      ];
    };
    d = {
      dispatchEvent(N, ee, be) {
        n(N, Zt(be, { $input: u }, ee));
      }
    }, Object.assign(u, d);
    const re = () => {
      const { className: N, type: ee } = e, be = i.value, we = w.value, Te = p.value;
      return o("div", {
        ref: c,
        class: ["vxe-calendar", `type--${ee}`, N, {
          [`size--${be}`]: be,
          "is--disabled": we
        }],
        style: Te
      }, [
        F()
      ]);
    };
    return u.renderVN = re, lt(() => e.modelValue, (N) => {
      l.inputValue = N, ne();
    }), lt(() => e.type, () => {
      Object.assign(l, {
        selectValue: null,
        inputValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      }), $(), Re();
    }), lt(Z, () => {
      v.value && (pe(l.datePanelValue), l.inputValue = e.multiple ? g.value : l.datePanelLabel);
    }), wn(() => {
      Re();
    }), $(), u;
  },
  render() {
    return this.renderVN();
  }
}), mL = Object.assign({}, Wa, {
  install(e) {
    e.component(Wa.name, Wa);
  }
});
Ht.use(mL);
Ce.component(Wa);
const us = pt({
  name: "VxeLoading",
  props: {
    modelValue: Boolean,
    icon: {
      type: String,
      default: () => oe().loading.icon
    },
    showIcon: {
      type: Boolean,
      default: () => oe().loading.showIcon
    },
    text: {
      type: String,
      default: () => oe().loading.text
    },
    showText: {
      type: Boolean,
      default: () => oe().loading.showText
    },
    status: String,
    size: {
      type: String,
      default: () => oe().loading.size || oe().size
    }
  },
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = Rt({
      initialized: !1
    }), c = {
      computeSize: l
    }, m = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getComputeMaps: () => c
    }, u = _(() => e.icon || ht().LOADING), d = _(() => {
      const { text: x } = e;
      return r.isString(x) ? x : Pe("vxe.loading.text");
    }), p = () => {
      a.initialized || (a.initialized = !!a.initialized);
    };
    Object.assign(m, {
      dispatchEvent: (x, h, O) => {
        s(x, Zt(O, { $loading: m }, h));
      }
    }, {});
    const S = () => {
      const { modelValue: x, showIcon: h, status: O } = e, { initialized: g } = a, b = l.value, E = n.default, C = n.text, V = n.icon, Q = u.value, Z = d.value;
      return !g && !x ? Ve() : o("div", {
        class: ["vxe-loading", {
          [`size--${b}`]: b,
          [`theme--${O}`]: O,
          "is--visible": x
        }]
      }, E ? [
        o("div", {
          class: "vxe-loading--wrapper"
        }, Nt(E({})))
      ] : [
        o("div", {
          class: "vxe-loading--chunk"
        }, [
          h && (V || Q) ? o("div", {
            class: "vxe-loading--icon"
          }, V ? Nt(V({})) : [
            o("i", {
              class: Q
            })
          ]) : o("div", {
            class: "vxe-loading--spinner"
          }),
          C || Z ? o("div", {
            class: "vxe-loading--text"
          }, C ? Nt(C({})) : `${Z}`) : null
        ])
      ]);
    };
    return lt(() => e.modelValue, () => {
      p();
    }), p(), m.renderVN = S, m;
  },
  render() {
    return this.renderVN();
  }
}), za = pt({
  name: "VxeCard",
  props: {
    title: String,
    showTitleOverflow: {
      type: Boolean,
      default: () => oe().card.showTitleOverflow
    },
    width: [String, Number],
    height: [String, Number],
    border: {
      type: Boolean,
      default: () => oe().card.border
    },
    loading: Boolean,
    shadow: {
      type: Boolean,
      default: () => oe().card.shadow
    },
    padding: {
      type: Boolean,
      default: () => oe().card.padding
    }
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), a = Rt({}), c = {
      refElem: l
    }, m = _(() => {
      const { height: S, width: x } = e, h = {};
      return x && (h.width = cn(x)), S && (h.height = cn(S)), h;
    }), u = {}, d = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => u
    };
    Object.assign(d, {
      dispatchEvent: (S, x, h) => {
        s(S, Zt(h, { $card: d }, x));
      }
    }, {});
    const D = () => {
      const { title: S, border: x, shadow: h, padding: O, loading: g, showTitleOverflow: b } = e, E = n.default, C = n.header, V = n.title, Q = n.extra, Z = n.footer, G = n.left, ue = n.right, Y = m.value;
      return o("div", {
        ref: l,
        class: ["vxe-card", {
          "is--border": x,
          "is--shadow": h,
          "is--padding": O
        }],
        style: Y
      }, [
        S || V || C ? o("div", {
          class: "vxe-card--header"
        }, C ? Nt(C({})) : [
          o("div", {
            class: ["vxe-card--header-title", {
              "is--ellipsis": b
            }]
          }, V ? Nt(V({})) : `${S || ""}`),
          Q ? o("div", {
            class: "vxe-card--header-extra"
          }, Nt(Q({}))) : Ve()
        ]) : Ve(),
        o("div", {
          class: "vxe-card--body"
        }, [
          G ? o("div", {
            class: "vxe-card--body-left"
          }, Nt(G({}))) : Ve(),
          o("div", {
            class: "vxe-card--body-content"
          }, E ? Nt(E({})) : []),
          ue ? o("div", {
            class: "vxe-card--body-right"
          }, Nt(ue({}))) : Ve()
        ]),
        Z ? o("div", {
          class: "vxe-card--footer"
        }, Nt(Z({}))) : Ve(),
        /**
         * 加载中
         */
        o(us, {
          class: "vxe-card--loading",
          modelValue: g
        })
      ]);
    };
    return d.renderVN = D, d;
  },
  render() {
    return this.renderVN();
  }
}), gL = Object.assign({}, za, {
  install(e) {
    e.component(za.name, za);
  }
});
Ht.use(gL);
Ce.component(za);
const Ha = pt({
  name: "VxeCarousel",
  props: {
    modelValue: [String, Number],
    options: Array,
    loading: Boolean,
    height: {
      type: [Number, String],
      default: () => oe().carousel.height
    },
    width: {
      type: [Number, String],
      default: () => oe().carousel.width
    },
    autoPlay: {
      type: Boolean,
      default: () => oe().carousel.autoPlay
    },
    interval: {
      type: [Number, String],
      default: () => oe().carousel.interval
    },
    loop: {
      type: Boolean,
      default: () => oe().carousel.loop
    },
    vertical: {
      type: Boolean,
      default: () => oe().carousel.vertical
    },
    showIndicators: {
      type: Boolean,
      default: () => oe().carousel.showIndicators
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), l = ke(), a = ke(), c = Rt({
      activeName: "",
      staticItems: [],
      itemWidth: 0,
      itemHeight: 0
    }), m = {
      apTimeout: void 0,
      stopFlag: !1
    }, u = {
      refElem: l
    }, d = _(() => {
      const { vertical: se, options: P } = e, { activeName: M, itemWidth: I, itemHeight: B, staticItems: H } = c, ce = (H && H.length ? H : P) || [], A = Math.max(0, r.findIndexOf(ce, (fe) => fe.name === M)), j = {};
      return se ? j.transform = `translateY(-${A * B}px)` : (j.width = `${I * ce.length}px`, j.transform = `translateX(-${A * I}px)`), j;
    }), p = {}, w = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      internalData: m,
      getRefMaps: () => u,
      getComputeMaps: () => p
    }, v = () => {
      me(() => {
        const se = a.value;
        se && (c.itemWidth = se.clientWidth, c.itemHeight = se.clientHeight);
      });
    }, D = (se, P) => {
      const M = P.name;
      c.activeName = P.name, n("update:modelValue", M), n("change", { value: M }, se), v();
    }, S = (se) => {
      let P = null;
      if (se && se.length) {
        let M = !1;
        P = e.modelValue, se.forEach((I) => {
          P === I.name && (M = !0);
        }), M || (P = se[0].name, n("update:modelValue", P));
      }
      c.activeName = P;
    }, x = (se, P, M) => {
      n(se, Zt(M, { $carousel: w }, P));
    }, h = (se) => {
      const { options: P, loop: M } = e, { activeName: I, staticItems: B } = c, H = (B && B.length ? B : P) || [], ce = Math.max(0, r.findIndexOf(H, (A) => A.name === I));
      if (ce > -1) {
        let A = null;
        if (se ? ce < H.length - 1 ? A = H[ce + 1] : M && (A = H[0]) : ce > 0 ? A = H[ce - 1] : M && (A = H[H.length - 1]), A) {
          const j = A.name, fe = j;
          return c.activeName = j, n("update:modelValue", fe), !0;
        }
      }
      return !1;
    }, O = {
      dispatchEvent: x,
      prev() {
        return h(!1) && C(), me();
      },
      next() {
        return h(!0) && C(), me();
      }
    }, g = (se) => {
      if (h(!1)) {
        const P = c.activeName;
        n("change", { value: P }, se);
      }
    }, b = (se) => {
      if (h(!0)) {
        const P = c.activeName;
        n("change", { value: P }, se);
      }
    }, E = () => {
      const { apTimeout: se } = m;
      m.stopFlag = !0, se && (clearTimeout(se), m.apTimeout = void 0);
    }, C = () => {
      const { autoPlay: se, interval: P } = e, { stopFlag: M } = m;
      E(), se && (m.stopFlag = !1, m.apTimeout = setTimeout(() => {
        M || h(!0);
      }, r.toNumber(P) || 300));
    }, V = () => {
      E();
    }, Q = () => {
      C();
    }, Z = {}, G = (se, P) => se && (r.isString(se) && (se = s[se] || null), r.isFunction(se)) ? Nt(se(P)) : [];
    Object.assign(w, O, Z);
    const ue = (se) => {
      const { height: P } = e, { activeName: M } = c, I = d.value;
      return o("div", {
        class: "vxe-carousel--list",
        style: I
      }, se.map((B) => {
        const { name: H, url: ce, slots: A } = B, j = A ? A.default : null;
        return o("div", {
          key: `${H}`,
          class: ["vxe-carousel--item-inner", {
            "is--active": M === H
          }],
          style: P ? {
            height: cn(P)
          } : null
        }, j ? G(j, {}) : [
          o("img", {
            class: "vxe-carousel--item-img",
            src: ce
          })
        ]);
      }));
    }, Y = (se) => {
      const { activeName: P } = c;
      return o("div", {
        class: "vxe-carousel--indicators"
      }, se.map((M) => {
        const { name: I } = M;
        return o("div", {
          key: `${I}`,
          class: ["vxe-carousel--indicators-item", {
            "is--active": P === I
          }],
          onClick(B) {
            D(B, M);
          }
        });
      }));
    }, K = () => {
      const { loading: se, height: P, width: M, showIndicators: I, vertical: B, options: H } = e, { staticItems: ce } = c, A = s.default, j = (ce && ce.length ? ce : H) || [];
      return o("div", {
        ref: l,
        class: ["vxe-carousel", `is--${B ? "vertical" : "horizontal"}`],
        style: M ? {
          width: cn(M)
        } : null,
        onMouseenter: V,
        onMouseleave: Q
      }, [
        o("div", {
          class: "vxe-carousel--slots"
        }, A ? A({}) : []),
        o("div", {
          ref: a,
          class: "vxe-carousel--item-wrapper",
          style: P ? {
            height: cn(P)
          } : null
        }, [
          ue(j)
        ]),
        I ? Y(j) : Ve(),
        o("div", {
          class: "vxe-carousel--btn-wrapper"
        }, [
          o("div", {
            class: "vxe-carousel--previous-btn",
            onClick: g
          }, [
            o("i", {
              class: B ? ht().CAROUSEL_VERTICAL_PREVIOUS : ht().CAROUSEL_HORIZONTAL_PREVIOUS
            })
          ]),
          o("div", {
            class: "vxe-carousel--next-btn",
            onClick: b
          }, [
            o("i", {
              class: B ? ht().CAROUSEL_VERTICAL_NEXT : ht().CAROUSEL_HORIZONTAL_NEXT
            })
          ])
        ]),
        /**
         * 加载中
         */
        o(us, {
          class: "vxe-carousel--loading",
          modelValue: se
        })
      ]);
    }, L = ke(0);
    lt(() => e.options ? e.options.length : -1, () => {
      L.value++;
    }), lt(() => e.options, () => {
      L.value++;
    }), lt(L, () => {
      S(e.options);
    });
    const ye = ke(0);
    return lt(() => c.staticItems ? c.staticItems.length : -1, () => {
      ye.value++;
    }), lt(() => c.staticItems, () => {
      ye.value++;
    }), lt(ye, () => {
      S(c.staticItems);
    }), lt(() => e.autoPlay, () => {
      C();
    }), S(c.staticItems.length ? c.staticItems : e.options), wn(() => {
      C(), v();
    }), $n(() => {
      E();
    }), bn("$xeCarousel", w), w.renderVN = K, w;
  },
  render() {
    return this.renderVN();
  }
}), hL = Object.assign({}, Ha, {
  install(e) {
    e.component(Ha.name, Ha);
  }
});
Ht.use(hL);
Ce.component(Ha);
function vL(e, t, n) {
  const s = e.reactData.staticItems, i = t.parentNode;
  i && s.splice(r.arrayIndexOf(i.children, t), 0, n), e.reactData.staticItems = s.slice(0);
}
function bL(e, t) {
  const n = e.reactData.staticItems, s = r.findIndexOf(n, (i) => i.id === t.id);
  s > -1 && n.splice(s, 1), e.reactData.staticItems = n.slice(0);
}
const ja = pt({
  name: "VxeCarouselItem",
  props: {
    name: [String, Number],
    className: String,
    url: String
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeCarousel", null), l = r.uniqueId(), a = ke(), c = Rt({}), m = Rt({
      id: l,
      name: e.name,
      url: e.url,
      className: e.className,
      slots: n
    }), u = {
      refElem: a
    }, d = {}, p = {
      xID: l,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => u,
      getComputeMaps: () => d
    };
    Object.assign(p, {
      dispatchEvent: (x, h, O) => {
        s(x, Zt(O, { $carouselItem: p }, h));
      }
    }, {});
    const S = () => o("div", {
      ref: a
    });
    return lt(() => e.name, (x) => {
      m.name = x;
    }), lt(() => e.url, (x) => {
      m.url = x;
    }), wn(() => {
      const x = a.value;
      i && x && vL(i, x, m);
    }), $n(() => {
      i && bL(i, m);
    }), p.renderVN = S, p;
  },
  render() {
    return this.renderVN();
  }
}), xL = Object.assign({}, ja, {
  install(e) {
    e.component(ja.name, ja);
  }
});
Ht.use(xL);
Ce.component(ja);
const nl = pt({
  name: "VxeCheckbox",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number],
      default: null
    },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: !0
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: !1
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => oe().checkbox.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeForm", null), l = mt("xeFormItemInfo", null), a = mt("$xeCheckboxGroup", null), c = r.uniqueId(), m = Rt({}), u = {
      xID: c,
      props: e,
      context: t,
      reactData: m
    };
    let d = {};
    const { computeSize: p } = dn(e), w = _(() => a ? r.includes(a.props.modelValue, e.label) : e.modelValue === e.checkedValue), v = _(() => {
      const { disabled: h } = e, O = w.value;
      if (h === null && a) {
        const { computeIsDisabled: g, computeIsMaximize: b } = a.getComputeMaps(), E = g.value, C = b.value;
        return E || C && !O;
      }
      return h;
    }), D = (h) => {
      const { checkedValue: O, uncheckedValue: g } = e;
      if (!v.value) {
        const E = h.target.checked, C = E ? O : g, V = { checked: E, value: C, label: e.label };
        a ? a.handleChecked(V, h) : (s("update:modelValue", C), d.dispatchEvent("change", V, h), i && l && i.triggerItemEvent(h, l.itemConfig.field, C));
      }
    };
    d = {
      dispatchEvent: (h, O, g) => {
        s(h, Zt(g, { $checkbox: u }, O));
      }
    }, Object.assign(u, d);
    const x = () => {
      const h = p.value, O = v.value, g = w.value, b = !g && e.indeterminate;
      return o("label", {
        class: ["vxe-checkbox", {
          [`size--${h}`]: h,
          "is--indeterminate": b,
          "is--disabled": O,
          "is--checked": g
        }],
        title: e.title
      }, [
        o("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: O,
          checked: g,
          onChange: D
        }),
        o("span", {
          class: ["vxe-checkbox--icon", b ? ht().CHECKBOX_INDETERMINATE : g ? ht().CHECKBOX_CHECKED : ht().CHECKBOX_UNCHECKED]
        }),
        o("span", {
          class: "vxe-checkbox--label"
        }, n.default ? n.default({}) : Bn(e.content))
      ]);
    };
    return u.renderVN = x, u;
  },
  render() {
    return this.renderVN();
  }
}), yL = Object.assign(nl, {
  install(e) {
    e.component(nl.name, nl);
  }
});
Ht.use(yL);
Ce.component(nl);
const Di = pt({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: {
      type: Boolean,
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => oe().checkboxGroup.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeForm", null), l = mt("xeFormItemInfo", null), a = r.uniqueId(), c = Rt({}), m = _(() => {
      const { disabled: b } = e;
      return b === null ? i ? i.props.readonly || i.props.disabled : !1 : b;
    }), u = _(() => {
      const { modelValue: b, max: E } = e;
      return E ? (b ? b.length : 0) >= r.toNumber(E) : !1;
    }), d = _(() => Object.assign({}, e.optionProps)), p = _(() => d.value.label || "label"), w = _(() => d.value.value || "value"), v = _(() => d.value.disabled || "disabled"), D = {
      computeIsMaximize: u,
      computeIsDisabled: m
    }, S = {
      xID: a,
      props: e,
      context: t,
      reactData: c,
      getComputeMaps: () => D
    };
    dn(e), Object.assign(S, {
      dispatchEvent: (b, E, C) => {
        s(b, Zt(C, { $checkboxGroup: S }, E));
      }
    }, {
      handleChecked(b, E) {
        const { checked: C, label: V } = b, Q = e.modelValue || [], Z = Q.indexOf(V);
        C ? Z === -1 && Q.push(V) : Q.splice(Z, 1), s("update:modelValue", Q), S.dispatchEvent("change", Object.assign({ checklist: Q }, b), E), i && l && i.triggerItemEvent(E, l.itemConfig.field, Q);
      }
    });
    const g = () => {
      const { options: b } = e, E = n.default, C = w.value, V = p.value, Q = v.value;
      return o("div", {
        class: "vxe-checkbox-group"
      }, E ? E({}) : b ? b.map((Z) => o(nl, {
        label: Z[C],
        content: Z[V],
        disabled: Z[Q]
      })) : []);
    };
    return bn("$xeCheckboxGroup", S), S.renderVN = g, g;
  }
}), CL = Object.assign(Di, {
  install(e) {
    e.component(Di.name, Di);
  }
});
Ht.use(CL);
Ce.component(Di);
const Bl = pt({
  name: "VxeCol",
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean,
    size: {
      type: String,
      default: () => oe().col.size || oe().size
    }
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId();
    dn(e);
    const l = ke(), a = Rt({}), c = {
      refElem: l
    }, m = mt("$xeRow", null), u = _(() => m ? m.props.gutter : null), d = _(() => m ? m.props.vertical : null), p = _(() => {
      const { width: O } = e, g = u.value, b = d.value, E = {};
      if (g) {
        let [C, V] = r.isArray(g) ? g : [g];
        if (b && (V = C, C = ""), C) {
          const Q = r.isNumber(C) ? cn(C / 2) : `calc(${cn(C)} / 2)`;
          E.paddingLeft = Q, E.paddingRight = Q;
        }
        if (V) {
          const Q = r.isNumber(V) ? cn(V / 2) : `calc(${cn(V)} / 2)`;
          E.paddingTop = Q, E.paddingBottom = Q;
        }
      }
      return O && (E.width = cn(O)), E;
    }), w = {}, v = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => w
    };
    Object.assign(v, {
      dispatchEvent: (O, g, b) => {
        s(O, Zt(b, { $col: v }, g));
      }
    }, {});
    const h = () => {
      const { span: O, fill: g, align: b, ellipsis: E } = e, C = p.value, V = n.default;
      return o("div", {
        ref: l,
        class: ["vxe-col", O ? `span${O}` : "", b ? `align--${b}` : "", {
          "is--span": O,
          "is--fill": g,
          "is--ellipsis": E
        }],
        style: C
      }, [
        o("div", {
          class: "vxe-col--inner"
        }, V ? V({}) : [])
      ]);
    };
    return v.renderVN = h, v;
  },
  render() {
    return this.renderVN();
  }
}), wL = Object.assign({}, Bl, {
  install(e) {
    e.component(Bl.name, Bl);
  }
});
Ht.use(wL);
Ce.component(Bl);
const qa = pt({
  name: "VxeCollapse",
  props: {
    modelValue: Array,
    options: Array,
    padding: {
      type: Boolean,
      default: () => oe().collapse.padding
    },
    expandConfig: Object,
    size: {
      type: String,
      default: () => oe().collapse.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "collapse-load"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = ke(), c = Rt({
      staticPanes: [],
      activeNames: [],
      initNames: [],
      cachePaneMaps: {}
    }), m = {
      refElem: a
    }, u = _(() => {
      const { options: G } = e;
      return (G || []).filter((ue) => D(ue));
    }), d = _(() => {
      const { staticPanes: G } = c;
      return G.filter((ue) => D(ue));
    }), p = _(() => Object.assign({}, oe().collapse.expandConfig, e.expandConfig)), w = {}, v = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => w
    }, D = (G) => {
      const { permissionCode: ue } = G;
      return !(ue && !Ai.checkVisible(ue));
    }, S = (G) => {
      const { initNames: ue } = c;
      return G && !ue.includes(G) ? (ue.push(G), !0) : !1;
    }, x = (G) => {
      const { activeNames: ue } = c, Y = {};
      G && G.length && G.forEach((K) => {
        const { name: L, preload: ye } = K || {};
        if (L) {
          const se = ue.includes(L);
          Y[`${L}`] = {
            loading: !1
          }, se && S(L), ye && (se || ue.push(L));
        }
      }), c.activeNames = ue ? ue.slice(0) : [], c.cachePaneMaps = Y;
    }, O = {
      dispatchEvent: (G, ue, Y) => {
        n(G, Zt(Y, { $collapse: v }, ue));
      }
    }, g = (G, ue) => G && (r.isString(G) && (G = s[G] || null), r.isFunction(G)) ? Nt(G(ue)) : [], b = (G, ue) => {
      const { activeNames: Y } = c, { name: K } = ue;
      if (K) {
        const L = Y.indexOf(K);
        L === -1 ? Y.push(K) : Y.splice(L, 1), S(K);
      }
    };
    Object.assign(v, O, {});
    const C = (G) => {
      const { activeNames: ue, initNames: Y } = c, K = p.value;
      return G.map((L) => {
        const { icon: ye, name: se, title: P, slots: M } = L, I = M ? M.title : null, B = M ? M.default : null, H = se && ue.includes(se);
        return o("div", {
          class: "vxe-collapse-item"
        }, [
          o("div", {
            class: "vxe-collapse--item-header",
            onClick(ce) {
              b(ce, L);
            }
          }, [
            K.showIcon ? o("span", {
              class: "vxe-collapse--item-switch"
            }, [
              o("i", {
                class: H ? ht().COLLAPSE_OPEN : ht().COLLAPSE_CLOSE
              })
            ]) : Yn(),
            ye ? o("span", {
              class: "vxe-collapse--item-icon"
            }, [
              o("i", {
                class: ye
              })
            ]) : Yn(),
            o("span", {
              class: "vxe-collapse--item-name"
            }, I ? g(I, { name: se, title: P }) : `${P}`)
          ]),
          o("div", {
            class: ["vxe-collapse--item-content", {
              "is--visible": H
            }]
          }, [
            se && Y.includes(se) ? o("div", {
              class: "vxe-collapse--item-inner"
            }, [
              B ? g(B, { name: se, title: P }) : ""
            ]) : Yn()
          ])
        ]);
      });
    }, V = () => {
      const { padding: G } = e, ue = l.value, Y = u.value, K = d.value, L = s.default, ye = L ? K : Y;
      return o("div", {
        ref: a,
        class: ["vxe-collapse", {
          [`size--${ue}`]: ue,
          "is--padding": G
        }]
      }, [
        o("div", {
          class: "vxe-collapse-slots"
        }, L ? L({}) : []),
        C(ye)
      ]);
    };
    lt(() => e.modelValue, (G) => {
      c.activeNames = G || [];
    });
    const Q = ke(0);
    lt(() => e.options ? e.options.length : -1, () => {
      Q.value++;
    }), lt(() => e.options, () => {
      Q.value++;
    }), lt(Q, () => {
      x(e.options);
    });
    const Z = ke(0);
    return lt(() => c.staticPanes ? c.staticPanes.length : -1, () => {
      Z.value++;
    }), lt(() => c.staticPanes, () => {
      Z.value++;
    }), lt(Z, () => {
      x(c.staticPanes);
    }), c.activeNames = e.modelValue || [], x(c.staticPanes.length ? c.staticPanes : e.options), bn("$xeCollapse", v), v.renderVN = V, v;
  },
  render() {
    return this.renderVN();
  }
}), EL = Object.assign({}, qa, {
  install(e) {
    e.component(qa.name, qa);
  }
});
Ht.use(EL);
Ce.component(qa);
function SL(e, t, n) {
  const s = e.reactData.staticPanes, i = t.parentNode;
  i && (s.splice(r.arrayIndexOf(i.children, t), 0, n), e.reactData.staticPanes = s.slice(0));
}
function DL(e, t) {
  const n = e.reactData.staticPanes, s = r.findTree(n, (i) => i.id === t.id, { children: "children" });
  s && s.items.splice(s.index, 1), e.reactData.staticPanes = n.slice(0);
}
const Ua = pt({
  name: "VxeCollapsePane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), l = mt("$xeCollapse", null), a = ke(), c = Rt({}), m = Rt({
      id: i,
      title: e.title,
      name: e.name,
      icon: e.icon,
      preload: e.preload,
      permissionCode: e.permissionCode,
      slots: s
    }), u = {
      refElem: a
    }, d = {}, p = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => u,
      getComputeMaps: () => d
    };
    Object.assign(p, {
      dispatchEvent: (x, h, O) => {
        n(x, Zt(O, { $collapsePane: p }, h));
      }
    }, {});
    const S = () => o("div", {
      ref: a
    }, []);
    return lt(() => e.title, (x) => {
      m.title = x;
    }), lt(() => e.name, (x) => {
      m.name = x;
    }), lt(() => e.icon, (x) => {
      m.icon = x;
    }), lt(() => e.permissionCode, (x) => {
      m.permissionCode = x;
    }), wn(() => {
      const x = a.value;
      l && x && SL(l, x, m);
    }), $n(() => {
      l && DL(l, m);
    }), p.renderVN = S, p;
  },
  render() {
    return this.renderVN();
  }
}), OL = Object.assign({}, Ua, {
  install(e) {
    e.component(Ua.name, Ua);
  }
});
Ht.use(OL);
Ce.component(Ua);
const Ga = pt({
  name: "VxeColorPicker",
  props: {},
  emits: [],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), i = ke(), l = Rt({}), a = {
      refElem: i
    }, c = {}, m = {
      xID: s,
      props: e,
      context: t,
      reactData: l,
      getRefMaps: () => a,
      getComputeMaps: () => c
    };
    Object.assign(m, {
      dispatchEvent: (v, D, S) => {
        n(v, Zt(S, { $colorPicker: m }, D));
      }
    }, {});
    const w = () => o("div", {
      ref: i,
      class: "vxe-color-picker"
    }, []);
    return m.renderVN = w, m;
  },
  render() {
    return this.renderVN();
  }
}), TL = Object.assign({}, Ga, {
  install(e) {
    e.component(Ga.name, Ga);
  }
});
Ht.use(TL);
Ce.component(Ga);
const Ps = pt({
  name: "VxeText",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    loading: Boolean,
    content: [String, Number],
    clickToCopy: Boolean,
    size: {
      type: String,
      default: () => oe().text.size || oe().size
    }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = ke(), c = ke(), m = Rt({}), u = {
      refElem: a
    }, d = {}, p = () => {
      const { content: g, clickToCopy: b } = e;
      if (b) {
        const E = c.value, C = (E ? E.textContent : "") || g;
        C && (Ce.clipboard.copy(C) ? Ce.modal && Ce.modal.message({
          content: Pe("vxe.text.copySuccess"),
          status: "success"
        }) : Ce.modal && Ce.modal.message({
          content: Pe("vxe.text.copyError"),
          status: "error"
        }));
      }
    }, w = {
      xID: i,
      props: e,
      context: t,
      reactData: m,
      getRefMaps: () => u,
      getComputeMaps: () => d
    }, v = (g, b, E) => {
      n(g, Zt(E, { $text: w }, b));
    }, D = {
      dispatchEvent: v
    }, S = (g) => {
      const { loading: b } = e;
      b || v("click", {}, g);
    };
    Object.assign(w, D, {});
    const h = () => {
      const { loading: g, icon: b, content: E, clickToCopy: C } = e, V = s.default, Q = s.icon;
      return [
        g ? o("span", {
          class: "vxe-text--loading"
        }, [
          o("i", {
            class: ht().TEXT_LOADING
          })
        ]) : Q || b || C ? o("span", {
          class: "vxe-text--icon",
          onClick: p
        }, Q ? Nt(Q({})) : [
          o("i", {
            class: b || ht().TEXT_COPY
          })
        ]) : Ve(),
        o("span", {
          ref: c,
          class: "vxe-text--content"
        }, V ? V({}) : r.toValueString(E))
      ];
    }, O = () => {
      const { loading: g, status: b, title: E, clickToCopy: C } = e, V = l.value;
      return o("span", {
        ref: a,
        title: E,
        class: ["vxe-text", {
          [`size--${V}`]: V,
          [`theme--${b}`]: b,
          "is--copy": C,
          "is--loading": g
        }],
        onClick: S
      }, h());
    };
    return w.renderVN = O, w;
  },
  render() {
    return this.renderVN();
  }
}), Ka = pt({
  name: "VxeCountdown",
  props: {
    modelValue: [Number, String],
    format: String,
    prefixConfig: Object,
    suffixConfig: Object,
    size: {
      type: String,
      default: () => oe().countdown.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "start",
    "end"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), { computeSize: a } = dn(e), c = Rt({
      currNum: 0,
      secondNum: 0
    }), m = {
      dnTimeout: void 0
    }, u = {
      refElem: l
    }, d = _(() => {
      const { secondNum: G } = c;
      return G >= 316224e5 ? ["yyyy", "MM", "dd", "HH", "mm", "ss"] : G >= 26784e5 ? ["MM", "dd", "HH", "mm", "ss"] : G >= 864e5 ? ["dd", "HH", "mm", "ss"] : G >= 36e5 ? ["HH", "mm", "ss"] : G >= 6e4 ? ["mm", "ss"] : ["ss"];
    }), p = _(() => {
      const { currNum: G } = c;
      return r.getDateDiff(Date.now(), Date.now() + G);
    }), w = _(() => {
      const { format: G } = e, ue = p.value;
      let Y = "";
      return G && (Y = `${G}`, r.each(ue, (K, L) => {
        Y = Y.replace(new RegExp(L, "g"), r.padStart(K, L.length, "0"));
      })), Y;
    }), v = _(() => Object.assign({}, e.prefixConfig, oe().countdown.prefixConfig)), D = _(() => Object.assign({}, e.suffixConfig, oe().countdown.suffixConfig)), S = {
      computeSize: a
    }, x = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      internalData: m,
      getRefMaps: () => u,
      getComputeMaps: () => S
    }, h = (G, ue, Y) => {
      s(G, Zt(Y, { $carousel: x }, ue));
    }, O = () => {
      const G = r.toNumber(e.modelValue || 0);
      c.secondNum = G, c.currNum = G;
    }, g = () => {
      const { currNum: G } = c;
      G > 1e3 ? (c.currNum -= 1e3, m.dnTimeout = setTimeout(() => {
        g();
      }, 1e3)) : (c.currNum = 0, C());
    }, b = {
      dispatchEvent: h
    }, E = () => {
      h("start", {}, null), g();
    }, C = () => {
      const { dnTimeout: G } = m;
      G && (clearTimeout(G), m.dnTimeout = void 0, h("end", {}, null));
    };
    Object.assign(x, b, {});
    const Q = () => {
      const { format: G } = e, ue = d.value, Y = p.value, K = w.value;
      return G ? [
        o("div", {
          key: "format",
          class: "vxe-countdown--content-format"
        }, K)
      ] : ue.map((L, ye) => o("div", {
        key: ye,
        class: "vxe-countdown--content-item"
      }, [
        o("div", {
          class: "vxe-countdown--content-num"
        }, `${Y[L] || 0}`),
        o("div", {
          class: "vxe-countdown--content-unit"
        }, Pe(`vxe.countdown.formats.${L}`))
      ]));
    }, Z = () => {
      const { prefixConfig: G, suffixConfig: ue } = e, { currNum: Y } = c, K = a.value, L = p.value, ye = v.value, se = D.value, P = n.prefix, M = n.suffix, I = n.default;
      return o("div", {
        ref: l,
        class: ["vxe-countdown", L.done ? "is--progress" : "is-end", {
          [`size--${K}`]: K
        }]
      }, [
        P || G ? o("div", {
          class: "vxe-countdown--prefix"
        }, P ? Nt(P({ currentValue: Y, diffConf: L })) : [
          o(Ps, {
            content: ye.content,
            icon: ye.icon,
            status: ye.status
          })
        ]) : Ve(),
        o("div", {
          class: "vxe-countdown--content"
        }, I ? Nt(I({ currentValue: Y, diffConf: L })) : Q()),
        M || ue ? o("div", {
          class: "vxe-countdown--suffix"
        }, M ? Nt(M({ currentValue: Y, diffConf: L })) : [
          o(Ps, {
            content: se.content,
            icon: se.icon,
            status: se.status
          })
        ]) : Ve()
      ]);
    };
    return lt(() => e.modelValue, () => {
      O(), C(), E();
    }), $n(() => {
      C();
    }), wn(() => {
      E();
    }), O(), x.renderVN = Z, x;
  },
  render() {
    return this.renderVN();
  }
}), ML = Object.assign({}, Ka, {
  install(e) {
    e.component(Ka.name, Ka);
  }
});
Ht.use(ML);
Ce.component(Ka);
const Il = pt({
  name: "VxeDatePicker",
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: !0
    },
    name: String,
    type: {
      type: String,
      default: "date"
    },
    clearable: {
      type: Boolean,
      default: () => oe().datePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => oe().datePicker.size || oe().size
    },
    multiple: Boolean,
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => oe().datePicker.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => oe().datePicker.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => oe().datePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: !0
    },
    festivalMethod: {
      type: Function,
      default: () => oe().datePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => oe().datePicker.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => oe().datePicker.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeModal", null), l = mt("$xeDrawer", null), a = mt("$xeTable", null), c = mt("$xeForm", null), m = mt("xeFormItemInfo", null), u = r.uniqueId(), { computeSize: d } = dn(e), p = Rt({
      initialized: !1,
      panelIndex: 0,
      visiblePanel: !1,
      isAniVisible: !1,
      panelStyle: {},
      panelPlacement: "",
      isActivated: !1,
      inputValue: "",
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    }), w = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: void 0
    }, v = ke(), D = ke(), S = ke(), x = ke(), h = ke(), O = {
      refElem: v,
      refInput: D
    }, g = {
      xID: u,
      props: e,
      context: t,
      reactData: p,
      internalData: w,
      getRefMaps: () => O
    };
    let b = {};
    const E = _(() => {
      const { transfer: ae } = e;
      if (ae === null) {
        const We = oe().datePicker.transfer;
        if (r.isBoolean(We))
          return We;
        if (a || i || l || c)
          return !0;
      }
      return ae;
    }), C = _(() => {
      const { readonly: ae } = e;
      return ae === null ? c ? c.props.readonly : !1 : ae;
    }), V = _(() => {
      const { disabled: ae } = e;
      return ae === null ? c ? c.props.disabled : !1 : ae;
    }), Q = _(() => {
      const { type: ae } = e;
      return ae === "time" || ae === "datetime";
    }), Z = _(() => Q.value || ["date", "week", "month", "quarter", "year"].indexOf(e.type) > -1), G = _(() => e.clearable), ue = _(() => e.startDate ? r.toStringDate(e.startDate) : null), Y = _(() => e.endDate ? r.toStringDate(e.endDate) : null), K = _(() => ["date", "week", "month", "quarter", "year"].indexOf(e.type) > -1), L = _(() => {
      const { modelValue: ae, multiple: We } = e, Ze = Z.value, ft = P.value;
      return We && ae && Ze ? r.toValueString(ae).split(",").map(($t) => {
        const Mt = ve($t, ft);
        return r.isValidDate(Mt), Mt;
      }) : [];
    }), ye = _(() => {
      const ae = L.value, We = P.value;
      return ae.map((Ze) => r.toDateString(Ze, We));
    }), se = _(() => {
      const ae = L.value, We = A.value;
      return ae.map((Ze) => r.toDateString(Ze, We)).join(", ");
    }), P = _(() => {
      const { type: ae, valueFormat: We } = e;
      return We || (ae === "time" ? "HH:mm:ss" : ae === "datetime" ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd");
    }), M = _(() => {
      const { modelValue: ae } = e, We = Z.value, Ze = P.value;
      let ft = null;
      if (ae && We) {
        const $t = ve(ae, Ze);
        r.isValidDate($t) && (ft = $t);
      }
      return ft;
    }), I = _(() => {
      const ae = ue.value, { selectMonth: We } = p;
      return We && ae ? We <= ae : !1;
    }), B = _(() => {
      const ae = Y.value, { selectMonth: We } = p;
      return We && ae ? We >= ae : !1;
    }), H = _(() => {
      const { datetimePanelValue: ae } = p, We = dt.value;
      return ae ? r.toDateString(ae, We ? "HH:mm:ss" : "HH:mm") : "";
    }), ce = _(() => {
      const ae = M.value, We = Q.value;
      return ae && We ? (ae.getHours() * 3600 + ae.getMinutes() * 60 + ae.getSeconds()) * 1e3 : 0;
    }), A = _(() => {
      const { labelFormat: ae } = e;
      return Z.value ? ae || Pe(`vxe.input.date.labelFormat.${e.type}`) : null;
    }), j = _(() => {
      const { yearSize: ae } = w, { selectMonth: We, currentDate: Ze } = p, ft = [];
      if (We && Ze) {
        const $t = Ze.getFullYear(), Mt = We.getFullYear(), jt = new Date(Mt - Mt % ae, 0, 1);
        for (let qt = -4; qt < ae + 4; qt++) {
          const tt = r.getWhatYear(jt, qt, "first"), _t = tt.getFullYear();
          ft.push({
            date: tt,
            isCurrent: !0,
            isPrev: qt < 0,
            isNow: $t === _t,
            isNext: qt >= ae,
            year: _t
          });
        }
      }
      return ft;
    }), fe = _(() => {
      if (Z.value) {
        const { datePanelType: We, selectMonth: Ze } = p, ft = j.value;
        let $t = "", Mt;
        return Ze && ($t = Ze.getFullYear(), Mt = Ze.getMonth() + 1), We === "quarter" ? Pe("vxe.input.date.quarterLabel", [$t]) : We === "month" ? Pe("vxe.input.date.monthLabel", [$t]) : We === "year" ? ft.length ? `${ft[0].year} - ${ft[ft.length - 1].year}` : "" : Pe("vxe.input.date.dayLabel", [$t, Mt ? Pe(`vxe.input.date.m${Mt}`) : "-"]);
      }
      return "";
    }), pe = _(() => {
      const { startDay: ae, startWeek: We } = e;
      return r.toNumber(r.isNumber(ae) || r.isString(ae) ? ae : We);
    }), ne = _(() => {
      const ae = [];
      if (Z.value) {
        let Ze = pe.value;
        ae.push(Ze);
        for (let ft = 0; ft < 6; ft++)
          Ze >= 6 ? Ze = 0 : Ze++, ae.push(Ze);
      }
      return ae;
    }), $ = _(() => Z.value ? ne.value.map((Ze) => ({
      value: Ze,
      label: Pe(`vxe.input.date.weeks.w${Ze}`)
    })) : []), J = _(() => {
      if (Z.value) {
        const We = $.value;
        return [{ label: Pe("vxe.input.date.weeks.w") }].concat(We);
      }
      return [];
    }), ge = _(() => {
      const ae = j.value;
      return r.chunk(ae, 4);
    }), Oe = _(() => {
      const { quarterSize: ae } = w, { selectMonth: We, currentDate: Ze } = p, ft = [];
      if (We && Ze) {
        const $t = Ze.getFullYear(), Mt = ql(Ze), jt = r.getWhatYear(We, 0, "first"), qt = jt.getFullYear();
        for (let tt = -2; tt < ae - 2; tt++) {
          const _t = r.getWhatQuarter(jt, tt), In = _t.getFullYear(), yn = ql(_t), Rn = In < qt;
          ft.push({
            date: _t,
            isPrev: Rn,
            isCurrent: In === qt,
            isNow: In === $t && yn === Mt,
            isNext: !Rn && In > qt,
            quarter: yn
          });
        }
      }
      return ft;
    }), Se = _(() => {
      const ae = Oe.value;
      return r.chunk(ae, 2);
    }), de = _(() => {
      const { monthSize: ae } = w, { selectMonth: We, currentDate: Ze } = p, ft = [];
      if (We && Ze) {
        const $t = Ze.getFullYear(), Mt = Ze.getMonth(), jt = r.getWhatYear(We, 0, "first").getFullYear();
        for (let qt = -4; qt < ae - 4; qt++) {
          const tt = r.getWhatYear(We, 0, qt), _t = tt.getFullYear(), In = tt.getMonth(), yn = _t < jt;
          ft.push({
            date: tt,
            isPrev: yn,
            isCurrent: _t === jt,
            isNow: _t === $t && In === Mt,
            isNext: !yn && _t > jt,
            month: In
          });
        }
      }
      return ft;
    }), Ie = _(() => {
      const ae = de.value;
      return r.chunk(ae, 4);
    }), je = _(() => {
      const { selectMonth: ae, currentDate: We } = p, Ze = [];
      if (ae && We) {
        const ft = ce.value, $t = ne.value, Mt = We.getFullYear(), jt = We.getMonth(), qt = We.getDate(), tt = ae.getFullYear(), _t = ae.getMonth(), In = ae.getDay(), yn = -$t.indexOf(In), Rn = new Date(r.getWhatDay(ae, yn).getTime() + ft);
        for (let To = 0; To < 42; To++) {
          const vo = r.getWhatDay(Rn, To), go = vo.getFullYear(), Xn = vo.getMonth(), bo = vo.getDate(), Zs = vo < ae;
          Ze.push({
            date: vo,
            isPrev: Zs,
            isCurrent: go === tt && Xn === _t,
            isNow: go === Mt && Xn === jt && bo === qt,
            isNext: !Zs && _t !== Xn,
            label: bo
          });
        }
      }
      return Ze;
    }), Ue = _(() => {
      const ae = je.value;
      return r.chunk(ae, 7);
    }), Ae = _(() => {
      const ae = Ue.value, We = pe.value;
      return ae.map((Ze) => {
        const ft = Ze[0];
        return [{
          date: ft.date,
          isWeekNumber: !0,
          isPrev: !1,
          isCurrent: !1,
          isNow: !1,
          isNext: !1,
          label: r.getYearWeek(ft.date, We)
        }].concat(Ze);
      });
    }), _e = _(() => {
      const ae = [];
      if (Q.value)
        for (let Ze = 0; Ze < 24; Ze++)
          ae.push({
            value: Ze,
            label: ("" + Ze).padStart(2, "0")
          });
      return ae;
    }), it = _(() => {
      const ae = [];
      if (Q.value)
        for (let Ze = 0; Ze < 60; Ze++)
          ae.push({
            value: Ze,
            label: ("" + Ze).padStart(2, "0")
          });
      return ae;
    }), vt = _(() => {
      const ae = P.value;
      return !/HH/.test(ae) || /mm/.test(ae);
    }), dt = _(() => {
      const ae = P.value;
      return !/HH/.test(ae) || /ss/.test(ae);
    }), at = _(() => it.value), Et = _(() => {
      const { type: ae, editable: We, multiple: Ze } = e;
      return C.value || Ze || !We || ae === "week" || ae === "quarter";
    }), Qe = _(() => "text"), De = _(() => {
      const { placeholder: ae } = e;
      if (ae)
        return Bn(ae);
      const We = oe().datePicker.placeholder;
      return We ? Bn(We) : Pe("vxe.base.pleaseSelect");
    }), Re = _(() => {
      const { immediate: ae } = e;
      return ae;
    }), Be = (ae) => {
      let We = "";
      ae && (r.isNumber(ae) && /^[0-9]{11,15}$/.test(`${ae}`) ? We = new Date(ae) : We = ae), p.inputValue = We;
    }, ve = (ae, We) => {
      const { type: Ze } = e;
      return Ze === "time" ? xv(ae) : r.toStringDate(ae, We);
    }, Ne = (ae) => {
      const { inputValue: We } = p;
      b.dispatchEvent(ae.type, { value: We }, ae);
    }, q = (ae, We) => {
      p.inputValue = ae, s("update:modelValue", ae), r.toValueString(e.modelValue) !== ae && (b.dispatchEvent("change", { value: ae }, We), c && m && c.triggerItemEvent(We, m.itemConfig.field, ae));
    }, z = (ae) => {
      const We = Z.value, Ze = Re.value, $t = ae.target.value;
      p.inputValue = $t, We || (Ze ? q($t, ae) : b.dispatchEvent("input", { value: $t }, ae));
    }, R = (ae) => {
      Re.value || Ne(ae);
    }, le = (ae) => {
      p.isActivated = !0, Z.value && Oo(ae), Ne(ae);
    }, F = (ae) => {
      if (!V.value) {
        const { inputValue: Ze } = p;
        b.dispatchEvent("prefix-click", { value: Ze }, ae);
      }
    }, re = () => new Promise((ae) => {
      p.visiblePanel = !1, w.hpTimeout = window.setTimeout(() => {
        p.isAniVisible = !1, ae();
      }, 350);
    }), N = (ae, We) => {
      Z.value && re(), q("", ae), b.dispatchEvent("clear", { value: We }, ae);
    }, ee = (ae) => {
      if (!V.value) {
        const { inputValue: Ze } = p;
        b.dispatchEvent("suffix-click", { value: Ze }, ae);
      }
    }, be = (ae) => {
      const { type: We } = e, Ze = A.value, ft = P.value, $t = pe.value;
      let Mt = null, jt = "";
      if (ae && (Mt = ve(ae, ft)), r.isValidDate(Mt)) {
        if (jt = r.toDateString(Mt, Ze, { firstDay: $t }), Ze && We === "week" && r.getWhatWeek(Mt, 0, $t, $t).getFullYear() < Mt.getFullYear()) {
          const tt = Ze.indexOf("yyyy");
          if (tt > -1) {
            const _t = Number(jt.substring(tt, tt + 4));
            _t && !isNaN(_t) && (jt = jt.replace(`${_t}`, `${_t - 1}`));
          }
        }
      } else
        Mt = null;
      p.datePanelValue = Mt, p.datePanelLabel = jt;
    }, we = () => {
      const ae = Z.value, { inputValue: We } = p;
      ae && (be(We), p.inputValue = e.multiple ? se.value : p.datePanelLabel);
    }, Te = () => {
      const ae = Z.value;
      Be(e.modelValue), ae && we();
    }, ze = () => {
      p.inputValue = e.multiple ? se.value : p.datePanelLabel;
    }, st = (ae) => {
      const We = r.getWhatMonth(ae, 0, "first");
      r.isEqual(We, p.selectMonth) || (p.selectMonth = We);
    }, ct = (ae) => {
      const { modelValue: We, multiple: Ze } = e, { datetimePanelValue: ft } = p, $t = Q.value, Mt = P.value, jt = pe.value;
      if (e.type === "week") {
        const tt = r.toNumber(e.selectDay);
        ae = r.getWhatWeek(ae, 0, tt, jt);
      } else $t && ft && (ae.setHours(ft.getHours()), ae.setMinutes(ft.getMinutes()), ae.setSeconds(ft.getSeconds()));
      const qt = r.toDateString(ae, Mt, { firstDay: jt });
      if (st(ae), Ze) {
        const tt = ye.value;
        if ($t) {
          const _t = [...L.value], In = [], yn = r.findIndexOf(_t, (Rn) => r.isDateSame(ae, Rn, "yyyyMMdd"));
          yn === -1 ? _t.push(ae) : _t.splice(yn, 1), _t.forEach((Rn) => {
            Rn && (ft && (Rn.setHours(ft.getHours()), Rn.setMinutes(ft.getMinutes()), Rn.setSeconds(ft.getSeconds())), In.push(Rn));
          }), q(In.map((Rn) => r.toDateString(Rn, Mt)).join(","), { type: "update" });
        } else
          tt.some((_t) => r.isEqual(_t, qt)) ? q(tt.filter((_t) => !r.isEqual(_t, qt)).join(","), { type: "update" }) : q(tt.concat([qt]).join(","), { type: "update" });
      } else
        r.isEqual(We, qt) || q(qt, { type: "update" });
    }, Ke = () => {
      const { type: ae } = e, { inputValue: We, datetimePanelValue: Ze } = p, ft = A.value;
      if (!Et.value)
        if (We) {
          let Mt = ve(We, ft);
          if (r.isValidDate(Mt))
            if (ae === "time")
              Mt = r.toDateString(Mt, ft), We !== Mt && q(Mt, { type: "check" }), p.inputValue = Mt;
            else {
              let jt = !1;
              const qt = pe.value;
              if (ae === "datetime") {
                const tt = M.value;
                (We !== r.toDateString(tt, ft) || We !== r.toDateString(Mt, ft)) && (jt = !0, Ze && (Ze.setHours(Mt.getHours()), Ze.setMinutes(Mt.getMinutes()), Ze.setSeconds(Mt.getSeconds())));
              } else
                jt = !0;
              p.inputValue = r.toDateString(Mt, ft, { firstDay: qt }), jt && ct(Mt);
            }
          else
            ze();
        } else
          q("", { type: "check" });
    }, wt = (ae) => {
      const { inputValue: We } = p, Ze = Re.value, ft = We;
      Ze || q(ft, ae), Ke(), p.visiblePanel || (p.isActivated = !1), b.dispatchEvent("blur", { value: ft }, ae), c && m && c.triggerItemEvent(ae, m.itemConfig.field, ft);
    }, St = (ae) => {
      Ne(ae);
    }, Dt = (ae) => {
      Ne(ae);
    }, Wt = (ae) => {
      Ne(ae);
    }, nn = (ae, We) => {
      p.selectMonth = r.getWhatMonth(ae, We, "first");
    }, zt = () => {
      const ae = r.getWhatDay(Date.now(), 0, "first");
      p.currentDate = ae, nn(ae, 0);
    }, At = () => {
      let { datePanelType: ae } = p;
      ae === "month" || ae === "quarter" ? ae = "year" : ae = "month", p.datePanelType = ae;
    }, Ee = (ae) => {
      const { type: We } = e, { datePanelType: Ze, selectMonth: ft, inputValue: $t } = p, { yearSize: Mt } = w, jt = $t;
      if (!I.value) {
        let tt;
        We === "year" ? tt = r.getWhatYear(ft, -Mt, "first") : We === "month" || We === "quarter" ? Ze === "year" ? tt = r.getWhatYear(ft, -Mt, "first") : tt = r.getWhatYear(ft, -1, "first") : Ze === "year" ? tt = r.getWhatYear(ft, -Mt, "first") : Ze === "month" ? tt = r.getWhatYear(ft, -1, "first") : tt = r.getWhatMonth(ft, -1, "first"), p.selectMonth = tt, b.dispatchEvent("date-prev", { viewType: Ze, viewDate: tt, value: jt, type: We }, ae);
      }
    }, Ye = (ae) => {
      zt(), e.multiple || (ct(p.currentDate), re()), b.dispatchEvent("date-today", { type: e.type }, ae);
    }, rt = (ae) => {
      const { type: We } = e, { datePanelType: Ze, selectMonth: ft, inputValue: $t } = p, { yearSize: Mt } = w, jt = $t;
      if (!B.value) {
        let tt;
        We === "year" ? tt = r.getWhatYear(ft, Mt, "first") : We === "month" || We === "quarter" ? Ze === "year" ? tt = r.getWhatYear(ft, Mt, "first") : tt = r.getWhatYear(ft, 1, "first") : Ze === "year" ? tt = r.getWhatYear(ft, Mt, "first") : Ze === "month" ? tt = r.getWhatYear(ft, 1, "first") : tt = r.getWhatMonth(ft, 1, "first"), p.selectMonth = tt, b.dispatchEvent("date-next", { viewType: Ze, value: jt, type: We }, ae);
      }
    }, Ot = (ae) => {
      const { disabledMethod: We } = e, { datePanelType: Ze } = p, ft = ue.value, $t = Y.value, { date: Mt } = ae;
      return ft && ft.getTime() > Mt.getTime() || $t && $t.getTime() < Mt.getTime() ? !0 : We ? We({ type: Ze, viewType: Ze, date: Mt, $datePicker: g }) : !1;
    }, Jt = (ae) => {
      const { type: We, multiple: Ze } = e, { datePanelType: ft } = p;
      We === "month" ? ft === "year" ? (p.datePanelType = "month", st(ae)) : (ct(ae), Ze || re()) : We === "year" ? (ct(ae), Ze || re()) : We === "quarter" ? ft === "year" ? (p.datePanelType = "quarter", st(ae)) : (ct(ae), Ze || re()) : ft === "month" ? (p.datePanelType = We === "week" ? We : "day", st(ae)) : ft === "year" ? (p.datePanelType = "month", st(ae)) : (ct(ae), We === "datetime" || Ze || re());
    }, Bt = (ae) => {
      Ot(ae) || Jt(ae.date);
    }, Gt = (ae) => {
      Ot({ date: ae }) || (je.value.some((Ze) => r.isDateSame(Ze.date, ae, "yyyyMMdd")) || st(ae), be(ae));
    }, Qt = (ae) => {
      Ot({ date: ae }) || (j.value.some((Ze) => r.isDateSame(Ze.date, ae, "yyyy")) || st(ae), be(ae));
    }, U = (ae) => {
      Ot({ date: ae }) || (Oe.value.some((Ze) => r.isDateSame(Ze.date, ae, "yyyyq")) || st(ae), be(ae));
    }, Lt = (ae) => {
      Ot({ date: ae }) || (de.value.some((Ze) => r.isDateSame(Ze.date, ae, "yyyyMM")) || st(ae), be(ae));
    }, on = (ae) => {
      if (!Ot(ae)) {
        const { datePanelType: We } = p;
        We === "month" ? Lt(ae.date) : We === "quarter" ? U(ae.date) : We === "year" ? Qt(ae.date) : Gt(ae.date);
      }
    }, en = (ae) => {
      if (ae) {
        const We = ae.offsetHeight, Ze = ae.parentNode;
        Ze.scrollTop = ae.offsetTop - We * 4;
      }
    }, hn = (ae) => {
      const { datetimePanelValue: We } = p;
      p.datetimePanelValue = We ? new Date(We.getTime()) : /* @__PURE__ */ new Date(), en(ae.currentTarget);
    }, En = (ae, We) => {
      const { datetimePanelValue: Ze } = p;
      Ze && Ze.setHours(We.value), hn(ae);
    }, mn = () => {
      const { multiple: ae } = e, { datetimePanelValue: We } = p, Ze = M.value, ft = Q.value;
      if (ft) {
        const $t = P.value;
        if (ae) {
          const Mt = ye.value;
          if (ft) {
            const jt = [...L.value], qt = [];
            jt.forEach((tt) => {
              tt && (We && (tt.setHours(We.getHours()), tt.setMinutes(We.getMinutes()), tt.setSeconds(We.getSeconds())), qt.push(tt));
            }), q(qt.map((tt) => r.toDateString(tt, $t)).join(","), { type: "update" });
          } else
            q(Mt.join(","), { type: "update" });
        } else
          ct(Ze || p.currentDate);
      }
      re();
    }, gn = (ae, We) => {
      const { datetimePanelValue: Ze } = p;
      Ze && Ze.setMinutes(We.value), hn(ae);
    }, Sn = (ae, We) => {
      const { datetimePanelValue: Ze } = p;
      Ze && Ze.setSeconds(We.value), hn(ae);
    }, Fn = (ae) => {
      const { isActivated: We, datePanelValue: Ze, datePanelType: ft } = p;
      if (We) {
        ae.preventDefault();
        const $t = ut.hasKey(ae, Yt.ARROW_LEFT), Mt = ut.hasKey(ae, Yt.ARROW_UP), jt = ut.hasKey(ae, Yt.ARROW_RIGHT), qt = ut.hasKey(ae, Yt.ARROW_DOWN);
        if (ft === "year") {
          let tt = r.getWhatYear(Ze || Date.now(), 0, "first");
          $t ? tt = r.getWhatYear(tt, -1) : Mt ? tt = r.getWhatYear(tt, -4) : jt ? tt = r.getWhatYear(tt, 1) : qt && (tt = r.getWhatYear(tt, 4)), Qt(tt);
        } else if (ft === "quarter") {
          let tt = r.getWhatQuarter(Ze || Date.now(), 0, "first");
          $t ? tt = r.getWhatQuarter(tt, -1) : Mt ? tt = r.getWhatQuarter(tt, -2) : jt ? tt = r.getWhatQuarter(tt, 1) : qt && (tt = r.getWhatQuarter(tt, 2)), U(tt);
        } else if (ft === "month") {
          let tt = r.getWhatMonth(Ze || Date.now(), 0, "first");
          $t ? tt = r.getWhatMonth(tt, -1) : Mt ? tt = r.getWhatMonth(tt, -4) : jt ? tt = r.getWhatMonth(tt, 1) : qt && (tt = r.getWhatMonth(tt, 4)), Lt(tt);
        } else {
          let tt = Ze || r.getWhatDay(Date.now(), 0, "first");
          const _t = pe.value;
          $t ? tt = r.getWhatDay(tt, -1) : Mt ? tt = r.getWhatWeek(tt, -1, _t) : jt ? tt = r.getWhatDay(tt, 1) : qt && (tt = r.getWhatWeek(tt, 1, _t)), Gt(tt);
        }
      }
    }, co = (ae) => {
      const { isActivated: We } = p;
      if (We) {
        const Ze = ut.hasKey(ae, Yt.PAGE_UP);
        ae.preventDefault(), Ze ? Ee(ae) : rt(ae);
      }
    }, Uo = () => {
      const { type: ae } = e, We = Q.value, Ze = M.value;
      ["year", "quarter", "month", "week"].indexOf(ae) > -1 ? p.datePanelType = ae : p.datePanelType = "day", p.currentDate = r.getWhatDay(Date.now(), 0, "first"), Ze ? (nn(Ze, 0), be(Ze)) : zt(), We && (p.datetimePanelValue = p.datePanelValue || r.getWhatDay(Date.now(), 0, "first"), me(() => {
        const ft = h.value;
        r.arrayEach(ft.querySelectorAll("li.is--selected"), ($t) => {
          en($t);
        });
      }));
    }, Qn = () => {
      p.panelIndex < ws() && (p.panelIndex = ds());
    }, ho = () => me().then(() => {
      const { placement: ae } = e, { panelIndex: We } = p, Ze = D.value, ft = S.value, $t = E.value;
      if (Ze && ft) {
        const Mt = Ze.offsetHeight, jt = Ze.offsetWidth, qt = ft.offsetHeight, tt = ft.offsetWidth, _t = 5, In = {
          zIndex: We
        }, { boundingTop: yn, boundingLeft: Rn, visibleHeight: To, visibleWidth: vo } = br(Ze);
        let go = "bottom";
        if ($t) {
          let Xn = Rn, bo = yn + Mt;
          ae === "top" ? (go = "top", bo = yn - qt) : ae || (bo + qt + _t > To && (go = "top", bo = yn - qt), bo < _t && (go = "bottom", bo = yn + Mt)), Xn + tt + _t > vo && (Xn -= Xn + tt + _t - vo), Xn < _t && (Xn = _t), Object.assign(In, {
            left: `${Xn}px`,
            top: `${bo}px`,
            minWidth: `${jt}px`
          });
        } else
          ae === "top" ? (go = "top", In.bottom = `${Mt}px`) : ae || (In.top = `${Mt}px`, yn + Mt + qt > To && yn - Mt - qt > _t && (go = "top", In.top = "", In.bottom = `${Mt}px`));
        return p.panelStyle = In, p.panelPlacement = go, me();
      }
    }), Co = () => {
      const { visiblePanel: ae } = p, We = V.value, Ze = Z.value;
      return !We && !ae ? (p.initialized || (p.initialized = !0), w.hpTimeout && (clearTimeout(w.hpTimeout), w.hpTimeout = void 0), p.isActivated = !0, p.isAniVisible = !0, Ze && Uo(), setTimeout(() => {
        p.visiblePanel = !0;
      }, 10), Qn(), ho()) : me();
    }, Oo = (ae) => {
      C.value || (ae.preventDefault(), Co());
    }, Po = (ae) => {
      Ne(ae);
    }, Ys = (ae) => {
      const { visiblePanel: We, isActivated: Ze } = p, ft = Z.value, $t = v.value, Mt = x.value;
      !V.value && Ze && (p.isActivated = jn(ae, $t).flag || jn(ae, Mt).flag, p.isActivated || (ft ? We && (re(), Ke()) : Ke()));
    }, Fs = (ae) => {
      const { clearable: We } = e, { visiblePanel: Ze } = p, ft = Z.value;
      if (!V.value) {
        const Mt = ut.hasKey(ae, Yt.TAB), jt = ut.hasKey(ae, Yt.DELETE), qt = ut.hasKey(ae, Yt.ESCAPE), tt = ut.hasKey(ae, Yt.ENTER), _t = ut.hasKey(ae, Yt.ARROW_LEFT), In = ut.hasKey(ae, Yt.ARROW_UP), yn = ut.hasKey(ae, Yt.ARROW_RIGHT), Rn = ut.hasKey(ae, Yt.ARROW_DOWN), To = ut.hasKey(ae, Yt.PAGE_UP), vo = ut.hasKey(ae, Yt.PAGE_DOWN), go = _t || In || yn || Rn;
        let Xn = p.isActivated;
        Mt ? (Xn && Ke(), Xn = !1, p.isActivated = Xn) : go ? ft && Xn && (Ze ? Fn(ae) : (In || Rn) && Oo(ae)) : tt ? ft && (Ze ? p.datePanelValue ? Jt(p.datePanelValue) : re() : Xn && Oo(ae)) : (To || vo) && ft && Xn && co(ae), Mt || qt ? Ze && re() : jt && We && Xn && N(ae, null);
      }
    }, ms = (ae) => {
      const { visiblePanel: We } = p;
      if (!V.value && We) {
        const ft = x.value;
        jn(ae, ft).flag ? ho() : (re(), Ke());
      }
    }, xr = () => {
      const { isActivated: ae, visiblePanel: We } = p;
      We ? (re(), Ke()) : ae && Ke();
    };
    b = {
      dispatchEvent: (ae, We, Ze) => {
        s(ae, Zt(Ze, { $datePicker: g }, We));
      },
      focus() {
        const ae = D.value;
        return p.isActivated = !0, ae.focus(), me();
      },
      blur() {
        return D.value.blur(), p.isActivated = !1, me();
      },
      select() {
        return D.value.select(), p.isActivated = !1, me();
      },
      showPanel: Co,
      hidePanel: re,
      updatePlacement: ho
    }, Object.assign(g, b);
    const oo = (ae, We) => {
      const { festivalMethod: Ze } = e;
      if (Ze) {
        const { datePanelType: ft } = p, $t = Ze({ type: ft, viewType: ft, date: ae.date, $datePicker: g }), Mt = $t ? r.isString($t) ? { label: $t } : $t : {}, jt = Mt.extra ? r.isString(Mt.extra) ? { label: Mt.extra } : Mt.extra : null, qt = [
          o("span", {
            class: ["vxe-date-picker--date-label", {
              "is-notice": Mt.notice
            }]
          }, jt && jt.label ? [
            o("span", `${We}`),
            o("span", {
              class: ["vxe-date-picker--date-label--extra", jt.important ? "is-important" : "", jt.className],
              style: jt.style
            }, r.toValueString(jt.label))
          ] : `${We}`)
        ], tt = Mt.label;
        if (tt) {
          const _t = r.toValueString(tt).split(",");
          qt.push(o("span", {
            class: ["vxe-date-picker--date-festival", Mt.important ? "is-important" : "", Mt.className],
            style: Mt.style
          }, [
            _t.length > 1 ? o("span", {
              class: ["vxe-date-picker--date-festival--overlap", `overlap--${_t.length}`]
            }, _t.map((In) => o("span", In.substring(0, 3)))) : o("span", {
              class: "vxe-date-picker--date-festival--label"
            }, _t[0].substring(0, 3))
          ]));
        }
        return qt;
      }
      return We;
    }, Bo = () => {
      const { multiple: ae } = e, { datePanelType: We, datePanelValue: Ze } = p, ft = M.value, $t = $.value, Mt = Ue.value, jt = L.value, qt = "yyyyMMdd";
      return [
        o("table", {
          class: `vxe-date-picker--date-${We}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("thead", [
            o("tr", $t.map((tt) => o("th", tt.label)))
          ]),
          o("tbody", Mt.map((tt) => o("tr", tt.map((_t) => o("td", {
            class: {
              "is--prev": _t.isPrev,
              "is--current": _t.isCurrent,
              "is--now": _t.isNow,
              "is--next": _t.isNext,
              "is--disabled": Ot(_t),
              "is--selected": ae ? jt.some((In) => r.isDateSame(In, _t.date, qt)) : r.isDateSame(ft, _t.date, qt),
              "is--hover": r.isDateSame(Ze, _t.date, qt)
            },
            onClick: () => Bt(_t),
            onMouseenter: () => on(_t)
          }, oo(_t, _t.label))))))
        ])
      ];
    }, ko = () => {
      const { multiple: ae } = e, { datePanelType: We, datePanelValue: Ze } = p, ft = M.value, $t = J.value, Mt = Ae.value, jt = L.value, qt = "yyyyMMdd";
      return [
        o("table", {
          class: `vxe-date-picker--date-${We}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("thead", [
            o("tr", $t.map((tt) => o("th", tt.label)))
          ]),
          o("tbody", Mt.map((tt) => {
            const _t = ae ? tt.some((yn) => jt.some((Rn) => r.isDateSame(Rn, yn.date, qt))) : tt.some((yn) => r.isDateSame(ft, yn.date, qt)), In = tt.some((yn) => r.isDateSame(Ze, yn.date, qt));
            return o("tr", tt.map((yn) => o("td", {
              class: {
                "is--prev": yn.isPrev,
                "is--current": yn.isCurrent,
                "is--now": yn.isNow,
                "is--next": yn.isNext,
                "is--disabled": Ot(yn),
                "is--selected": _t,
                "is--hover": In
              },
              // event
              onClick: () => Bt(yn),
              onMouseenter: () => on(yn)
            }, oo(yn, yn.label))));
          }))
        ])
      ];
    }, _o = () => {
      const { multiple: ae } = e, { datePanelType: We, datePanelValue: Ze } = p, ft = M.value, $t = Ie.value, Mt = L.value, jt = "yyyyMM";
      return [
        o("table", {
          class: `vxe-date-picker--date-${We}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tbody", $t.map((qt) => o("tr", qt.map((tt) => o("td", {
            class: {
              "is--prev": tt.isPrev,
              "is--current": tt.isCurrent,
              "is--now": tt.isNow,
              "is--next": tt.isNext,
              "is--disabled": Ot(tt),
              "is--selected": ae ? Mt.some((_t) => r.isDateSame(_t, tt.date, jt)) : r.isDateSame(ft, tt.date, jt),
              "is--hover": r.isDateSame(Ze, tt.date, jt)
            },
            onClick: () => Bt(tt),
            onMouseenter: () => on(tt)
          }, oo(tt, Pe(`vxe.input.date.months.m${tt.month}`)))))))
        ])
      ];
    }, ts = () => {
      const { multiple: ae } = e, { datePanelType: We, datePanelValue: Ze } = p, ft = M.value, $t = Se.value, Mt = L.value, jt = "yyyyq";
      return [
        o("table", {
          class: `vxe-date-picker--date-${We}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tbody", $t.map((qt) => o("tr", qt.map((tt) => o("td", {
            class: {
              "is--prev": tt.isPrev,
              "is--current": tt.isCurrent,
              "is--now": tt.isNow,
              "is--next": tt.isNext,
              "is--disabled": Ot(tt),
              "is--selected": ae ? Mt.some((_t) => r.isDateSame(_t, tt.date, jt)) : r.isDateSame(ft, tt.date, jt),
              "is--hover": r.isDateSame(Ze, tt.date, jt)
            },
            onClick: () => Bt(tt),
            onMouseenter: () => on(tt)
          }, oo(tt, Pe(`vxe.input.date.quarters.q${tt.quarter}`)))))))
        ])
      ];
    }, Kn = () => {
      const { multiple: ae } = e, { datePanelType: We, datePanelValue: Ze } = p, ft = M.value, $t = ge.value, Mt = L.value, jt = "yyyy";
      return [
        o("table", {
          class: `vxe-date-picker--date-${We}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tbody", $t.map((qt) => o("tr", qt.map((tt) => o("td", {
            class: {
              "is--prev": tt.isPrev,
              "is--current": tt.isCurrent,
              "is--now": tt.isNow,
              "is--next": tt.isNext,
              "is--disabled": Ot(tt),
              "is--selected": ae ? Mt.some((_t) => r.isDateSame(_t, tt.date, jt)) : r.isDateSame(ft, tt.date, jt),
              "is--hover": r.isDateSame(Ze, tt.date, jt)
            },
            onClick: () => Bt(tt),
            onMouseenter: () => on(tt)
          }, oo(tt, tt.year))))))
        ])
      ];
    }, $o = () => {
      const { datePanelType: ae } = p;
      switch (ae) {
        case "week":
          return ko();
        case "month":
          return _o();
        case "quarter":
          return ts();
        case "year":
          return Kn();
      }
      return Bo();
    }, Wo = () => {
      const { multiple: ae } = e, { datePanelType: We } = p, Ze = I.value, ft = B.value, $t = fe.value;
      return [
        o("div", {
          class: "vxe-date-picker--date-picker-header"
        }, [
          o("div", {
            class: "vxe-date-picker--date-picker-type-wrapper"
          }, [
            We === "year" ? o("span", {
              class: "vxe-date-picker--date-picker-label"
            }, $t) : o("span", {
              class: "vxe-date-picker--date-picker-btn",
              onClick: At
            }, $t)
          ]),
          o("div", {
            class: "vxe-date-picker--date-picker-btn-wrapper"
          }, [
            o("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-prev-btn", {
                "is--disabled": Ze
              }],
              onClick: Ee
            }, [
              o("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            o("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-current-btn",
              onClick: Ye
            }, [
              o("i", {
                class: "vxe-icon-dot"
              })
            ]),
            o("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-next-btn", {
                "is--disabled": ft
              }],
              onClick: rt
            }, [
              o("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            ae && K.value ? o("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-confirm-btn"
            }, [
              o("button", {
                class: "vxe-date-picker--date-picker-confirm",
                type: "button",
                onClick: mn
              }, Pe("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        o("div", {
          class: "vxe-date-picker--date-picker-body"
        }, $o())
      ];
    }, Go = () => {
      const { datetimePanelValue: ae } = p, We = H.value, Ze = _e.value, ft = vt.value, $t = it.value, Mt = dt.value, jt = at.value;
      return [
        o("div", {
          class: "vxe-date-picker--time-picker-header"
        }, [
          ft ? o("div", {
            class: "vxe-date-picker--time-picker-title"
          }, We) : Ve(),
          o("div", {
            class: "vxe-date-picker--time-picker-btn"
          }, [
            o("button", {
              class: "vxe-date-picker--time-picker-confirm",
              type: "button",
              onClick: mn
            }, Pe("vxe.button.confirm"))
          ])
        ]),
        o("div", {
          ref: h,
          class: "vxe-date-picker--time-picker-body"
        }, [
          o("ul", {
            class: "vxe-date-picker--time-picker-hour-list"
          }, Ze.map((qt, tt) => o("li", {
            key: tt,
            class: {
              "is--selected": ae && ae.getHours() === qt.value
            },
            onClick: (_t) => En(_t, qt)
          }, qt.label))),
          ft ? o("ul", {
            class: "vxe-date-picker--time-picker-minute-list"
          }, $t.map((qt, tt) => o("li", {
            key: tt,
            class: {
              "is--selected": ae && ae.getMinutes() === qt.value
            },
            onClick: (_t) => gn(_t, qt)
          }, qt.label))) : Ve(),
          ft && Mt ? o("ul", {
            class: "vxe-date-picker--time-picker-second-list"
          }, jt.map((qt, tt) => o("li", {
            key: tt,
            class: {
              "is--selected": ae && ae.getSeconds() === qt.value
            },
            onClick: (_t) => Sn(_t, qt)
          }, qt.label))) : Ve()
        ])
      ];
    }, Xs = () => {
      const { type: ae } = e, { initialized: We, isAniVisible: Ze, visiblePanel: ft, panelPlacement: $t, panelStyle: Mt } = p, jt = d.value, qt = Z.value, tt = E.value, _t = [];
      return qt ? (ae === "datetime" ? _t.push(o("div", {
        key: ae,
        ref: x,
        class: "vxe-date-picker--panel-layout-wrapper"
      }, [
        o("div", {
          class: "vxe-date-picker--panel-left-wrapper"
        }, Wo()),
        o("div", {
          class: "vxe-date-picker--panel-right-wrapper"
        }, Go())
      ])) : ae === "time" ? _t.push(o("div", {
        key: ae,
        ref: x,
        class: "vxe-date-picker--panel-wrapper"
      }, Go())) : _t.push(o("div", {
        key: ae || "default",
        ref: x,
        class: "vxe-date-picker--panel-wrapper"
      }, Wo())), o(ks, {
        to: "body",
        disabled: tt ? !We : !0
      }, [
        o("div", {
          ref: S,
          class: ["vxe-table--ignore-clear vxe-date-picker--panel", `type--${ae}`, {
            [`size--${jt}`]: jt,
            "is--transfer": tt,
            "ani--leave": Ze,
            "ani--enter": ft
          }],
          placement: $t,
          style: Mt
        }, We && (ft || Ze) ? _t : [])
      ])) : Ve();
    }, yr = () => {
      const { prefixIcon: ae } = e, We = n.prefix;
      return We || ae ? o("div", {
        class: "vxe-date-picker--prefix",
        onClick: F
      }, [
        o("div", {
          class: "vxe-date-picker--prefix-icon"
        }, We ? Nt(We({})) : [
          o("i", {
            class: ae
          })
        ])
      ]) : null;
    }, ns = () => {
      const { suffixIcon: ae } = e, { inputValue: We } = p, Ze = n.suffix, ft = V.value, $t = G.value;
      return o("div", {
        class: ["vxe-date-picker--suffix", {
          "is--clear": $t && !ft && !(We === "" || r.eqNull(We))
        }]
      }, [
        $t ? o("div", {
          class: "vxe-date-picker--clear-icon",
          onClick: N
        }, [
          o("i", {
            class: ht().INPUT_CLEAR
          })
        ]) : Ve(),
        zr(),
        Ze || ae ? o("div", {
          class: "vxe-date-picker--suffix-icon",
          onClick: ee
        }, Ze ? Nt(Ze({})) : [
          o("i", {
            class: ae
          })
        ]) : Ve()
      ]);
    }, zr = () => o("div", {
      class: "vxe-date-picker--control-icon",
      onClick: Oo
    }, [
      o("i", {
        class: ["vxe-date-picker--date-picker-icon", ht().DATE_PICKER_DATE]
      })
    ]), mo = () => {
      const { className: ae, type: We, align: Ze, name: ft, autocomplete: $t, autoComplete: Mt } = e, { inputValue: jt, visiblePanel: qt, isActivated: tt } = p, _t = d.value, In = V.value;
      if (C.value)
        return o("div", {
          ref: v,
          class: ["vxe-date-picker--readonly", `type--${We}`, ae]
        }, jt);
      const Rn = Et.value, To = Qe.value, vo = De.value, go = G.value, Xn = yr(), bo = ns();
      return o("div", {
        ref: v,
        class: ["vxe-date-picker", `type--${We}`, ae, {
          [`size--${_t}`]: _t,
          [`is--${Ze}`]: Ze,
          "is--prefix": !!Xn,
          "is--suffix": !!bo,
          "is--visible": qt,
          "is--disabled": In,
          "is--active": tt,
          "show--clear": go && !In && !(jt === "" || r.eqNull(jt))
        }],
        spellcheck: !1
      }, [
        Xn || Ve(),
        o("div", {
          class: "vxe-date-picker--wrapper"
        }, [
          o("input", {
            ref: D,
            class: "vxe-date-picker--inner",
            value: jt,
            name: ft,
            type: To,
            placeholder: vo,
            readonly: Rn,
            disabled: In,
            autocomplete: Mt || $t,
            onKeydown: St,
            onKeyup: Dt,
            onWheel: Wt,
            onClick: Po,
            onInput: z,
            onChange: R,
            onFocus: le,
            onBlur: wt
          })
        ]),
        bo || Ve(),
        // 下拉面板
        Xs()
      ]);
    };
    return lt(() => e.modelValue, (ae) => {
      Be(ae), we();
    }), lt(() => e.type, () => {
      Object.assign(p, {
        inputValue: "",
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      }), Te();
    }), lt(A, () => {
      Z.value && (be(p.datePanelValue), p.inputValue = e.multiple ? se.value : p.datePanelLabel);
    }), me(() => {
      ut.on(g, "mousewheel", ms), ut.on(g, "mousedown", Ys), ut.on(g, "keydown", Fs), ut.on(g, "blur", xr);
    }), $n(() => {
      ut.off(g, "mousewheel"), ut.off(g, "mousedown"), ut.off(g, "keydown"), ut.off(g, "blur");
    }), Te(), g.renderVN = mo, g;
  },
  render() {
    return this.renderVN();
  }
}), IL = Object.assign({}, Il, {
  install(e) {
    e.component(Il.name, Il), e.component("VxeDateInput", Il);
  }
});
Ht.use(IL);
Ce.component(Il);
const Xc = Object.assign({}, us, {
  install(e) {
    e.component(us.name, us);
  }
}), VL = {
  open(e) {
    const t = Object.assign({}, e);
    Vs.globalLoading = {
      modelValue: !0,
      text: t.text,
      icon: t.icon
    }, Yc();
  },
  close() {
    Vs.globalLoading = null;
  }
};
Ht.use(Xc);
Ce.component(us);
Ce.loading = VL;
const Jr = [], Ya = pt({
  name: "VxeDrawer",
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: {
      type: Boolean,
      default: null
    },
    className: String,
    position: {
      type: [String, Object],
      default: () => oe().drawer.position
    },
    lockView: {
      type: Boolean,
      default: () => oe().drawer.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => oe().drawer.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => oe().drawer.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => oe().drawer.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => oe().drawer.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => oe().drawer.confirmClosable
    },
    showHeader: {
      type: Boolean,
      default: () => oe().drawer.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => oe().drawer.showFooter
    },
    showClose: {
      type: Boolean,
      default: () => oe().drawer.showClose
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => oe().drawer.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => oe().drawer.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => oe().drawer.confirmButtonText
    },
    destroyOnClose: {
      type: Boolean,
      default: () => oe().drawer.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => oe().drawer.showTitleOverflow
    },
    width: [Number, String],
    height: [Number, String],
    resize: {
      type: Boolean,
      default: () => oe().drawer.resize
    },
    zIndex: Number,
    transfer: {
      type: Boolean,
      default: () => oe().drawer.transfer
    },
    padding: {
      type: Boolean,
      default: () => oe().drawer.padding
    },
    size: {
      type: String,
      default: () => oe().drawer.size || oe().size
    },
    beforeHideMethod: {
      type: Function,
      default: () => oe().drawer.beforeHideMethod
    },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "resize"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = ke(), c = ke(), m = ke(), u = ke(), d = Rt({
      initialized: !1,
      visible: !1,
      contentVisible: !1,
      drawerZIndex: 0
    }), p = {
      refElem: a
    }, w = _(() => {
      switch (e.position) {
        case "top":
          return "sb";
        case "bottom":
          return "st";
        case "left":
          return "wr";
      }
      return "wl";
    }), v = {}, D = {
      xID: i,
      props: e,
      context: t,
      reactData: d,
      getRefMaps: () => p,
      getComputeMaps: () => v
    }, S = () => c.value, x = () => {
      const { width: B, height: H } = e, ce = S();
      return ce && (ce.style.width = cn(B), ce.style.height = cn(H)), me();
    }, h = () => {
      const { zIndex: B } = e, { drawerZIndex: H } = d;
      B ? d.drawerZIndex = B : H < ws() && (d.drawerZIndex = ds());
    }, O = (B) => {
      const { beforeHideMethod: H } = e, { visible: ce } = d, A = { type: B };
      return ce && Promise.resolve(H ? H(A) : null).then((j) => {
        r.isError(j) || (d.contentVisible = !1, r.remove(Jr, (fe) => fe === D), V("before-hide", A, null), setTimeout(() => {
          d.visible = !1, s("update:modelValue", !1), V("hide", A, null);
        }, 200));
      }).catch((j) => j), me();
    }, g = (B) => {
      const H = "close";
      V(H, { type: H }, B), O(H);
    }, b = (B) => {
      const { confirmClosable: H } = e, ce = "confirm";
      V(ce, { type: ce }, B), H && O(ce);
    }, E = (B) => {
      const { cancelClosable: H } = e, ce = "cancel";
      V(ce, { type: ce }, B), H && O(ce);
    }, C = () => {
      const { showFooter: B } = e, { initialized: H, visible: ce } = d;
      return H || (d.initialized = !0), ce || (d.visible = !0, d.contentVisible = !1, h(), Jr.push(D), setTimeout(() => {
        x(), d.contentVisible = !0, me(() => {
          if (B) {
            const fe = m.value, pe = u.value, ne = fe || pe;
            ne && ne.focus();
          }
          const j = { type: "" };
          s("update:modelValue", !0), V("show", j, null);
        });
      }, 10)), me();
    }, V = (B, H, ce) => {
      s(B, Zt(ce, { $drawer: D }, H));
    }, Q = {
      dispatchEvent: V,
      open: C,
      close() {
        return O("close");
      },
      getBox: S
    }, Z = (B) => {
      const H = a.value;
      e.maskClosable && B.target === H && O("mask");
    }, G = (B) => {
      if (ut.hasKey(B, Yt.ESCAPE)) {
        const ce = r.max(Jr, (A) => A.reactData.drawerZIndex);
        ce && setTimeout(() => {
          if (ce === D && ce.props.escClosable) {
            const A = "exit";
            V("close", { type: A }, B), O(A);
          }
        }, 10);
      }
    }, ue = () => {
      const { drawerZIndex: B } = d;
      Jr.some((H) => H.reactData.visible && H.reactData.drawerZIndex > B) && h();
    }, Y = (B) => {
      B.preventDefault();
      const { visibleHeight: H, visibleWidth: ce } = tl(), A = 0, fe = B.target.getAttribute("type"), pe = 0, ne = 0, $ = ce, J = H, ge = S(), Oe = document.onmousemove, Se = document.onmouseup, de = ge.clientWidth, Ie = ge.clientHeight, je = B.clientX, Ue = B.clientY, Ae = ge.offsetTop, _e = ge.offsetLeft, it = { type: "resize" };
      document.onmousemove = (vt) => {
        vt.preventDefault();
        let dt, at, Et, Qe;
        switch (fe) {
          case "wl":
            dt = je - vt.clientX, Et = dt + de, _e - dt > A && Et > pe && (ge.style.width = `${Et < $ ? Et : $}px`);
            break;
          case "st":
            at = Ue - vt.clientY, Qe = Ie + at, Ae - at > A && Qe > ne && (ge.style.height = `${Qe < J ? Qe : J}px`);
            break;
          case "wr":
            dt = vt.clientX - je, Et = dt + de, _e + Et + A < ce && Et > pe && (ge.style.width = `${Et < $ ? Et : $}px`);
            break;
          case "sb":
            at = vt.clientY - Ue, Qe = at + Ie, Ae + Qe + A < H && Qe > ne && (ge.style.height = `${Qe < J ? Qe : J}px`);
            break;
        }
        ge.className = ge.className.replace(/\s?is--drag/, "") + " is--drag", V("resize", it, vt);
      }, document.onmouseup = () => {
        document.onmousemove = Oe, document.onmouseup = Se, setTimeout(() => {
          ge.className = ge.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    Object.assign(D, Q, {});
    const L = () => {
      const { slots: B = {}, showClose: H, title: ce } = e, A = n.title || B.title, j = n.corner || B.corner;
      return [
        o("div", {
          class: "vxe-drawer--header-title"
        }, A ? Nt(A({ $drawer: D })) : ce ? Bn(ce) : Pe("vxe.alert.title")),
        o("div", {
          class: "vxe-drawer--header-right"
        }, [
          j ? o("div", {
            class: "vxe-drawer--corner-wrapper"
          }, Nt(j({ $drawer: D }))) : Yn(),
          H ? o("div", {
            class: ["vxe-drawer--close-btn", "trigger--btn"],
            title: Pe("vxe.drawer.close"),
            onClick: g
          }, [
            o("i", {
              class: ht().DRAWER_CLOSE
            })
          ]) : Yn()
        ])
      ];
    }, ye = () => {
      const { slots: B = {}, showTitleOverflow: H } = e, ce = n.header || B.header;
      return e.showHeader ? o("div", {
        class: ["vxe-drawer--header", {
          "is--ellipsis": H
        }]
      }, ce ? Nt(ce({ $drawer: D })) : L()) : Yn();
    }, se = () => {
      const { slots: B = {}, content: H } = e, ce = n.default || B.default, A = n.left || B.left, j = n.right || B.right;
      return o("div", {
        class: "vxe-drawer--body"
      }, [
        A ? o("div", {
          class: "vxe-drawer--body-left"
        }, Nt(A({ $drawer: D }))) : Yn(),
        o("div", {
          class: "vxe-drawer--body-default"
        }, [
          o("div", {
            class: "vxe-drawer--content"
          }, ce ? Nt(ce({ $drawer: D })) : Bn(H))
        ]),
        j ? o("div", {
          class: "vxe-drawer--body-right"
        }, Nt(j({ $drawer: D }))) : Yn(),
        o(Xc, {
          class: "vxe-drawer--loading",
          modelValue: e.loading
        })
      ]);
    }, P = () => {
      const { slots: B = {}, showCancelButton: H, showConfirmButton: ce, loading: A } = e, j = n.leftfoot || B.leftfoot, fe = n.rightfoot || B.rightfoot, pe = [];
      return H && pe.push(o(Vn, {
        key: 1,
        ref: u,
        content: e.cancelButtonText || Pe("vxe.button.cancel"),
        onClick: E
      })), ce && pe.push(o(Vn, {
        key: 2,
        ref: m,
        loading: A,
        status: "primary",
        content: e.confirmButtonText || Pe("vxe.button.confirm"),
        onClick: b
      })), o("div", {
        class: "vxe-drawer--footer-wrapper"
      }, [
        o("div", {
          class: "vxe-drawer--footer-left"
        }, j ? Nt(j({ $drawer: D })) : []),
        o("div", {
          class: "vxe-drawer--footer-right"
        }, fe ? Nt(fe({ $drawer: D })) : pe)
      ]);
    }, M = () => {
      const { slots: B = {} } = e, H = n.footer || B.footer;
      return e.showFooter ? o("div", {
        class: "vxe-drawer--footer"
      }, H ? Nt(H({ $drawer: D })) : [P()]) : Yn();
    }, I = () => {
      const { slots: B = {}, className: H, position: ce, loading: A, lockScroll: j, padding: fe, lockView: pe, mask: ne, resize: $, destroyOnClose: J } = e, { initialized: ge, contentVisible: Oe, visible: Se } = d, de = n.aside || B.aside, Ie = l.value, je = w.value;
      return o(ks, {
        to: "body",
        disabled: e.transfer ? !ge : !0
      }, [
        o("div", {
          ref: a,
          class: ["vxe-drawer--wrapper", `pos--${ce}`, H || "", {
            [`size--${Ie}`]: Ie,
            "is--padding": fe,
            "lock--scroll": j,
            "lock--view": pe,
            "is--resize": $,
            "is--mask": ne,
            "is--visible": Oe,
            "is--active": Se,
            "is--loading": A
          }],
          style: {
            zIndex: d.drawerZIndex
          },
          onClick: Z
        }, [
          o("div", {
            ref: c,
            class: "vxe-drawer--box",
            onMousedown: ue
          }, [
            de ? o("div", {
              class: "vxe-drawer--aside"
            }, Nt(de({ $drawer: D }))) : Yn(),
            o("div", {
              class: "vxe-drawer--container"
            }, !d.initialized || J && !d.visible ? [] : [
              ye(),
              se(),
              M(),
              $ ? o("span", {
                class: "vxe-drawer--resize"
              }, [
                o("span", {
                  class: `${je}-resize`,
                  type: je,
                  onMousedown: Y
                })
              ]) : Yn()
            ])
          ])
        ])
      ]);
    };
    return lt(() => e.width, x), lt(() => e.height, x), lt(() => e.modelValue, (B) => {
      B ? C() : O("model");
    }), wn(() => {
      me(() => {
        e.modelValue && C(), x();
      }), e.escClosable && ut.on(D, "keydown", G);
    }), $n(() => {
      ut.off(D, "keydown");
    }), bn("$xeDrawer", "$xeDrawer"), D.renderVN = I, D;
  },
  render() {
    return this.renderVN();
  }
});
function PL(e) {
  return Yc(), new Promise((t) => {
    if (e && e.id && Jr.some((n) => n.props.id === e.id))
      t("exist");
    else {
      const n = e.onHide, s = Object.assign(e, {
        key: r.uniqueId(),
        modelValue: !0,
        onHide(i) {
          const l = Vs.drawers;
          n && n(i), Vs.drawers = l.filter((a) => a.key !== s.key), t(i.type);
        }
      });
      Vs.drawers.push(s);
    }
  });
}
function yv(e) {
  return r.find(Jr, (t) => t.props.id === e);
}
function kL(e) {
  const t = e ? [yv(e)] : Jr, n = [];
  return t.forEach((s) => {
    s && n.push(s.close());
  }), Promise.all(n);
}
function $L(e) {
  return PL(Object.assign({}, e));
}
const RL = {
  get: yv,
  close: kL,
  open: $L
}, Cv = Object.assign(Ya, {
  install: function(e) {
    e.component(Ya.name, Ya);
  }
});
Ce.drawer = RL;
Ht.use(Cv);
Ce.component(Ya);
const Xa = pt({
  name: "VxeEmpty",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    status: String,
    content: [String, Number]
  },
  emits: [],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), i = ke(), l = Rt({}), a = {
      refElem: i
    }, c = {}, m = {
      xID: s,
      props: e,
      context: t,
      reactData: l,
      getRefMaps: () => a,
      getComputeMaps: () => c
    };
    Object.assign(m, {
      dispatchEvent: (v, D, S) => {
        n(v, Zt(S, { $empty: m }, D));
      }
    }, {});
    const w = () => {
      const { imageUrl: v, imageStyle: D, icon: S, status: x, content: h } = e;
      return o("div", {
        ref: i,
        class: ["vxe-empty", {
          [`theme--${x}`]: x
        }]
      }, [
        o("div", {
          class: "vxe-empty--inner"
        }, [
          v ? o("div", {
            class: "vxe-empty--img-wrapper"
          }, [
            o("img", {
              src: v,
              style: D
            })
          ]) : o("div", {
            class: "vxe-empty--icon-wrapper"
          }, [
            o("i", {
              class: S || ht().EMPTY_DEFAULT
            })
          ]),
          o("div", {
            class: "vxe-empty--content-wrapper"
          }, `${h || Pe("vxe.empty.defText")}`)
        ])
      ]);
    };
    return m.renderVN = w, m;
  },
  render() {
    return this.renderVN();
  }
}), NL = Object.assign({}, Xa, {
  install(e) {
    e.component(Xa.name, Xa);
  }
});
Ht.use(NL);
Ce.component(Xa);
class wv {
  constructor(t, n) {
    Object.assign(this, {
      id: r.uniqueId("item_"),
      title: n.title,
      field: n.field,
      span: n.span,
      align: n.align,
      verticalAlign: n.verticalAlign,
      titleBackground: n.titleBackground,
      titleBold: n.titleBold,
      titleAlign: n.titleAlign,
      titleWidth: n.titleWidth,
      titleColon: n.titleColon,
      vertical: n.vertical,
      padding: n.padding,
      titleAsterisk: n.titleAsterisk,
      titlePrefix: n.titlePrefix,
      titleSuffix: n.titleSuffix,
      titleOverflow: n.titleOverflow,
      showTitle: n.showTitle,
      resetValue: n.resetValue,
      visibleMethod: n.visibleMethod,
      visible: n.visible,
      showContent: n.showContent,
      folding: n.folding,
      collapseNode: n.collapseNode,
      className: n.className,
      contentClassName: n.contentClassName,
      contentStyle: n.contentStyle,
      titleClassName: n.titleClassName,
      titleStyle: n.titleStyle,
      itemRender: n.itemRender,
      rules: n.rules,
      // 渲染属性
      showError: !1,
      errRule: null,
      slots: n.slots,
      children: []
    });
  }
  update(t, n) {
    this[t] = n;
  }
}
function FL(e) {
  return e instanceof wv;
}
function Od(e, t) {
  return FL(t) ? t : new wv(e, t);
}
function sm(e, t) {
  return t ? r.isString(t) ? e.getItemByField(t) : t : null;
}
function LL(e, t) {
  const { reactData: n } = e, { collapseAll: s } = n, { folding: i, visible: l } = t;
  return l === !1 || i && s;
}
function Ev(e, t) {
  let { visibleMethod: n, itemRender: s, visible: i, field: l } = t;
  if (i === !1)
    return i;
  const a = xs(s) ? Cn.get(s.name) : null, c = a ? a.formItemVisibleMethod || a.itemVisibleMethod : null;
  if (!n && c && (n = c), !n)
    return !0;
  const m = e.props, { data: u } = m;
  return n({ data: u, field: l, property: l, item: t, $form: e, $grid: e.xegrid });
}
function Sv(e, t) {
  Object.keys(e).forEach((n) => {
    lt(() => e[n], (s) => {
      t.update(n, s);
    });
  });
}
function Dv(e, t, n, s) {
  const { reactData: i } = e, l = e.props, { customLayout: a } = l, { staticItems: c } = i;
  if (a)
    c.some((m) => m.id === n.id) || c.push(n);
  else if (t) {
    const m = t.parentNode, u = s ? s.formItem : null, d = u ? u.children : c;
    m && (d.splice(r.arrayIndexOf(m.children, t), 0, n), i.staticItems = c.slice(0));
  }
}
function Ov(e, t) {
  const { reactData: n } = e, { staticItems: s } = n, i = r.findIndexOf(s, (l) => l.id === t.id);
  i > -1 && s.splice(i, 1), n.staticItems = s.slice(0);
}
const _l = pt({
  name: "VxeIcon",
  props: {
    name: String,
    className: String,
    roll: Boolean,
    status: String,
    size: {
      type: String,
      default: () => oe().icon.size || oe().size
    }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), { computeSize: i } = dn(e), l = {
      xID: s,
      props: e,
      context: t
    }, a = (p) => {
      n("click", Zt(p, {}));
    };
    Object.assign(l, {
      dispatchEvent: (p, w, v) => {
        n(p, Zt(v, { $icon: l }, w));
      }
    }, {});
    const d = () => {
      const { name: p, roll: w, status: v, className: D } = e, S = i.value;
      return o("i", {
        class: ["vxe-icon", `vxe-icon-${p}`, `${D || ""}`, {
          [`size--${S}`]: S,
          [`theme--${v}`]: v,
          roll: w
        }],
        onClick: a
      });
    };
    return l.renderVN = d, l;
  },
  render() {
    return this.renderVN();
  }
});
function rm(e) {
  return o("span", {
    class: "vxe-form--item-title-prefix"
  }, [
    o(_l, {
      class: e.icon || ht().FORM_PREFIX,
      status: e.iconStatus
    })
  ]);
}
function lm(e) {
  return o("span", {
    class: "vxe-form--item-title-suffix"
  }, [
    o(_l, {
      class: e.icon || ht().FORM_SUFFIX,
      status: e.iconStatus
    })
  ]);
}
const Td = (e, t, n) => {
  const s = e.props, i = e.reactData, { data: l, rules: a, readonly: c, disabled: m, span: u, titleBackground: d, titleBold: p, titleColon: w, titleAsterisk: v, vertical: D, padding: S } = s, { collapseAll: x } = i, { folding: h, field: O, itemRender: g, showError: b, className: E, vertical: C, padding: V, children: Q, showContent: Z } = t, G = xs(g) ? Cn.get(g.name) : null, ue = G ? G.formItemClassName || G.itemClassName : "", Y = t.span || u, K = r.eqNull(V) ? S : V, L = r.eqNull(C) ? D : C, ye = r.eqNull(t.titleBackground) ? d : t.titleBackground, se = r.eqNull(t.titleBold) ? p : t.titleBold, P = r.eqNull(t.titleColon) ? w : t.titleColon, M = r.eqNull(t.titleAsterisk) ? v : t.titleAsterisk, I = { data: l, disabled: m, readonly: c, field: O, property: O, item: t, $form: e, $grid: e.xegrid }, B = Q && Q.length > 0;
  let H = !1, ce = !1;
  if (!c && a) {
    const A = a[O];
    A && A.length && (ce = !0, H = A.some((j) => j.required));
  }
  return [
    n || B ? "vxe-form--group" : "",
    "vxe-form--item",
    t.id,
    Y ? `vxe-form--item-col_${Y} is--span` : "",
    E ? r.isFunction(E) ? E(I) : E : "",
    ue ? r.isFunction(ue) ? ue(I) : ue : "",
    {
      "is--colon": P,
      "is--tbg": ye,
      "is--bold": se,
      "is--padding": K,
      "is--vertical": L,
      "is--asterisk": M,
      "hide--content": Z === !1,
      "is--valid": ce,
      "is--required": H,
      "is--hidden": h && x,
      "is--active": Ev(e, t),
      "is--error": b
    }
  ];
}, Md = (e, t, n) => {
  const s = e.props, { data: i, readonly: l, disabled: a, align: c, verticalAlign: m } = s, { field: u, itemRender: d, contentClassName: p, children: w } = t, v = xs(d) ? Cn.get(d.name) : null, D = v ? v.formItemContentClassName || v.itemContentClassName : "", S = r.eqNull(t.align) ? c : t.align, x = r.eqNull(t.verticalAlign) ? m : t.verticalAlign, h = { data: i, disabled: a, readonly: l, field: u, property: u, item: t, $form: e, $grid: e.xegrid }, O = w && w.length > 0;
  return [
    n || O ? "vxe-form--group-content vxe-form--item-row" : "",
    "vxe-form--item-content",
    S ? `align--${S}` : "",
    x ? `vertical-align--${x}` : "",
    D ? r.isFunction(D) ? D(h) : D : "",
    p ? r.isFunction(p) ? p(h) : p : ""
  ];
};
function Id(e, t, n) {
  const s = e.props, { data: i, readonly: l, disabled: a, titleAlign: c, titleWidth: m, titleOverflow: u, vertical: d } = s, { slots: p, title: w, field: v, itemRender: D, titleOverflow: S, vertical: x, showTitle: h, titleClassName: O, titleStyle: g, titlePrefix: b, titleSuffix: E, children: C, showContent: V } = t, { computeTooltipOpts: Q } = e.getComputeMaps(), Z = Q.value, G = xs(D) ? Cn.get(D.name) : null, ue = G ? G.formItemTitleClassName || G.itemTitleClassName : "", Y = G ? G.formItemTitleStyle || G.itemTitleStyle : null, K = r.eqNull(x) ? d : x, L = r.eqNull(t.titleAlign) ? c : t.titleAlign, ye = K ? null : r.eqNull(t.titleWidth) ? m : t.titleWidth, se = r.eqNull(S) ? u : S, P = se === "ellipsis", M = se === "title", I = se === !0 || se === "tooltip", B = M || I || P, H = { data: i, disabled: a, readonly: l, field: v, property: v, item: t, $form: e, $grid: e.xegrid }, ce = p ? p.title : null, A = p ? p.extra : null, j = h !== !1 && (w || ce), fe = C && C.length > 0, pe = [];
  b && pe.push(b.content || b.message ? o(Rr, Object.assign(Object.assign(Object.assign({}, Z), b), { content: Bn(b.content || b.message) }), {
    default: () => rm(b)
  }) : rm(b));
  const ne = G ? G.renderFormItemTitle || G.renderItemTitle : null;
  pe.push(o("span", {
    class: "vxe-form--item-title-label"
  }, ce ? e.callSlot(ce, H) : ne ? Nt(ne(D, H)) : Bn(t.title)));
  const $ = [];
  E && $.push(E.content || E.message ? o(Rr, Object.assign(Object.assign(Object.assign({}, Z), E), { content: Bn(E.content || E.message) }), {
    default: () => lm(E)
  }) : lm(E));
  const J = I ? {
    onMouseenter(ge) {
      e.triggerTitleTipEvent(ge, H);
    },
    onMouseleave: e.handleTitleTipLeaveEvent
  } : {};
  return j ? o("div", Object.assign({ class: [
    n || fe ? "vxe-form--group-title" : "",
    "vxe-form--item-title",
    L ? `align--${L}` : "",
    B ? "is--ellipsis" : "",
    ue ? r.isFunction(ue) ? ue(H) : ue : "",
    O ? r.isFunction(O) ? O(H) : O : ""
  ], style: Object.assign({}, r.isFunction(Y) ? Y(H) : Y, r.isFunction(g) ? g(H) : g, ye && V !== !1 ? {
    width: cn(ye)
  } : null), title: M ? Bn(w) : null }, J), [
    o("div", {
      class: "vxe-form--item-title-content"
    }, pe),
    o("div", {
      class: "vxe-form--item-title-postfix"
    }, $),
    A ? o("div", {
      class: "vxe-form--item-title-extra"
    }, e.callSlot(A, H)) : Ve()
  ]) : Ve();
}
const Tv = (e, t) => {
  const n = e.props, s = e.reactData, { computeCollapseOpts: i, computeValidOpts: l } = e.getComputeMaps(), { data: a, readonly: c, disabled: m } = n, { collapseAll: u } = s, { slots: d, field: p, itemRender: w, collapseNode: v, errRule: D } = t, S = d ? d.default : null, x = d ? d.valid : null, h = i.value, O = l.value, g = xs(w) ? Cn.get(w.name) : null, b = { data: a, disabled: m, readonly: c, field: p, property: p, item: t, $form: e, $grid: e.xegrid };
  let E = [];
  const C = g ? g.renderFormItemContent || g.renderItemContent : null;
  if (S ? E = e.callSlot(S, b) : C ? E = Nt(C(w, b)) : p && (E = [`${r.get(a, p)}`]), v && E.push(o("div", {
    class: "vxe-form--item-trigger-node",
    onClick: e.toggleCollapseEvent
  }, [
    o("span", {
      class: "vxe-form--item-trigger-text"
    }, u ? h.unfoldButtonText || Pe("vxe.form.unfolding") : h.foldButtonText || Pe("vxe.form.folding")),
    o("i", {
      class: ["vxe-form--item-trigger-icon", u ? h.foldIcon || ht().FORM_FOLDING : h.unfoldIcon || ht().FORM_UNFOLDING]
    })
  ])), D && O.showMessage) {
    const V = Object.assign(Object.assign({}, b), { rule: D });
    E.push(o("div", {
      class: "vxe-form-item--valid-error-tip",
      style: D.maxWidth ? {
        width: cn(D.maxWidth)
      } : null
    }, [
      o("div", {
        class: `vxe-form-item--valid-error-wrapper vxe-form-item--valid-error-theme-${O.theme || "normal"}`
      }, [
        x ? e.callSlot(x, V) : [
          o("span", {
            class: "vxe-form--item--valid-error-msg"
          }, D.content || D.message)
        ]
      ])
    ]));
  }
  return o("div", {
    class: "vxe-form--item-inner"
  }, E);
}, AL = pt({
  name: "VxeFormConfigItem",
  props: {
    itemConfig: Object
  },
  setup(e) {
    const t = mt("$xeForm", {}), n = { itemConfig: e.itemConfig };
    bn("xeFormItemInfo", n);
    const s = (a, c) => {
      const m = a.props, { data: u, readonly: d, disabled: p } = m, { visible: w, field: v, itemRender: D, contentStyle: S, children: x, showContent: h } = c, O = xs(D) ? Cn.get(D.name) : null, g = O ? O.formItemStyle || O.itemStyle : null, b = O ? O.formItemContentStyle || O.itemContentStyle : null, E = { data: u, disabled: p, readonly: d, field: v, property: v, item: c, $form: a, $grid: a.xegrid }, C = x && x.length > 0;
      return w === !1 ? Ve() : o("div", {
        key: c.id,
        class: Td(a, c),
        style: r.isFunction(g) ? g(E) : g
      }, [
        Id(a, c),
        h === !1 ? Ve() : o("div", {
          class: Md(a, c),
          style: Object.assign({}, r.isFunction(b) ? b(E) : b, r.isFunction(S) ? S(E) : S)
        }, C ? x.map((V) => s(a, V)) : [
          Tv(a, c)
        ])
      ]);
    }, l = {
      renderVN: () => s(t, e.itemConfig)
    };
    return bn("$xeFormGroup", null), l;
  },
  render() {
    return this.renderVN();
  }
});
class xi {
  constructor(t) {
    Object.assign(this, {
      $options: t,
      required: t.required,
      min: t.min,
      max: t.min,
      type: t.type,
      pattern: t.pattern,
      validator: t.validator,
      trigger: t.trigger,
      maxWidth: t.maxWidth
    });
  }
  get content() {
    return Bn(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
const im = (e, t) => {
  const { type: n, min: s, max: i, pattern: l } = e, a = n === "number", c = a ? r.toNumber(t) : r.getSize(t);
  return !!(a && isNaN(t) || !r.eqNull(s) && c < r.toNumber(s) || !r.eqNull(i) && c > r.toNumber(i) || l && !(r.isRegExp(l) ? l : new RegExp(l)).test(t));
}, Nn = pt({
  name: "VxeForm",
  props: {
    collapseStatus: {
      type: Boolean,
      default: !0
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => oe().form.size || oe().size
    },
    span: {
      type: [String, Number],
      default: () => oe().form.span
    },
    align: {
      type: String,
      default: () => oe().form.align
    },
    verticalAlign: {
      type: String,
      default: () => oe().form.verticalAlign
    },
    border: {
      type: Boolean,
      default: () => oe().form.border
    },
    titleBackground: {
      type: Boolean,
      default: () => oe().form.titleBackground
    },
    titleBold: {
      type: Boolean,
      default: () => oe().form.titleBold
    },
    titleAlign: {
      type: String,
      default: () => oe().form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => oe().form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => oe().form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => oe().form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: () => oe().form.titleOverflow
    },
    vertical: {
      type: Boolean,
      default: () => oe().form.vertical
    },
    padding: {
      type: Boolean,
      default: () => oe().form.padding
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => oe().form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    collapseConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => oe().form.customLayout
    }
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = Rt({
      collapseAll: e.collapseStatus,
      staticItems: [],
      formItems: []
    }), c = Rt({
      meTimeout: void 0,
      stTimeout: void 0,
      tooltipStore: {
        item: null,
        visible: !1
      }
    });
    bn("xeFormItemInfo", null);
    const m = mt("$xeGrid", null), u = ke(), d = ke();
    let p = {};
    const w = _(() => Object.assign({}, oe().form.validConfig, e.validConfig)), v = _(() => Object.assign({}, oe().tooltip, oe().form.tooltipConfig, e.tooltipConfig)), D = _(() => Object.assign({}, oe().form.collapseConfig, e.collapseConfig)), S = {
      refElem: u
    }, x = {
      computeSize: l,
      computeValidOpts: w,
      computeTooltipOpts: v,
      computeCollapseOpts: D
    }, h = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      xegrid: m,
      getRefMaps: () => S,
      getComputeMaps: () => x
    }, O = ($, J) => $ && (r.isString($) && ($ = n[$] || null), r.isFunction($)) ? Nt($(J)) : [], g = ($) => ($.length && process.env.NODE_ENV === "development" && $.forEach((J) => {
      J.slots && r.each(J.slots, (ge) => {
        r.isFunction(ge) || n[ge] || Ao("vxe.error.notSlot", [ge]);
      });
    }), a.staticItems = r.mapTree($, (J) => Od(h, J), { children: "children" }), me()), b = () => {
      const $ = [];
      return r.eachTree(a.formItems, (J) => {
        $.push(J);
      }, { children: "children" }), $;
    }, E = ($) => {
      const J = r.findTree(a.formItems, (ge) => ge.field === $, { children: "children" });
      return J ? J.item : null;
    }, C = () => a.collapseAll, V = () => {
      const $ = !C();
      return a.collapseAll = $, s("update:collapseStatus", $), me();
    }, Q = ($) => {
      V();
      const J = C();
      p.dispatchEvent("toggle-collapse", { status: J, collapse: J, data: e.data }, $), p.dispatchEvent("collapse", { status: J, collapse: J, data: e.data }, $);
    }, Z = ($) => {
      if ($) {
        let J = $;
        r.isArray($) || (J = [$]), J.forEach((ge) => {
          if (ge) {
            const Oe = sm(h, ge);
            Oe && (Oe.showError = !1);
          }
        });
      } else
        b().forEach((J) => {
          J.showError = !1;
        });
      return me();
    }, G = ($, J) => {
      const { field: ge, resetValue: Oe } = $, Se = r.get(J, ge);
      if (r.isFunction(Oe))
        return Oe({ field: ge, item: $, data: J, $form: h, $grid: h.xegrid });
      if (Oe === null && r.isArray(Se))
        return [];
    }, ue = () => {
      const { data: $ } = e, J = b();
      return $ && J.forEach((ge) => {
        const { field: Oe, itemRender: Se } = ge;
        if (xs(Se)) {
          const de = Cn.get(Se.name), Ie = de ? de.formItemResetMethod || de.itemResetMethod : null;
          de && Ie ? Ie({ data: $, field: Oe, property: Oe, item: ge, $form: h, $grid: h.xegrid }) : Oe && r.set($, Oe, G(ge, $));
        }
      }), Z();
    }, Y = ($) => {
      $.preventDefault(), ue(), p.dispatchEvent("reset", { data: e.data }, $);
    }, K = ($) => {
      const J = u.value;
      if (J)
        for (let ge = 0; ge < $.length; ge++) {
          const Oe = $[ge], Se = E(Oe);
          if (Se && xs(Se.itemRender)) {
            const { itemRender: de } = Se, Ie = Cn.get(de.name);
            ge || rL(J.querySelector(`.${Se.id}`));
            let je = null;
            const Ue = de.autoFocus || de.autofocus || (Ie ? Ie.formItemAutoFocus : null);
            if (r.isFunction(Ue) ? je = Ue({ $form: h, $grid: m, item: Se, data: e.data, field: Oe }) : Ue === !0 ? je = J.querySelector(`.${Se.id} input,textarea`) : Ue && (je = J.querySelector(`.${Se.id} ${Ue}`)), je) {
              je.focus();
              break;
            }
          }
        }
    }, L = ($, J, ge) => {
      const { data: Oe, rules: Se } = e, de = {};
      return r.isArray(J) || (J = [J]), Promise.all(J.map((Ie) => {
        const je = [], Ue = [];
        if (Ie && Se) {
          const Ae = r.get(Se, Ie);
          if (Ae) {
            const _e = r.isUndefined(ge) ? r.get(Oe, Ie) : ge;
            Ae.forEach((it) => {
              const { type: vt, trigger: dt, required: at, validator: Et } = it;
              if ($ === "all" || !dt || $ === dt)
                if (Et) {
                  const Qe = {
                    itemValue: _e,
                    rule: it,
                    rules: Ae,
                    data: Oe,
                    field: Ie,
                    property: Ie,
                    $form: h
                  };
                  let De;
                  if (r.isString(Et)) {
                    const Re = wd.get(Et);
                    if (Re) {
                      const Be = Re.formItemValidatorMethod || Re.itemValidatorMethod;
                      Be ? De = Be(Qe) : process.env.NODE_ENV === "development" && Ar("vxe.error.notValidators", [Et]);
                    } else
                      process.env.NODE_ENV === "development" && Ao("vxe.error.notValidators", [Et]);
                  } else
                    De = Et(Qe);
                  De && (r.isError(De) ? je.push(new xi({ type: "custom", trigger: dt, content: De.message, rule: new xi(it) })) : De.catch && Ue.push(De.catch((Re) => {
                    je.push(new xi({ type: "custom", trigger: dt, content: Re ? Re.message : it.content || it.message, rule: new xi(it) }));
                  })));
                } else {
                  const Qe = vt === "array", De = r.isArray(_e);
                  let Re = !0;
                  Qe || De ? Re = !De || !_e.length : r.isString(_e) ? Re = Ei(_e.trim()) : Re = Ei(_e), (at ? Re || im(it, _e) : !Re && im(it, _e)) && je.push(new xi(it));
                }
            });
          }
        }
        return Promise.all(Ue).then(() => {
          je.length && (de[Ie] = je.map((Ae) => ({
            $form: h,
            rule: Ae,
            data: Oe,
            field: Ie,
            property: Ie
          })));
        });
      })).then(() => {
        if (!r.isEmpty(de))
          return Promise.reject(de);
      });
    }, ye = ($, J, ge) => {
      const { data: Oe, rules: Se } = e, de = w.value, Ie = {}, je = [], Ue = [];
      return clearTimeout(c.meTimeout), Oe && Se ? ($.forEach((Ae) => {
        const { field: _e } = Ae;
        _e && !LL(h, Ae) && Ev(h, Ae) && Ue.push(L(J || "all", _e).then(() => {
          Ae.errRule = null;
        }).catch((it) => {
          const vt = it[_e];
          return Ie[_e] || (Ie[_e] = []), Ie[_e].push(vt), je.push(_e), Ae.errRule = vt[0].rule, Promise.reject(vt);
        }));
      }), Promise.all(Ue).then(() => {
        ge && ge();
      }).catch(() => new Promise((Ae) => {
        c.meTimeout = window.setTimeout(() => {
          $.forEach((_e) => {
            _e.errRule && (_e.showError = !0);
          });
        }, 20), de.autoPos !== !1 && me(() => {
          K(je);
        }), ge ? (ge(Ie), Ae()) : Ae(Ie);
      }))) : (ge && ge(), Promise.resolve());
    }, se = ($) => {
      const { readonly: J } = e;
      return Z(), J ? me() : ye(b(), "", $);
    }, P = ($, J) => {
      const { readonly: ge } = e;
      if (ge)
        return me();
      let Oe = [];
      return $ && (r.isArray($) ? Oe = $ : Oe = [$]), ye(Oe.map((Se) => sm(h, Se)), "", J);
    }, M = ($) => {
      const { readonly: J } = e;
      if ($.preventDefault(), !e.preventSubmit) {
        if (Z(), J) {
          p.dispatchEvent("submit", { data: e.data }, $);
          return;
        }
        ye(b()).then((ge) => {
          ge ? p.dispatchEvent("submit-invalid", { data: e.data, errMap: ge }, $) : p.dispatchEvent("submit", { data: e.data }, $);
        });
      }
    }, I = () => {
      const { tooltipStore: $ } = c, J = d.value;
      return $.visible && (Object.assign($, {
        item: null,
        visible: !1
      }), J && J.close()), me();
    }, B = ($, J) => {
      const { item: ge } = J, { tooltipStore: Oe } = c, Se = d.value, de = $.currentTarget.children[0], Ie = (de.textContent || "").trim(), je = de.scrollWidth > de.clientWidth;
      clearTimeout(c.stTimeout), Oe.item !== ge && I(), Ie && je && (Object.assign(Oe, {
        item: ge,
        visible: !0
      }), Se && Se.open(de, Ie));
    }, H = () => {
      const $ = v.value;
      let J = d.value;
      J && J.setActived(!1), $.enterable ? c.stTimeout = setTimeout(() => {
        J = d.value, J && !J.isActived() && I();
      }, $.leaveDelay) : I();
    }, ce = ($, J, ge) => J ? L($ ? ["blur"].includes($.type) ? "blur" : "change" : "all", J, ge).then(() => {
      Z(J);
    }).catch((Oe) => {
      const Se = Oe[J], de = E(J);
      Se && de && (de.showError = !0, de.errRule = Se[0].rule);
    }) : me();
    p = {
      dispatchEvent($, J, ge) {
        s($, Zt(ge, { $form: h, $grid: m }, J));
      },
      reset: ue,
      validate: se,
      validateField: P,
      clearValidate: Z,
      updateStatus: ($, J) => {
        const { field: ge } = $;
        return ce(new Event("change"), ge, J);
      },
      toggleCollapse: V,
      getItems: b,
      getItemByField: E,
      closeTooltip: I
    }, Object.assign(h, p, {
      callSlot: O,
      triggerItemEvent: ce,
      toggleCollapseEvent: Q,
      triggerTitleTipEvent: B,
      handleTitleTipLeaveEvent: H
    });
    const fe = () => {
      const { loading: $, border: J, className: ge, data: Oe, customLayout: Se } = e, { formItems: de } = a, Ie = l.value, je = v.value, Ue = n.default;
      return o("form", {
        ref: u,
        class: ["vxe-form", ge ? r.isFunction(ge) ? ge({ items: de, data: Oe, $form: h }) : ge : "", {
          [`size--${Ie}`]: Ie,
          "is--border": J,
          "custom--layout": Se,
          "is--loading": $
        }],
        onSubmit: M,
        onReset: Y
      }, [
        o("div", {
          class: "vxe-form--wrapper vxe-form--item-row"
        }, Se ? Ue ? Ue({}) : [] : de.map((Ae, _e) => o(AL, {
          key: _e,
          itemConfig: Ae
        }))),
        o("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, Se ? [] : Ue ? Ue({}) : []),
        /**
         * 加载中
         */
        o(us, {
          class: "vxe-form--loading",
          modelValue: $
        }),
        /**
         * 工具提示
         */
        o(Rr, Object.assign({ ref: d }, je))
      ]);
    }, pe = ke(0);
    lt(() => a.staticItems.length, () => {
      pe.value++;
    }), lt(() => a.staticItems, () => {
      pe.value++;
    }), lt(pe, () => {
      a.formItems = a.staticItems;
    });
    const ne = ke(0);
    return lt(() => e.items ? e.items.length : -1, () => {
      ne.value++;
    }), lt(() => e.items, () => {
      ne.value++;
    }), lt(ne, () => {
      g(e.items || []);
    }), lt(() => e.collapseStatus, ($) => {
      a.collapseAll = !!$;
    }), lt(() => e.readonly, () => {
      Z();
    }), lt(() => e.disabled, () => {
      Z();
    }), wn(() => {
      me(() => {
        process.env.NODE_ENV === "development" && e.customLayout && e.items && Ao("vxe.error.errConflicts", ["custom-layout", "items"]);
      });
    }), e.items && g(e.items), bn("$xeForm", h), bn("$xeFormGroup", null), bn("$xeFormItem", null), h.renderVN = fe, h;
  },
  render() {
    return this.renderVN();
  }
}), BL = "modelValue";
function Mv(e) {
  return `vxe-${e.replace("$", "")}`;
}
function ur({ name: e }) {
  return qo(e);
}
function Iv({ name: e }) {
  return qo(Mv(e));
}
function Vv(e) {
  let { name: t, attrs: n } = e;
  return t === "input" && (n = Object.assign({ type: "text" }, n)), n;
}
function hs(e, t, n, s) {
  return r.assign({}, s, e.props, { [BL]: n });
}
function _L(e, t, n, s) {
  const { events: i } = e, l = pv(e.name), a = mv(e.name), c = a === l, m = {};
  return i && r.objectEach(i, (u, d) => {
    m[Ll(d)] = function(...p) {
      u(t, ...p);
    };
  }), n && (m[Ll(l)] = function(u) {
    n(u), c && s && s(u), i && i[l] && i[l](t, u);
  }), !c && s && (m[Ll(a)] = function(...u) {
    s(...u), i && i[a] && i[a](t, ...u);
  }), m;
}
function Pv(e, t, n, s) {
  const { events: i } = e, l = pv(e.name), a = mv(e.name), c = {};
  return r.objectEach(i, (m, u) => {
    c[Ll(u)] = function(...d) {
      process.env.NODE_ENV === "development" && (r.isFunction(m) || Ao("vxe.error.errFunc", [m])), m(t, ...d);
    };
  }), n && (c[Ll(l)] = function(m) {
    n(m), i && i[l] && i[l](t, m);
  }), s && (c[Ll(a)] = function(...m) {
    s(...m), i && i[a] && i[a](t, ...m);
  }), c;
}
function as(e, t) {
  const { $form: n, data: s, field: i } = t;
  return Pv(e, t, (l) => {
    r.set(s, i, l);
  }, () => {
    n.updateStatus(t);
  });
}
function kv(e, t) {
  const { $form: n, data: s, field: i } = t;
  return _L(e, t, (l) => {
    const a = l.target.value;
    r.set(s, i, a);
  }, () => {
    n.updateStatus(t);
  });
}
function WL(e, t, n) {
  const { optionGroups: s, optionGroupProps: i = {} } = e, l = i.options || "options", a = i.label || "label";
  return s.map((c, m) => o("optgroup", {
    key: m,
    label: c[a]
  }, n(c[l], e, t)));
}
function am(e, t) {
  const { data: n, field: s } = t, { name: i } = e, l = Vv(e), a = r.get(n, s);
  return [
    o(i, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${i}` }, l), { value: l && i === "input" && (l.type === "submit" || l.type === "reset") ? null : a }), kv(e, t)))
  ];
}
function sr(e, t) {
  const { data: n, field: s } = t, i = r.get(n, s);
  return [
    o(ur(e), Object.assign(Object.assign({}, hs(e, t, i)), as(e, t)))
  ];
}
function _u(e, t) {
  const { data: n, field: s } = t, i = r.get(n, s);
  return [
    o(Iv(e), Object.assign(Object.assign({}, hs(e, t, i)), as(e, t)))
  ];
}
function $v(e, t) {
  return [
    o(qo("vxe-button"), Object.assign(Object.assign({}, hs(e, t, null)), Pv(e, t)))
  ];
}
function zL(e, t) {
  return e.children.map((n) => $v(n, t)[0]);
}
function cm(e, t, n) {
  const { data: s, field: i } = n, { optionProps: l = {} } = t, a = l.label || "label", c = l.value || "value", m = l.disabled || "disabled", u = r.get(s, i);
  return e.map((d, p) => o("option", {
    key: p,
    value: d[c],
    disabled: d[m],
    /* eslint-disable eqeqeq */
    selected: d[c] == u
  }, d[a]));
}
function Oa(e, t) {
  const { data: n, field: s } = t, i = r.get(n, s);
  return [
    o(ur(e), Object.assign(Object.assign({}, hs(e, t, i)), as(e, t)))
  ];
}
function um(e, t) {
  const { options: n, optionProps: s } = e, { data: i, field: l } = t, a = r.get(i, l);
  return [
    o(ur(e), Object.assign(Object.assign({
      options: n,
      optionProps: s
    }, hs(e, t, a)), as(e, t)))
  ];
}
function dm(e, t) {
  const { name: n, options: s, optionProps: i = {} } = e, { data: l, field: a } = t, c = i.label || "label", m = i.value || "value", u = i.disabled || "disabled", d = r.get(l, a), p = Mv(n);
  return s ? [
    o(qo(`${p}-group`), Object.assign(Object.assign({}, hs(e, t, d)), as(e, t)), {
      default: () => s.map((w, v) => o(qo(p), {
        key: v,
        label: w[m],
        content: w[c],
        disabled: w[u]
      }))
    })
  ] : [
    o(qo(p), Object.assign(Object.assign({}, hs(e, t, d)), as(e, t)))
  ];
}
Cn.mixin({
  input: {
    formItemAutoFocus: "input",
    renderFormItemContent: am
  },
  textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: am
  },
  select: {
    formItemAutoFocus: "input",
    renderFormItemContent(e, t) {
      return [
        o("select", Object.assign(Object.assign({ class: "vxe-default-select" }, Vv(e)), kv(e, t)), e.optionGroups ? WL(e, t, cm) : cm(e.options, e, t))
      ];
    }
  },
  VxeInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: sr
  },
  VxeNumberInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: sr
  },
  VxePasswordInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: sr
  },
  VxeTextarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: sr
  },
  VxeDatePicker: {
    formItemAutoFocus: "input",
    renderFormItemContent: sr
  },
  VxeButton: {
    renderFormItemContent: Oa
  },
  VxeButtonGroup: {
    renderFormItemContent(e, t) {
      const { options: n } = e, { data: s, field: i } = t, l = r.get(s, i);
      return [
        o(ur(e), Object.assign(Object.assign({ options: n }, hs(e, t, l)), as(e, t)))
      ];
    }
  },
  VxeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(e, t) {
      const { data: n, field: s } = t, { options: i, optionProps: l, optionGroups: a, optionGroupProps: c } = e, m = r.get(n, s);
      return [
        o(ur(e), Object.assign(Object.assign({}, hs(e, t, m, { options: i, optionProps: l, optionGroups: a, optionGroupProps: c })), as(e, t)))
      ];
    }
  },
  VxeTreeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(e, t) {
      const { data: n, field: s } = t, { options: i, optionProps: l } = e, a = r.get(n, s);
      return [
        o(ur(e), Object.assign(Object.assign({}, hs(e, t, a, { options: i, optionProps: l })), as(e, t)))
      ];
    }
  },
  VxeTableSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(e, t) {
      const { data: n, field: s } = t, { options: i, optionProps: l } = e, a = r.get(n, s);
      return [
        o(ur(e), Object.assign(Object.assign({}, hs(e, t, a, { options: i, optionProps: l })), as(e, t)))
      ];
    }
  },
  VxeIconPicker: {
    renderFormItemContent: Oa
  },
  VxeRadio: {
    renderFormItemContent: Oa
  },
  VxeRadioGroup: {
    renderFormItemContent: um
  },
  VxeCheckbox: {
    renderFormItemContent: Oa
  },
  VxeCheckboxGroup: {
    renderFormItemContent: um
  },
  VxeSwitch: {
    renderFormItemContent: sr
  },
  VxeRate: {
    renderFormItemContent: sr
  },
  VxeSlider: {
    renderFormItemContent: sr
  },
  VxeImage: {
    renderFormItemContent(e, t) {
      const { data: n, field: s } = t, { props: i } = e, l = r.get(n, s);
      return [
        o(ur(e), Object.assign(Object.assign(Object.assign({}, i), { src: l }), as(e, t)))
      ];
    }
  },
  VxeImageGroup: {
    renderFormItemContent(e, t) {
      const { data: n, field: s } = t, { props: i } = e, l = r.get(n, s);
      return [
        o(ur(e), Object.assign(Object.assign(Object.assign({}, i), { urlList: l }), as(e, t)))
      ];
    }
  },
  VxeUpload: {
    renderFormItemContent: sr
  },
  // 以下已废弃
  $input: {
    formItemAutoFocus: "input",
    renderFormItemContent: _u
  },
  $textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: _u
  },
  $button: {
    renderFormItemContent: $v
  },
  $buttons: {
    renderFormItemContent: zL
  },
  $select: {
    formItemAutoFocus: "input",
    renderFormItemContent(e, t) {
      const { data: n, field: s } = t, { options: i, optionProps: l, optionGroups: a, optionGroupProps: c } = e, m = r.get(n, s);
      return [
        o(Iv(e), Object.assign(Object.assign({}, hs(e, t, m, { options: i, optionProps: l, optionGroups: a, optionGroupProps: c })), as(e, t)))
      ];
    }
  },
  $radio: {
    renderFormItemContent: dm
  },
  $checkbox: {
    renderFormItemContent: dm
  },
  $switch: {
    renderFormItemContent: _u
  }
  // 以上已废弃
});
const Rv = Object.assign(Nn, {
  install(e) {
    e.component(Nn.name, Nn);
  }
});
Ht.use(Rv);
Ce.component(Nn);
let Wu = 1e5;
function HL(e) {
  return r.eachTree(e, (t) => {
    t && (Wu = Math.max(Wu, t.id));
  }, { children: "children" }), ++Wu;
}
const rl = (e) => e ? Ul(e.name).group === "layout" : !1, od = ke({}), Ul = (e) => od.value[e] || {};
function jL(e, t) {
  const n = Ul(e);
  if (n) {
    const s = n.title, i = { name: e, $formDesign: t };
    return r.toValueString(r.isFunction(s) ? s(i) : s);
  }
  return e;
}
function qL(e, t) {
  const n = Ul(e);
  if (n) {
    const s = n.customGroup, i = { name: e, $formDesign: t };
    return r.toValueString(r.isFunction(s) ? s(i) : s);
  }
  return e;
}
const UL = (e, t) => !r.findTree(t, (n) => n.field === e, { children: "children" });
class sd {
  constructor(t, n, s) {
    Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "field", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "title", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "required", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "hidden", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "children", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        update: !1,
        value: ""
      }
    });
    let i = "";
    if (n) {
      const a = Cn.get(n) || {};
      if (a) {
        const c = od.value, m = a.createFormDesignWidgetConfig;
        if (m) {
          const u = { name: n, $formDesign: t }, d = m(u) || {}, p = d.title, w = d.field;
          this.title = r.toValueString(r.isFunction(p) ? p(u) : p), this.options = d.options || {}, this.children = d.children || [], w && (r.isFunction(w) ? i = w({ name: n, $formDesign: t }) : i = w), c[n] || (c[n] = Object.assign({}, d), od.value = Object.assign({}, c));
        }
      }
    }
    const l = HL(s);
    i && (UL(i, s) || Ao("vxe.error.uniField", [i])), this.id = l, this.field = i || `${n}${l}`, this.name = n;
  }
}
function Vd(e) {
  const t = new sd(null, e.name, []);
  return t.id = e.id, t.title = e.title || "", t.field = e.field || "", t.required = e.required || !1, t.hidden = e.hidden || !1, t.options = Object.assign({}, t.options, e.options), t.children = e.children ? e.children.map((n) => Vd(n)) : [], t;
}
const GL = pt({
  props: {},
  emits: [],
  setup() {
    const e = mt("$xeFormDesign", null);
    if (!e)
      return () => [];
    const { reactData: t } = e, n = (m) => {
      const u = m.currentTarget, d = m.dataTransfer, p = u.getAttribute("data-widget-name") || "";
      if (e.validWidgetUnique(p)) {
        const w = e.createWidget(p);
        d && d.setData("text/plain", p), t.sortWidget = null, t.dragWidget = w;
      } else
        m.preventDefault();
    }, s = (m) => {
      if (m.preventDefault(), t.dragWidget) {
        const u = t.dragWidget;
        t.activeWidget = u, e.dispatchEvent("add-widget", { newWidget: u }, m);
      }
      t.dragWidget = null, t.sortWidget = null;
    }, i = (m, u) => {
      const { widgetObjList: d, dragWidget: p } = t;
      if (p && u.children.some((w) => w.name === p.name)) {
        const w = r.findTree(d, (v) => v && v.id === p.id, { children: "children" });
        w && w.items.splice(w.index, 1);
      }
    }, l = (m, u) => {
      if (e.validWidgetUnique(u)) {
        const { widgetObjList: d } = t, p = e.createWidget(u);
        d.push(p), t.activeWidget = p, t.sortWidget = null, t.dragWidget = null, e.dispatchEvent("add-widget", { newWidget: p }, m);
      }
    }, a = (m) => {
      const u = [];
      return m.children && m.children.forEach((d, p) => {
        const { name: w } = d, v = jL(w, e), D = Cn.get(w) || {}, S = Ul(w), x = D.renderFormDesignWidgetItem;
        u.push(o("div", {
          key: p,
          class: "vxe-form-design--widget-item"
        }, o("div", {
          class: "vxe-form-design--widget-box",
          "data-widget-name": w,
          title: v,
          draggable: !0,
          onDragstart: n,
          onDragend: s
        }, x ? Nt(x({}, { $formDesign: e })) : [
          o("i", {
            class: ["vxe-form-design--widget-item-icon", S && S.icon || ""]
          }),
          o("span", {
            class: "vxe-form-design--widget-item-name"
          }, v),
          o("span", {
            class: "vxe-form-design--widget-item-add",
            onClick(h) {
              l(h, w);
            }
          }, [
            o("i", {
              class: ht().FORM_DESIGN_WIDGET_ADD
            })
          ])
        ])));
      }), u;
    }, c = () => {
      const { widgetConfigs: m } = t;
      return m.map((u, d) => {
        const { title: p, group: w } = u;
        return o("div", {
          key: d,
          class: "vxe-form-design--widget-group"
        }, [
          o("div", {
            class: "vxe-form-design--widget-title"
          }, w ? Pe(`vxe.formDesign.widget.group.${w}`) : `${p || ""}`),
          o("div", {
            class: "vxe-form-design--widget-list",
            onDragover(v) {
              i(v, u);
            }
          }, a(u))
        ]);
      });
    };
    return () => o("div", {
      class: "vxe-form-design--widget"
    }, c());
  }
}), KL = pt({
  name: "FormDesignLayoutViewItem",
  props: {
    item: {
      type: Object,
      default: () => ({})
    },
    itemIndex: {
      type: Number,
      default: 0
    },
    items: {
      type: Array,
      default: () => []
    }
  },
  emits: [],
  setup(e, { slots: t }) {
    const n = mt("$xeFormDesign", null);
    if (!n)
      return () => [];
    const { reactData: s } = n, i = (m) => {
      const { widgetObjList: u } = s, d = m.currentTarget, p = Number(d.getAttribute("data-widget-id")), w = r.findTree(u, (v) => v && v.id === p, { children: "children" });
      w && (s.dragWidget = null, s.sortWidget = w.item);
    }, l = () => {
      s.activeWidget = s.sortWidget, s.sortWidget = null;
    }, a = (m) => {
      const { widgetObjList: u, sortWidget: d } = s, p = n.internalData, { lastDragTime: w } = p;
      if (w && w > Date.now() - 300) {
        m.preventDefault();
        return;
      }
      if (d) {
        const v = m.currentTarget;
        m.preventDefault();
        const D = Number(v.getAttribute("data-widget-id"));
        if (D !== d.id) {
          const S = r.findTree(u, (x) => x && x.id === D, { children: "children" });
          if (S) {
            const x = r.findTree(u, (h) => h && h.id === d.id, { children: "children" });
            x && (x.parent && x.parent.name === "row" ? x.items[x.index] = n.createEmptyWidget() : x.items.splice(x.index, 1), S.items.splice(S.index, 0, x.item), p.lastDragTime = Date.now(), n.dispatchEvent("drag-widget", { widget: x.item }, m));
          }
        }
      }
    }, c = (m, u) => {
      n.handleClickWidget(m, u);
    };
    return () => {
      const { dragWidget: m, activeWidget: u, sortWidget: d } = s, { item: p } = e, { name: w } = p, v = u && u.id === p.id, D = t.default;
      return o("div", {
        key: p.id,
        "data-widget-id": p.id,
        draggable: !0,
        class: ["vxe-form-design--preview-item", `widget-${r.kebabCase(w)}`, {
          "is--active": v,
          "is--sort": d && d.id === p.id,
          "is--drag": m && m.id === p.id
        }],
        onDragstart: i,
        onDragend: l,
        onDragenter: a,
        // onDragover: dragoverItemEvent,
        onClick(S) {
          c(S, p);
        }
      }, [
        o("div", {
          class: "vxe-form-design--preview-item-view vxe-form--item-row"
        }, D ? D({}) : []),
        v ? o("div", {
          class: "vxe-form-design--preview-item-operate"
        }, [
          o(Vn, {
            icon: ht().FORM_DESIGN_WIDGET_COPY,
            status: "primary",
            size: "mini",
            circle: !0,
            onClick(S) {
              n.handleCopyWidget(S.$event, p);
            }
          }),
          o(Vn, {
            icon: ht().FORM_DESIGN_WIDGET_DELETE,
            status: "danger",
            size: "mini",
            circle: !0,
            onClick(S) {
              n.handleRemoveWidget(S.$event, p);
            }
          })
        ]) : Ve()
      ]);
    };
  }
}), YL = pt({
  name: "FormDesignLayoutPreview",
  props: {},
  emits: [],
  setup() {
    const e = mt("$xeFormDesign", null);
    if (!e)
      return () => [];
    const { reactData: t } = e, n = (c) => {
      const { widgetObjList: m, dragWidget: u } = t;
      u && (c.preventDefault(), r.findTree(m, (p) => p && p.id === u.id, { children: "children" }) || (t.sortWidget = u, m.push(u), e.dispatchEvent("drag-widget", { widget: u }, c)));
    }, s = (c) => {
      c.preventDefault();
    };
    let i = Date.now();
    const l = (c) => {
      const { widgetObjList: m, sortWidget: u } = t;
      if (c.stopPropagation(), i > Date.now() - 300) {
        c.preventDefault();
        return;
      }
      if (u) {
        if (rl(u))
          return;
        const d = r.findTree(m, (p) => p.id === u.id, { children: "children" });
        if (d) {
          const { item: p, index: w, items: v, parent: D } = d;
          D && D.name === "row" ? d.items[d.index] = e.createEmptyWidget() : v.splice(w, 1), m.unshift(p), i = Date.now(), e.dispatchEvent("drag-widget", { widget: p }, c);
        }
      }
    }, a = (c) => {
      const { widgetObjList: m, sortWidget: u } = t;
      if (c.stopPropagation(), i > Date.now() - 300) {
        c.preventDefault();
        return;
      }
      if (u) {
        if (rl(u))
          return;
        const d = r.findTree(m, (p) => p.id === u.id, { children: "children" });
        if (d) {
          const { item: p, index: w, items: v, parent: D } = d;
          D && D.name === "row" ? d.items[d.index] = e.createEmptyWidget() : v.splice(w, 1), m.push(p), i = Date.now(), e.dispatchEvent("drag-widget", { widget: p }, c);
        }
      }
    };
    return () => {
      const { widgetObjList: c } = t;
      return o("div", {
        class: "vxe-form-design--preview",
        onDragenter: n,
        onDragover: s
      }, [
        o("div", {
          class: "vxe-form-design--preview-wrapper"
        }, [
          o("div", {
            class: "vxe-form-design--preview-place-widget",
            onDragenter: l
          }),
          o(Nn, {
            customLayout: !0,
            span: 24,
            vertical: !0
          }, {
            default() {
              return o(Fr, {
                class: "vxe-form-design--preview-list",
                tag: "div",
                name: "vxe-form-design--preview-list"
              }, {
                default: () => c.map((m, u) => o(KL, {
                  key: m.id,
                  item: m,
                  itemIndex: u,
                  items: c
                }, {
                  default() {
                    const { name: d } = m, p = Cn.get(d) || {}, w = p.renderFormDesignWidgetEdit || p.renderFormDesignWidgetView, v = m, D = !0;
                    return w ? Nt(w(v, { widget: m, readonly: !1, disabled: !1, isEditMode: D, isViewMode: !D, $formDesign: e, $formView: null })) : [];
                  }
                }))
              });
            }
          }),
          o("div", {
            class: "vxe-form-design--preview-place-widget",
            onDragenter: a
          })
        ])
      ]);
    };
  }
}), ol = pt({
  name: "VxeTabs",
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    height: [String, Number],
    destroyOnClose: Boolean,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: String,
    showClose: Boolean,
    padding: {
      type: Boolean,
      default: () => oe().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    closeConfig: Object,
    refreshConfig: Object,
    // 已废弃
    beforeCloseMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "tab-change",
    "tab-change-fail",
    "tab-close",
    "tab-close-fail",
    "tab-click",
    "tab-load"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = mt("$xeTabs", null), a = ke(), c = ke(), m = Rt({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintWidth: 0,
      isTabOver: !1,
      resizeFlag: 1,
      cacheTabMaps: {}
    }), u = {
      slTimeout: void 0
    }, d = {
      refElem: a
    }, p = _(() => Object.assign({}, oe().tabs.closeConfig, e.closeConfig)), w = _(() => Object.assign({}, oe().tabs.refreshConfig, e.refreshConfig)), v = _(() => {
      const { options: j } = e;
      return (j || []).filter((fe) => h(fe));
    }), D = _(() => {
      const { staticTabs: j } = m;
      return j.filter((fe) => h(fe));
    }), S = {}, x = {
      xID: i,
      props: e,
      context: t,
      reactData: m,
      getRefMaps: () => d,
      getComputeMaps: () => S
    }, h = (j) => {
      const { permissionCode: fe } = j;
      return !(fe && !Ai.checkVisible(fe));
    }, O = (j, fe) => j && (r.isString(j) && (j = n[j] || null), r.isFunction(j)) ? Nt(j(fe)) : [], g = () => {
      me(() => {
        const { type: j } = e, { activeName: fe } = m, pe = v.value, ne = D.value, $ = c.value;
        let J = 0, ge = 0, Oe = !1;
        if ($) {
          const Se = r.findIndexOf(ne.length ? ne : pe, (Ue) => Ue.name === fe), { children: de, scrollWidth: Ie, clientWidth: je } = $;
          if (Oe = Ie !== je, Se > -1) {
            const Ue = de[Se], Ae = Ue.clientWidth;
            j ? j === "card" ? (J = Ae + 2, ge = Ue.offsetLeft) : j === "border-card" && (J = Ae + 2, ge = Ue.offsetLeft - 1) : (J = Math.max(4, Math.floor(Ae * 0.6)), ge = Ue.offsetLeft + Math.floor((Ae - J) / 2));
          }
        }
        m.lintLeft = ge, m.lintWidth = J, m.isTabOver = Oe;
      });
    }, b = (j, fe, pe) => {
      s(j, Zt(pe, { $tabs: x }, fe));
    }, E = (j, fe) => {
      const { initNames: pe } = m;
      return j && !pe.includes(j) ? (b("tab-load", { name: j }, fe), pe.push(j), !0) : !1;
    }, C = (j) => {
      let fe = null;
      const pe = {};
      if (j && j.length) {
        let ne = !1;
        fe = e.modelValue, j.forEach(($) => {
          const { name: J, preload: ge } = $ || {};
          J && (pe[`${J}`] = {
            loading: !1
          }, fe === J && (ne = !0), ge && E(J, null));
        }), ne || (fe = j[0].name, E(fe, null), s("update:modelValue", fe));
      }
      m.activeName = fe, m.cacheTabMaps = pe;
    }, V = (j, fe) => {
      const { trigger: pe } = e, ne = e.beforeChangeMethod || oe().tabs.beforeChangeMethod, { activeName: $ } = m, { name: J } = fe, ge = J;
      b("tab-click", { name: J }, j), pe !== "manual" && J !== $ && Promise.resolve(!ne || ne({ $tabs: x, name: J, oldName: $, newName: J, option: fe })).then((Oe) => {
        Oe ? (m.activeName = J, s("update:modelValue", ge), E(J, j), b("change", { value: ge, name: J, oldName: $, newName: J, option: fe }, j), b("tab-change", { value: ge, name: J, oldName: $, newName: J, option: fe }, j)) : b("tab-change-fail", { value: ge, name: J, oldName: $, newName: J, option: fe }, j);
      }).catch(() => {
        b("tab-change-fail", { value: ge, name: J, oldName: $, newName: J, option: fe }, j);
      });
    }, Q = (j, fe) => {
      j.stopPropagation();
      const { activeName: pe, cacheTabMaps: ne } = m, { name: $ } = fe, J = w.value, { queryMethod: ge } = J, Oe = $ ? ne[`${$}`] : null;
      Oe && (ge ? (Oe.loading = !0, Promise.resolve(ge({ $tabs: x, value: pe, name: $, option: fe })).finally(() => {
        Oe.loading = !1;
      })) : Ao("vxe.error.notFunc", ["refresh-config.queryMethod"]));
    }, Z = (j, fe, pe, ne) => {
      j.stopPropagation();
      const { activeName: $ } = m, ge = p.value.beforeMethod || e.beforeCloseMethod || oe().tabs.beforeCloseMethod, { name: Oe } = fe, Se = $;
      let de = Se;
      if ($ === Oe) {
        const Ie = pe < ne.length - 1 ? ne[pe + 1] : ne[pe - 1];
        de = Ie ? Ie.name : null;
      }
      Promise.resolve(!ge || ge({ $tabs: x, value: Se, name: Oe, nextName: de, option: fe })).then((Ie) => {
        Ie ? b("tab-close", { value: Se, name: Oe, nextName: de }, j) : b("tab-close-fail", { value: Se, name: Oe, nextName: de }, j);
      }).catch(() => {
        b("tab-close-fail", { value: Se, name: Oe, nextName: de }, j);
      });
    }, G = (j, fe) => {
      const { slTimeout: pe } = u;
      let ne = fe, $ = 6, J = 35;
      pe && (clearTimeout(pe), u.slTimeout = void 0);
      const ge = () => {
        const Oe = c.value;
        if ($ > 0 && ($--, Oe)) {
          const { clientWidth: Se, scrollWidth: de, scrollLeft: Ie } = Oe;
          ne = Math.floor(ne / 2), j > 0 ? Se + Ie < de && (Oe.scrollLeft += ne, J -= 4, u.slTimeout = setTimeout(ge, J)) : Ie > 0 && (Oe.scrollLeft -= ne, J -= 4, u.slTimeout = setTimeout(ge, J)), g();
        }
      };
      ge();
    }, ue = (j) => {
      const fe = c.value;
      if (fe) {
        const pe = Math.floor(fe.clientWidth * 0.75);
        G(j, pe);
      }
    }, Y = () => {
      ue(-1);
    }, K = () => {
      ue(1);
    }, L = (j) => {
      const fe = v.value, pe = D.value;
      return me().then(() => {
        const ne = c.value;
        if (ne) {
          const $ = r.findIndexOf(pe.length ? pe : fe, (J) => J.name === j);
          if ($ > -1) {
            const { scrollLeft: J, clientWidth: ge, children: Oe } = ne, Se = Oe[$];
            if (Se) {
              const de = Se.offsetLeft, Ie = Se.clientWidth, je = de + Ie - (J + ge);
              je > 0 && (ne.scrollLeft += je), de < J && (ne.scrollLeft = de);
            }
          }
          g();
        }
      });
    }, ye = (j) => {
      const { activeName: fe } = m, pe = v.value, ne = D.value, $ = ne.length ? ne : pe, J = r.findIndexOf($, (ge) => ge.name === fe);
      if (J > -1) {
        let ge = null;
        if (j ? J < $.length - 1 && (ge = $[J + 1]) : J > 0 && (ge = $[J - 1]), ge) {
          const Oe = ge.name, Se = Oe;
          m.activeName = Oe, s("update:modelValue", Se), E(Oe, null);
        }
      }
      return me();
    }, se = {
      dispatchEvent: b,
      scrollToTab: L,
      prev() {
        return ye(!1);
      },
      next() {
        return ye(!0);
      },
      prevTab() {
        return process.env.NODE_ENV === "development" && Ar("vxe.error.delFunc", ["prevTab", "prev"]), se.prev();
      },
      nextTab() {
        return process.env.NODE_ENV === "development" && Ar("vxe.error.delFunc", ["nextTab", "next"]), se.next();
      }
    };
    Object.assign(x, se, {});
    const M = (j) => {
      const { type: fe, titleWidth: pe, titleAlign: ne, showClose: $, closeConfig: J, refreshConfig: ge } = e, { activeName: Oe, lintLeft: Se, lintWidth: de, isTabOver: Ie, cacheTabMaps: je } = m, Ue = n.extra, Ae = p.value, _e = Ae.visibleMethod, it = w.value, vt = it.visibleMethod;
      return o("div", {
        class: "vxe-tabs-header"
      }, [
        Ie ? o("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--left-bar",
          onClick: Y
        }, [
          o("span", {
            class: ht().TABS_TAB_BUTTON_LEFT
          })
        ]) : Ve(),
        o("div", {
          class: "vxe-tabs-header--wrapper"
        }, [
          o("div", {
            ref: c,
            class: "vxe-tabs-header--item-wrapper"
          }, j.map((dt, at) => {
            const { title: Et, titleWidth: Qe, titleAlign: De, icon: Re, name: Be, slots: ve } = dt, Ne = ve ? ve.title || ve.tab : null, q = Qe || pe, z = De || ne, R = { $tabs: x, value: Oe, name: Be, option: dt }, le = Oe === Be, F = Be ? je[`${Be}`] : null, re = F ? F.loading : !1;
            return o("div", {
              key: `${Be}`,
              class: ["vxe-tabs-header--item", z ? `align--${z}` : "", {
                "is--active": le
              }],
              style: q ? {
                width: cn(q)
              } : null,
              onClick(N) {
                V(N, dt);
              }
            }, [
              o("div", {
                class: "vxe-tabs-header--item-inner"
              }, [
                o("div", {
                  class: "vxe-tabs-header--item-content"
                }, [
                  Re ? o("span", {
                    class: "vxe-tabs-header--item-icon"
                  }, [
                    o("i", {
                      class: Re
                    })
                  ]) : Ve(),
                  o("span", {
                    class: "vxe-tabs-header--item-name"
                  }, Ne ? O(Ne, { name: Be, title: Et }) : `${Et}`)
                ]),
                (xs(ge) || it.enabled) && (vt ? vt(R) : le) ? o("div", {
                  class: "vxe-tabs-header--refresh-btn",
                  onClick(N) {
                    Q(N, dt);
                  }
                }, [
                  o("i", {
                    class: re ? ht().TABS_TAB_REFRESH_LOADING : ht().TABS_TAB_REFRESH
                  })
                ]) : Ve(),
                ($ || xs(J) || Ae.enabled) && (!_e || _e(R)) ? o("div", {
                  class: "vxe-tabs-header--close-btn",
                  onClick(N) {
                    Z(N, dt, at, j);
                  }
                }, [
                  o("i", {
                    class: ht().TABS_TAB_CLOSE
                  })
                ]) : Ve()
              ])
            ]);
          }).concat([
            o("span", {
              key: "line",
              class: `vxe-tabs-header--active-line type--${fe || "default"}`,
              style: {
                left: `${Se}px`,
                width: `${de}px`
              }
            })
          ]))
        ]),
        Ie ? o("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--right-bar",
          onClick: K
        }, [
          o("span", {
            class: ht().TABS_TAB_BUTTON_RIGHT
          })
        ]) : Ve(),
        Ue ? o("div", {
          class: "vxe-tabs-header--extra"
        }, Nt(Ue({}))) : Ve()
      ]);
    }, I = (j) => {
      const { initNames: fe, activeName: pe } = m, { name: ne, slots: $ } = j, J = $ ? $.default : null;
      return ne && fe.includes(ne) ? o("div", {
        key: `${ne}`,
        class: ["vxe-tabs-pane--item", {
          "is--visible": pe === ne,
          "has--content": !!J
        }]
      }, J ? O(J, { name: ne }) : []) : Ve();
    }, B = (j) => {
      const { destroyOnClose: fe } = e, { activeName: pe } = m, ne = j.find(($) => $.name === pe);
      return fe ? [ne ? I(ne) : Ve()] : j.map(($) => I($));
    }, H = () => {
      const { type: j, height: fe, padding: pe, trigger: ne } = e, $ = v.value, J = D.value, ge = n.default, Oe = n.footer, Se = ge ? J : $;
      return o("div", {
        ref: a,
        class: ["vxe-tabs", `vxe-tabs--${j || "default"}`, `trigger--${ne === "manual" ? "trigger" : "default"}`, {
          "is--padding": pe,
          "is--height": fe
        }],
        style: fe ? {
          height: cn(fe)
        } : null
      }, [
        o("div", {
          class: "vxe-tabs-slots"
        }, ge ? ge({}) : []),
        M(Se),
        o("div", {
          class: "vxe-tabs-pane"
        }, B(Se)),
        Oe ? o("div", {
          class: "vxe-tabs-footer"
        }, O(Oe, {})) : Yn()
      ]);
    };
    lt(() => e.modelValue, (j) => {
      E(j, null), m.activeName = j;
    }), lt(() => m.activeName, (j) => {
      L(j), me(() => {
        m.resizeFlag++;
      });
    });
    const ce = ke(0);
    lt(() => e.options ? e.options.length : -1, () => {
      ce.value++;
    }), lt(() => e.options, () => {
      ce.value++;
    }), lt(ce, () => {
      C(e.options), g();
    });
    const A = ke(0);
    return lt(() => m.staticTabs ? m.staticTabs.length : -1, () => {
      A.value++;
    }), lt(() => m.staticTabs, () => {
      A.value++;
    }), lt(A, () => {
      C(m.staticTabs), g();
    }), l && lt(() => l ? l.reactData.resizeFlag : null, () => {
      m.resizeFlag++;
    }), lt(() => m.resizeFlag, () => {
      me(() => {
        g();
      });
    }), wn(() => {
      ut.on(x, "resize", g), g();
    }), $n(() => {
      ut.off(x, "resize");
    }), bn("$xeTabs", x), E(e.modelValue, null), C(m.staticTabs.length ? m.staticTabs : e.options), x.renderVN = H, x;
  },
  render() {
    return this.renderVN();
  }
});
function XL(e, t, n) {
  const s = e.reactData.staticTabs, i = t.parentNode;
  i && (s.splice(r.arrayIndexOf(i.children, t), 0, n), e.reactData.staticTabs = s.slice(0));
}
function ZL(e, t) {
  const n = e.reactData.staticTabs, s = r.findTree(n, (i) => i.id === t.id, { children: "children" });
  s && s.items.splice(s.index, 1), e.reactData.staticTabs = n.slice(0);
}
const qs = pt({
  name: "VxeTabPane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), a = mt("$xeTabs", null), c = Rt({}), m = Rt({
      id: i,
      title: e.title,
      name: e.name,
      icon: e.icon,
      titleWidth: e.titleWidth,
      titleAlign: e.titleAlign,
      preload: e.preload,
      permissionCode: e.permissionCode,
      slots: n
    }), u = {
      refElem: l
    }, d = {}, p = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => u,
      getComputeMaps: () => d
    };
    Object.assign(p, {
      dispatchEvent: (x, h, O) => {
        s(x, Zt(O, { $tabPane: p }, h));
      }
    }, {}), lt(() => e.title, (x) => {
      m.title = x;
    }), lt(() => e.name, (x) => {
      m.name = x;
    }), lt(() => e.icon, (x) => {
      m.icon = x;
    }), lt(() => e.permissionCode, (x) => {
      m.permissionCode = x;
    }), wn(() => {
      const x = l.value;
      a && x && XL(a, x, m);
    }), $n(() => {
      a && ZL(a, m);
    });
    const S = () => o("div", {
      ref: l
    }, []);
    return p.renderVN = S, p;
  },
  render() {
    return this.renderVN();
  }
}), Nv = {
  title: String,
  field: String,
  span: {
    type: [String, Number],
    default: null
  },
  align: {
    type: String,
    default: null
  },
  verticalAlign: {
    type: String,
    default: null
  },
  titleBackground: {
    type: Boolean,
    default: null
  },
  titleBold: {
    type: Boolean,
    default: null
  },
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: !0
  },
  vertical: {
    type: Boolean,
    default: null
  },
  padding: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: {
    type: Boolean,
    default: null
  },
  showContent: {
    type: Boolean,
    default: null
  },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array
}, kt = pt({
  name: "VxeFormItem",
  props: Nv,
  setup(e, { slots: t }) {
    const n = ke(), s = mt("$xeForm", {}), i = mt("$xeFormGroup", null), l = Rt(Od(s, e));
    l.slots = t, bn("xeFormItemInfo", { itemConfig: l });
    const c = (d, p) => {
      const w = d.props, { data: v, readonly: D, disabled: S } = w, { visible: x, field: h, itemRender: O, contentStyle: g, showContent: b } = p, E = xs(O) ? Cn.get(O.name) : null, C = E ? E.formItemStyle || E.itemStyle : null, V = E ? E.formItemContentStyle || E.itemContentStyle : null, Q = { data: v, disabled: S, readonly: D, field: h, property: h, item: p, $form: d, $grid: d.xegrid };
      return x === !1 ? Ve() : o("div", {
        ref: n,
        key: p.id,
        class: Td(d, p),
        style: r.isFunction(C) ? C(Q) : C
      }, [
        Id(d, p),
        b === !1 ? Ve() : o("div", {
          class: Md(d, p),
          style: Object.assign({}, r.isFunction(V) ? V(Q) : V, r.isFunction(g) ? g(Q) : g)
        }, [
          Tv(d, p)
        ])
      ]);
    }, u = {
      formItem: l,
      renderVN: () => (s ? s.props.customLayout : !1) ? c(s, l) : o("div", {
        ref: n
      })
    };
    return Sv(e, l), wn(() => {
      const d = n.value;
      Dv(s, d, l, i);
    }), $n(() => {
      Ov(s, l);
    }), bn("$xeFormItem", u), bn("$xeFormGroup", null), u;
  },
  render() {
    return this.renderVN();
  }
}), ao = pt({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => oe().switch.size || oe().size
    },
    openLabel: String,
    closeLabel: String,
    openValue: {
      type: [String, Number, Boolean],
      default: !0
    },
    closeValue: {
      type: [String, Number, Boolean],
      default: !1
    },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup(e, t) {
    const { emit: n } = t, s = mt("$xeForm", null), i = mt("xeFormItemInfo", null), l = r.uniqueId(), { computeSize: a } = dn(e), c = Rt({
      isActivated: !1,
      hasAnimat: !1,
      offsetLeft: 0
    }), m = {}, u = {
      xID: l,
      props: e,
      context: t,
      reactData: c,
      internalData: m
    }, d = ke();
    let p = {};
    const w = _(() => {
      const { disabled: C } = e;
      return C === null ? s ? s.props.readonly || s.props.disabled : !1 : C;
    }), v = _(() => Bn(e.openLabel)), D = _(() => Bn(e.closeLabel)), S = _(() => e.modelValue === e.openValue), x = (C) => {
      n("update:modelValue", C);
    }, h = (C) => {
      if (!w.value) {
        const Q = S.value;
        clearTimeout(m.atTimeout);
        const Z = Q ? e.closeValue : e.openValue;
        c.hasAnimat = !0, x(Z), p.dispatchEvent("change", { value: Z }, C), s && i && s.triggerItemEvent(C, i.itemConfig.field, Z), m.atTimeout = setTimeout(() => {
          c.hasAnimat = !1, m.atTimeout = void 0;
        }, 400);
      }
    }, O = (C, V, Q) => {
      n(C, Zt(Q, { $switch: u }, V));
    }, g = (C) => {
      c.isActivated = !0, p.dispatchEvent("focus", { value: e.modelValue }, C);
    }, b = (C) => {
      c.isActivated = !1, p.dispatchEvent("blur", { value: e.modelValue }, C);
    };
    p = {
      dispatchEvent: O,
      focus() {
        const C = d.value;
        return c.isActivated = !0, C && C.focus(), me();
      },
      blur() {
        const C = d.value;
        return C && C.blur(), c.isActivated = !1, me();
      }
    }, Object.assign(u, p);
    const E = () => {
      const { openIcon: C, closeIcon: V, openActiveIcon: Q, closeActiveIcon: Z } = e, G = a.value, ue = S.value, Y = v.value, K = D.value, L = w.value;
      return o("div", {
        class: ["vxe-switch", ue ? "is--on" : "is--off", {
          [`size--${G}`]: G,
          "is--disabled": L,
          "is--animat": c.hasAnimat
        }]
      }, [
        o("button", {
          ref: d,
          class: "vxe-switch--button",
          type: "button",
          disabled: L,
          onClick: h,
          onFocus: g,
          onBlur: b
        }, [
          o("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            C ? o("i", {
              class: ["vxe-switch--label-icon", C]
            }) : Ve(),
            Y
          ]),
          o("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            V ? o("i", {
              class: ["vxe-switch--label-icon", V]
            }) : Ve(),
            K
          ]),
          o("span", {
            class: ["vxe-switch--icon"]
          }, Q || Z ? [
            o("i", {
              class: ue ? Q : Z
            })
          ] : [])
        ])
      ]);
    };
    return u.renderVN = E, u;
  },
  render() {
    return this.renderVN();
  }
}), JL = pt({
  name: "DefaultSettingForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormDesign", null);
    if (!t)
      return () => [];
    const { props: n } = t;
    return () => {
      const { formData: s } = e;
      return o(Nn, {
        data: s,
        span: 24,
        vertical: !0,
        titleBold: !0
      }, {
        default() {
          const { showPc: i, showMobile: l } = n;
          return [
            o(kt, {
              title: Pe("vxe.formDesign.formName"),
              field: "title",
              itemRender: { name: "VxeInput", props: { placeholder: Pe("vxe.formDesign.defFormTitle") } }
            }),
            i && l ? o(kt, {
              title: Pe("vxe.formDesign.widgetProp.displaySetting.name")
            }, {
              default() {
                return [
                  o("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    o("div", {
                      class: "vxe-form-design--widget-form-item-pc"
                    }, [
                      o(Ps, {
                        icon: ht().FORM_DESIGN_PROPS_PC,
                        content: Pe("vxe.formDesign.widgetProp.displaySetting.pc")
                      }),
                      o(ao, {
                        modelValue: s.pcVisible,
                        openLabel: Pe("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: Pe("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(a) {
                          s.pcVisible = a;
                        }
                      })
                    ]),
                    o("div", {
                      class: "vxe-form-design--widget-form-item-mobile"
                    }, [
                      o(Ps, {
                        icon: ht().FORM_DESIGN_PROPS_MOBILE,
                        content: Pe("vxe.formDesign.widgetProp.displaySetting.mobile")
                      }),
                      o(ao, {
                        modelValue: s.mobileVisible,
                        openLabel: Pe("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: Pe("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(a) {
                          s.mobileVisible = a;
                        }
                      })
                    ])
                  ])
                ];
              }
            }) : Ve()
          ];
        }
      });
    };
  }
}), QL = pt({
  name: "FormDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const e = mt("$xeFormDesign", null);
    if (!e)
      return () => [];
    const { props: t, reactData: n } = e, s = ke(1), i = () => {
      const { activeWidget: a } = n;
      if (a) {
        const c = Cn.get(a.name), m = c ? c.renderFormDesignWidgetFormView : null;
        if (m)
          return o("div", {
            class: "vxe-form-design--custom-widget-form-view"
          }, Nt(m(a, { isEditMode: !0, isViewMode: !1, widget: a, $formDesign: e, $formView: null })));
      }
      return Ve();
    }, l = () => {
      const { formRender: a } = t, { formData: c } = n;
      if (a) {
        const m = Cn.get(a.name), u = m ? m.renderFormDesignSettingFormView : null;
        if (u)
          return o("div", {
            class: "vxe-form-design--custom-setting-form-view"
          }, Nt(u({}, { $formDesign: e })));
      }
      return o(JL, {
        formData: c
      });
    };
    return lt(() => n.activeWidget, () => {
      s.value = 1;
    }), () => o("div", {
      class: "vxe-form-design--setting"
    }, [
      o("div", {
        class: "vxe-form-design--setting-form"
      }, [
        o(ol, {
          modelValue: s.value,
          titleWidth: "50%",
          titleAlign: "center",
          padding: !0,
          class: "vxe-form-design--setting-form-tabs",
          "onUpdate:modelValue"(a) {
            s.value = a;
          }
        }, {
          default() {
            return [
              o(qs, {
                title: Pe("vxe.formDesign.widgetPropTab"),
                name: 1
              }, {
                default() {
                  return i();
                }
              }),
              o(qs, {
                title: Pe("vxe.formDesign.widgetFormTab"),
                name: 2
              }, {
                default() {
                  return l();
                }
              })
            ];
          }
        })
      ])
    ]);
  }
}), Pr = [], zu = [], Hu = [], yi = "data-vxe-lock-scroll", fm = "--vxe-ui-modal-lock-scroll-view-width", Oi = pt({
  name: "VxeModal",
  props: {
    modelValue: Boolean,
    id: String,
    type: {
      type: String,
      default: "modal"
    },
    loading: {
      type: Boolean,
      default: null
    },
    status: String,
    iconStatus: String,
    className: String,
    top: {
      type: [Number, String],
      default: () => oe().modal.top
    },
    position: [String, Object],
    title: String,
    duration: {
      type: [Number, String],
      default: () => oe().modal.duration
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => oe().modal.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => oe().modal.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => oe().modal.confirmButtonText
    },
    lockView: {
      type: Boolean,
      default: () => oe().modal.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => oe().modal.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => oe().modal.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => oe().modal.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => oe().modal.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => oe().modal.confirmClosable
    },
    resize: Boolean,
    showHeader: {
      type: Boolean,
      default: () => oe().modal.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => oe().modal.showFooter
    },
    showZoom: Boolean,
    zoomConfig: Object,
    showMaximize: {
      type: Boolean,
      default: () => tm(oe().modal.showMaximize)
    },
    showMinimize: {
      type: Boolean,
      default: () => tm(oe().modal.showMinimize)
    },
    showClose: {
      type: Boolean,
      default: () => oe().modal.showClose
    },
    dblclickZoom: {
      type: Boolean,
      default: () => oe().modal.dblclickZoom
    },
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => oe().modal.minWidth
    },
    minHeight: {
      type: [Number, String],
      default: () => oe().modal.minHeight
    },
    zIndex: Number,
    marginSize: {
      type: [Number, String],
      default: () => oe().modal.marginSize
    },
    fullscreen: Boolean,
    draggable: {
      type: Boolean,
      default: () => oe().modal.draggable
    },
    remember: { type: Boolean, default: () => oe().modal.remember },
    destroyOnClose: {
      type: Boolean,
      default: () => oe().modal.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => oe().modal.showTitleOverflow
    },
    transfer: {
      type: Boolean,
      default: () => oe().modal.transfer
    },
    storage: {
      type: Boolean,
      default: () => oe().modal.storage
    },
    storageKey: {
      type: String,
      default: () => oe().modal.storageKey
    },
    padding: {
      type: Boolean,
      default: () => oe().modal.padding
    },
    size: {
      type: String,
      default: () => oe().modal.size || oe().size
    },
    beforeHideMethod: Function,
    slots: Object,
    /**
     * 已废弃
     * @deprecated
     */
    message: [Number, String],
    /**
     * 已废弃
     * @deprecated
     */
    animat: {
      type: Boolean,
      default: () => oe().modal.animat
    }
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "zoom",
    "resize",
    "move"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = Rt({
      initialized: !1,
      visible: !1,
      contentVisible: !1,
      modalTop: 0,
      modalZindex: 0,
      prevZoomStatus: "",
      zoomStatus: "",
      revertLocat: null,
      prevLocat: null,
      firstOpen: !0
    }), c = {
      msgTimeout: void 0
    }, m = ke(), u = ke(), d = ke(), p = ke(), w = ke(), v = {
      refElem: m
    }, D = _(() => e.type === "message" || e.type === "notification"), S = _(() => a.zoomStatus === "minimize"), x = _(() => a.zoomStatus === "maximize"), h = _(() => Object.assign({}, oe().modal.zoomConfig, e.zoomConfig)), O = {
      computeSize: l,
      computeZoomOpts: h
    }, g = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      internalData: c,
      getRefMaps: () => v,
      getComputeMaps: () => O
    };
    let b = {};
    const E = () => u.value, C = () => {
      const { width: ve, height: Ne } = e, q = E();
      return q && (q.style.width = cn(ve), q.style.height = cn(Ne)), me();
    }, V = () => {
      const { zIndex: ve } = e, { modalZindex: Ne } = a;
      ve ? a.modalZindex = ve : Ne < ws() && (a.modalZindex = ds());
    }, Q = () => me().then(() => {
      const { position: ve } = e, Ne = r.toNumber(e.marginSize), q = E();
      if (!q)
        return;
      const z = document.documentElement.clientWidth || document.body.clientWidth, R = document.documentElement.clientHeight || document.body.clientHeight, le = ve === "center", { top: F, left: re } = r.isString(ve) ? { top: ve, left: ve } : Object.assign({}, ve), N = le || F === "center", ee = le || re === "center";
      let be = "", we = "";
      re && !ee ? we = isNaN(re) ? re : `${re}px` : we = `${Math.max(Ne, z / 2 - q.offsetWidth / 2)}px`, F && !N ? be = isNaN(F) ? F : `${F}px` : be = `${Math.max(Ne, R / 2 - q.offsetHeight / 2)}px`, q.style.top = be, q.style.left = we;
    }), Z = () => {
      me(() => {
        const { type: ve } = e, Ne = ve === "notification" ? Hu : zu;
        let q = 0;
        Ne.forEach((z) => {
          const R = z.getBox();
          R && (q += r.toNumber(z.props.top), z.reactData.modalTop = q, q += R.clientHeight);
        });
      });
    }, G = () => {
      const { type: ve } = e, Ne = ve === "notification" ? Hu : zu;
      Ne.indexOf(g) > -1 && r.remove(Ne, (q) => q === g), Z();
    }, ue = (ve) => {
      const { remember: Ne } = e, { visible: q } = a, z = D.value, R = e.beforeHideMethod || oe().modal.beforeHideMethod, le = { type: ve };
      return q && Promise.resolve(R ? R(le) : null).then((F) => {
        r.isError(F) || (z && G(), a.contentVisible = !1, Ne || Se(), r.remove(Pr, (re) => re === g), dt("before-hide", le, null), setTimeout(() => {
          a.visible = !1, s("update:modelValue", !1), dt("hide", le, null);
        }, 200), A());
      }).catch((F) => F), me();
    }, Y = (ve) => {
      const Ne = "close";
      dt(Ne, { type: Ne }, ve), ue(Ne);
    }, K = (ve) => {
      const { confirmClosable: Ne } = e, q = "confirm";
      dt(q, { type: q }, ve), Ne && ue(q);
    }, L = (ve) => {
      const { cancelClosable: Ne } = e, q = "cancel";
      dt(q, { type: q }, ve), Ne && ue(q);
    }, ye = (ve) => {
      const Ne = oe().version, q = r.toStringJSON(localStorage.getItem(ve) || "");
      return q && q._v === Ne ? q : { _v: Ne };
    }, se = () => {
      const { id: ve, remember: Ne, storage: q, storageKey: z } = e;
      return !!(ve && Ne && q && ye(z)[ve]);
    }, P = () => {
      const { id: ve, remember: Ne, storage: q, storageKey: z } = e;
      if (ve && Ne && q) {
        const R = ye(z)[ve];
        if (R) {
          const le = E(), [F, re, N, ee, be, we, Te, ze] = R.split(",");
          le && (F && (le.style.left = `${F}px`), re && (le.style.top = `${re}px`), N && (le.style.width = `${N}px`), ee && (le.style.height = `${ee}px`)), be && we && (a.revertLocat = {
            left: be,
            top: we,
            width: Te,
            height: ze
          });
        }
      }
    }, M = () => {
      const { type: ve } = e, Ne = ve === "notification" ? Hu : zu;
      Ne.indexOf(g) === -1 && Ne.push(g), Z();
    }, I = () => {
      const { id: ve, remember: Ne, storage: q, storageKey: z } = e, { revertLocat: R } = a;
      if (ve && Ne && q) {
        const le = E();
        if (!le)
          return;
        const F = ye(z);
        F[ve] = [
          le.style.left,
          le.style.top,
          le.style.width,
          le.style.height
        ].concat(R ? [
          R.left,
          R.top,
          R.width,
          R.height
        ] : []).map((re) => re ? r.toNumber(re) : "").join(","), localStorage.setItem(z, r.toJSONString(F));
      }
    }, B = () => {
      const ve = h.value, { minimizeLayout: Ne, minimizeMaxSize: q, minimizeHorizontalOffset: z, minimizeVerticalOffset: R, minimizeOffsetMethod: le } = ve, F = Ne === "horizontal", re = a.zoomStatus, N = [], ee = [];
      Pr.forEach((we) => {
        we.xID !== g.xID && we.props.type === "modal" && we.reactData.zoomStatus === "minimize" && (we.getComputeMaps().computeZoomOpts.value.minimizeLayout === "horizontal" ? N.push(we) : ee.push(we));
      });
      const be = F ? N : ee;
      return q && be.length >= q ? (Ce.modal && Ce.modal.message({
        status: "error",
        content: Pe("vxe.modal.miniMaxSize", [q])
      }), me()) : (a.prevZoomStatus = re, a.zoomStatus = "minimize", me().then(() => {
        const we = E();
        if (!we)
          return;
        const Te = d.value;
        if (!Te)
          return;
        const { visibleHeight: ze } = tl();
        re || (a.revertLocat = {
          top: we.offsetTop,
          left: we.offsetLeft,
          width: we.offsetWidth + (we.style.width ? 0 : 1),
          height: we.offsetHeight + (we.style.height ? 0 : 1)
        });
        const st = r[F ? "max" : "min"](be, (wt) => {
          const St = wt.getBox();
          return St ? r.toNumber(St.style[F ? "left" : "top"]) : 0;
        });
        let ct = ze - Te.offsetHeight - 16, Ke = 16;
        if (st) {
          const wt = st.getBox();
          if (wt) {
            const St = r.toNumber(wt.style.left), Dt = r.toNumber(wt.style.top);
            let Wt = {};
            F ? Wt = Object.assign({}, z) : Wt = Object.assign({}, R), Ke = St + r.toNumber(Wt.left), ct = Dt + r.toNumber(Wt.top), le && (Wt = le({
              $modal: g,
              left: Ke,
              top: ct
            }), Ke = r.toNumber(Wt.left), ct = r.toNumber(Wt.top));
          }
        }
        Object.assign(we.style, {
          top: `${ct}px`,
          left: `${Ke}px`,
          width: "200px",
          height: `${Te.offsetHeight}px`
        }), I();
      }));
    }, H = () => {
      const ve = a.zoomStatus;
      return a.prevZoomStatus = ve, a.zoomStatus = "maximize", me().then(() => {
        const Ne = E();
        Ne && (ve || (a.revertLocat = {
          top: Ne.offsetTop,
          left: Ne.offsetLeft,
          width: Ne.offsetWidth + (Ne.style.width ? 0 : 1),
          height: Ne.offsetHeight + (Ne.style.height ? 0 : 1)
        }), Object.assign(Ne.style, {
          top: "0",
          left: "0",
          width: "100%",
          height: "100%"
        })), I();
      });
    }, ce = () => {
      const { duration: ve } = e;
      ve !== -1 && (c.msgTimeout = setTimeout(() => ue("close"), r.toNumber(ve)));
    }, A = () => {
      const ve = document.documentElement, Ne = ve.getAttribute(yi);
      if (Ne) {
        const q = Ne.split(",").filter((z) => z !== i);
        q.length ? ve.setAttribute(yi, q.join(",")) : (ve.removeAttribute(yi), ve.style.removeProperty(fm));
      }
    }, j = () => {
      const { lockScroll: ve } = e, Ne = D.value;
      if (ve && !Ne) {
        const q = document.documentElement, z = document.body.clientWidth, R = q.getAttribute(yi), le = R ? R.split(",") : [];
        le.includes(i) || (le.push(i), q.setAttribute(yi, le.join(","))), q.style.setProperty(fm, `${z}px`);
      }
    }, fe = () => {
      const { remember: ve, showFooter: Ne } = e, { initialized: q, visible: z } = a, R = D.value;
      return q || (a.initialized = !0), z || (j(), a.visible = !0, a.contentVisible = !1, V(), Pr.push(g), ve || me(() => {
        C();
      }), setTimeout(() => {
        a.contentVisible = !0, me(() => {
          if (Ne) {
            const re = p.value, N = w.value, ee = re || N;
            ee && ee.focus();
          }
          const F = { type: "" };
          s("update:modelValue", !0), dt("show", F, null);
        });
      }, 10), R ? (M(), ce()) : me(() => {
        const { fullscreen: le } = e, { firstOpen: F } = a;
        (!ve || F) && Q().then(() => {
          setTimeout(() => Q(), 20);
        }), F ? (a.firstOpen = !1, se() ? P() : le && me(() => H())) : le && me(() => H());
      })), me();
    }, pe = (ve) => {
      const Ne = m.value;
      e.maskClosable && ve.target === Ne && ue("mask");
    }, ne = () => {
      const { msgTimeout: ve } = c;
      if (!ve)
        return;
      D.value && (clearTimeout(ve), c.msgTimeout = void 0);
    }, $ = () => {
      const { msgTimeout: ve } = c;
      ve || D.value && ce();
    }, J = (ve) => {
      if (ut.hasKey(ve, Yt.ESCAPE)) {
        const q = r.max(Pr, (z) => z.reactData.modalZindex);
        q && setTimeout(() => {
          if (q === g && q.props.escClosable) {
            const z = "exit";
            dt("close", { type: z }, ve), ue(z);
          }
        }, 10);
      }
    }, ge = () => a.zoomStatus === "minimize", Oe = () => a.zoomStatus === "maximize", Se = () => (a.prevZoomStatus = a.zoomStatus, a.zoomStatus = "", me().then(() => {
      const { revertLocat: ve } = a;
      if (ve) {
        const Ne = E();
        return a.revertLocat = null, Ne && Object.assign(Ne.style, {
          top: `${ve.top}px`,
          left: `${ve.left}px`,
          width: `${ve.width}px`,
          height: `${ve.height}px`
        }), I(), me();
      }
    })), de = (ve) => {
      const { zoomStatus: Ne } = a;
      return new Promise((q) => {
        if (ve) {
          if (ve === "maximize") {
            q(H());
            return;
          }
          if (ve === "minimize") {
            q(B());
            return;
          }
          q(Se());
          return;
        }
        q(Ne ? Se() : H());
      }).then(() => a.zoomStatus || "revert");
    }, Ie = (ve) => {
      const { zoomStatus: Ne, prevZoomStatus: q } = a;
      return de(Ne === "minimize" ? q || "revert" : "minimize").then((z) => {
        dt("zoom", { type: z }, ve);
      });
    }, je = (ve) => de().then((Ne) => {
      dt("zoom", { type: Ne }, ve);
    }), Ue = () => {
      if (!D.value) {
        const Ne = E();
        if (Ne)
          return {
            top: Ne.offsetTop,
            left: Ne.offsetLeft
          };
      }
      return null;
    }, Ae = (ve, Ne) => {
      if (!D.value) {
        const z = E();
        z && (r.isNumber(ve) && (z.style.top = `${ve}px`), r.isNumber(Ne) && (z.style.left = `${Ne}px`));
      }
      return me();
    }, _e = () => {
      const { modalZindex: ve } = a;
      Pr.some((Ne) => Ne.reactData.visible && Ne.reactData.modalZindex > ve) && V();
    }, it = (ve) => {
      const { remember: Ne, storage: q } = e, { zoomStatus: z } = a, R = r.toNumber(e.marginSize), le = E();
      if (le && z !== "maximize" && ve.button === 0 && !jn(ve, le, "trigger--btn").flag) {
        ve.preventDefault();
        const F = document.onmousemove, re = document.onmouseup, N = ve.clientX - le.offsetLeft, ee = ve.clientY - le.offsetTop, { visibleHeight: be, visibleWidth: we } = tl();
        document.onmousemove = (Te) => {
          Te.preventDefault();
          const ze = le.offsetWidth, st = le.offsetHeight, ct = R, Ke = we - ze - R - 1, wt = R, St = be - st - R - 1;
          let Dt = Te.clientX - N, Wt = Te.clientY - ee;
          Dt > Ke && (Dt = Ke), Dt < ct && (Dt = ct), Wt > St && (Wt = St), Wt < wt && (Wt = wt), le.style.left = `${Dt}px`, le.style.top = `${Wt}px`, le.className = le.className.replace(/\s?is--drag/, "") + " is--drag", dt("move", { type: "move" }, Te);
        }, document.onmouseup = () => {
          document.onmousemove = F, document.onmouseup = re, Ne && q && me(() => {
            I();
          }), setTimeout(() => {
            le.className = le.className.replace(/\s?is--drag/, "");
          }, 50);
        };
      }
    }, vt = (ve) => {
      ve.preventDefault();
      const { remember: Ne, storage: q } = e, { visibleHeight: z, visibleWidth: R } = tl(), le = r.toNumber(e.marginSize), re = ve.target.getAttribute("type"), N = r.toNumber(e.minWidth), ee = r.toNumber(e.minHeight), be = R, we = z, Te = E(), ze = document.onmousemove, st = document.onmouseup, ct = Te.clientWidth, Ke = Te.clientHeight, wt = ve.clientX, St = ve.clientY, Dt = Te.offsetTop, Wt = Te.offsetLeft, nn = { type: "resize" };
      document.onmousemove = (zt) => {
        zt.preventDefault();
        let At, Ee, Ye, rt;
        switch (re) {
          case "wl":
            At = wt - zt.clientX, Ye = At + ct, Wt - At > le && Ye > N && (Te.style.width = `${Ye < be ? Ye : be}px`, Te.style.left = `${Wt - At}px`);
            break;
          case "swst":
            At = wt - zt.clientX, Ee = St - zt.clientY, Ye = At + ct, rt = Ee + Ke, Wt - At > le && Ye > N && (Te.style.width = `${Ye < be ? Ye : be}px`, Te.style.left = `${Wt - At}px`), Dt - Ee > le && rt > ee && (Te.style.height = `${rt < we ? rt : we}px`, Te.style.top = `${Dt - Ee}px`);
            break;
          case "swlb":
            At = wt - zt.clientX, Ee = zt.clientY - St, Ye = At + ct, rt = Ee + Ke, Wt - At > le && Ye > N && (Te.style.width = `${Ye < be ? Ye : be}px`, Te.style.left = `${Wt - At}px`), Dt + rt + le < z && rt > ee && (Te.style.height = `${rt < we ? rt : we}px`);
            break;
          case "st":
            Ee = St - zt.clientY, rt = Ke + Ee, Dt - Ee > le && rt > ee && (Te.style.height = `${rt < we ? rt : we}px`, Te.style.top = `${Dt - Ee}px`);
            break;
          case "wr":
            At = zt.clientX - wt, Ye = At + ct, Wt + Ye + le < R && Ye > N && (Te.style.width = `${Ye < be ? Ye : be}px`);
            break;
          case "sest":
            At = zt.clientX - wt, Ee = St - zt.clientY, Ye = At + ct, rt = Ee + Ke, Wt + Ye + le < R && Ye > N && (Te.style.width = `${Ye < be ? Ye : be}px`), Dt - Ee > le && rt > ee && (Te.style.height = `${rt < we ? rt : we}px`, Te.style.top = `${Dt - Ee}px`);
            break;
          case "selb":
            At = zt.clientX - wt, Ee = zt.clientY - St, Ye = At + ct, rt = Ee + Ke, Wt + Ye + le < R && Ye > N && (Te.style.width = `${Ye < be ? Ye : be}px`), Dt + rt + le < z && rt > ee && (Te.style.height = `${rt < we ? rt : we}px`);
            break;
          case "sb":
            Ee = zt.clientY - St, rt = Ee + Ke, Dt + rt + le < z && rt > ee && (Te.style.height = `${rt < we ? rt : we}px`);
            break;
        }
        Te.className = Te.className.replace(/\s?is--drag/, "") + " is--drag", Ne && q && I(), dt("resize", nn, zt);
      }, document.onmouseup = () => {
        a.revertLocat = null, document.onmousemove = ze, document.onmouseup = st, setTimeout(() => {
          Te.className = Te.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    }, dt = (ve, Ne, q) => {
      s(ve, Zt(q, { $modal: g }, Ne));
    };
    b = {
      dispatchEvent: dt,
      open: fe,
      close() {
        return ue("close");
      },
      getBox: E,
      getPosition: Ue,
      setPosition: Ae,
      isMinimized: ge,
      isMaximized: Oe,
      zoom: de,
      minimize: B,
      maximize: H,
      revert: Se
    }, Object.assign(g, b);
    const at = () => {
      const { slots: ve = {}, showClose: Ne, showZoom: q, showMaximize: z, showMinimize: R, title: le } = e, { zoomStatus: F } = a, re = n.title || ve.title, N = n.corner || ve.corner, ee = S.value, be = x.value;
      return [
        o("div", {
          class: "vxe-modal--header-title"
        }, re ? Nt(re({
          $modal: g,
          minimized: ee,
          maximized: be
        })) : le ? Bn(le) : Pe("vxe.alert.title")),
        o("div", {
          class: "vxe-modal--header-right"
        }, [
          N && !ee ? o("div", {
            class: "vxe-modal--corner-wrapper"
          }, Nt(N({ $modal: g }))) : Ve(),
          (r.isBoolean(R) ? R : q) ? o("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: Pe(`vxe.modal.zoom${F === "minimize" ? "Out" : "Min"}`),
            onClick: Ie
          }, [
            o("i", {
              class: F === "minimize" ? ht().MODAL_ZOOM_REVERT : ht().MODAL_ZOOM_MIN
            })
          ]) : Ve(),
          (r.isBoolean(z) ? z : q) && F !== "minimize" ? o("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: Pe(`vxe.modal.zoom${F === "maximize" ? "Out" : "In"}`),
            onClick: je
          }, [
            o("i", {
              class: F === "maximize" ? ht().MODAL_ZOOM_OUT : ht().MODAL_ZOOM_IN
            })
          ]) : Ve(),
          Ne ? o("div", {
            class: ["vxe-modal--close-btn", "trigger--btn"],
            title: Pe("vxe.modal.close"),
            onClick: Y
          }, [
            o("i", {
              class: ht().MODAL_CLOSE
            })
          ]) : Ve()
        ])
      ];
    }, Et = () => {
      const { slots: ve = {}, showZoom: Ne, showMaximize: q, draggable: z } = e, R = D.value, le = n.header || ve.header;
      if (e.showHeader) {
        const F = {};
        return z && (F.onMousedown = it), (r.isBoolean(q) ? q : Ne) && e.dblclickZoom && e.type === "modal" && (F.onDblclick = je), o("div", Object.assign({ ref: d, class: ["vxe-modal--header", {
          "is--ellipsis": !R && e.showTitleOverflow
        }] }, F), le ? Nt(le({ $modal: g })) : at());
      }
      return Ve();
    }, Qe = () => {
      const { slots: ve = {}, status: Ne, message: q, iconStatus: z } = e, R = e.content || q, le = D.value, F = n.default || ve.default, re = n.left || ve.left, N = n.right || ve.right, ee = [];
      return !le && (Ne || z) && ee.push(o("div", {
        class: "vxe-modal--status-wrapper"
      }, [
        o("i", {
          class: ["vxe-modal--status-icon", z || ht()[`MODAL_${Ne}`.toLocaleUpperCase()]]
        })
      ])), ee.push(o("div", {
        class: "vxe-modal--content"
      }, F ? Nt(F({ $modal: g })) : Bn(R))), o("div", {
        class: "vxe-modal--body"
      }, [
        re ? o("div", {
          class: "vxe-modal--body-left"
        }, Nt(re({ $modal: g }))) : Ve(),
        o("div", {
          class: "vxe-modal--body-default"
        }, ee),
        N ? o("div", {
          class: "vxe-modal--body-right"
        }, Nt(N({ $modal: g }))) : Ve(),
        le ? Ve() : o(Xc, {
          class: "vxe-modal--loading",
          modelValue: e.loading
        })
      ]);
    }, De = () => {
      const { slots: ve = {}, showCancelButton: Ne, showConfirmButton: q, type: z, loading: R } = e, le = n.leftfoot || ve.leftfoot, F = n.rightfoot || ve.rightfoot, re = [];
      return (r.isBoolean(Ne) ? Ne : z === "confirm") && re.push(o(Vn, {
        key: 1,
        ref: w,
        content: e.cancelButtonText || Pe("vxe.button.cancel"),
        onClick: L
      })), (r.isBoolean(q) ? q : z === "confirm" || z === "alert") && re.push(o(Vn, {
        key: 2,
        ref: p,
        loading: R,
        status: "primary",
        content: e.confirmButtonText || Pe("vxe.button.confirm"),
        onClick: K
      })), o("div", {
        class: "vxe-modal--footer-wrapper"
      }, [
        o("div", {
          class: "vxe-modal--footer-left"
        }, le ? Nt(le({ $modal: g })) : []),
        o("div", {
          class: "vxe-modal--footer-right"
        }, F ? Nt(F({ $modal: g })) : re)
      ]);
    }, Re = () => {
      const { slots: ve = {} } = e, Ne = n.footer || ve.footer;
      return e.showFooter ? o("div", {
        class: "vxe-modal--footer"
      }, Ne ? Nt(Ne({ $modal: g })) : [De()]) : Ve();
    }, Be = () => {
      const { slots: ve = {}, className: Ne, type: q, animat: z, draggable: R, iconStatus: le, position: F, loading: re, destroyOnClose: N, status: ee, lockScroll: be, padding: we, lockView: Te, mask: ze, resize: st } = e, { initialized: ct, modalTop: Ke, contentVisible: wt, visible: St, zoomStatus: Dt } = a, Wt = n.aside || ve.aside, nn = l.value, zt = D.value, At = S.value, Ee = {};
      return zt && (Ee.onMouseover = ne, Ee.onMouseout = $), o(ks, {
        to: "body",
        disabled: e.transfer ? !ct : !0
      }, [
        o("div", Object.assign({ ref: m, class: ["vxe-modal--wrapper", `type--${q}`, `zoom--${Dt || "revert"}`, Ne || "", F ? `pos--${F}` : "", {
          [`size--${nn}`]: nn,
          [`status--${ee}`]: ee,
          "is--padding": we,
          "is--animat": z,
          "lock--scroll": be,
          "lock--view": Te,
          "is--draggable": R,
          "is--resize": st,
          "is--mask": ze,
          "is--visible": wt,
          "is--active": St,
          "is--loading": re
        }], style: {
          zIndex: a.modalZindex,
          top: Ke ? `${Ke}px` : null
        }, onClick: pe }, Ee), [
          o("div", {
            ref: u,
            class: "vxe-modal--box",
            onMousedown: _e
          }, [
            (zt || Wt) && !At ? o("div", {
              class: "vxe-modal--aside"
            }, Wt ? Nt(Wt({ $modal: g })) : [
              ee || le ? o("div", {
                class: "vxe-modal--status-wrapper"
              }, [
                o("i", {
                  class: ["vxe-modal--status-icon", le || ht()[`MODAL_${ee}`.toLocaleUpperCase()]]
                })
              ]) : Ve()
            ]) : Ve(),
            o("div", {
              class: "vxe-modal--container"
            }, !a.initialized || N && !a.visible ? [] : [
              Et(),
              Qe(),
              Re(),
              !zt && st ? o("span", {
                class: "vxe-modal--resize"
              }, ["wl", "wr", "swst", "sest", "st", "swlb", "selb", "sb"].map((Ye) => o("span", {
                class: `${Ye}-resize`,
                type: Ye,
                onMousedown: vt
              }))) : Ve()
            ])
          ])
        ])
      ]);
    };
    return g.renderVN = Be, lt(() => e.width, C), lt(() => e.height, C), lt(() => e.modelValue, (ve) => {
      ve ? fe() : ue("model");
    }), wn(() => {
      process.env.NODE_ENV === "development" && e.type === "modal" && e.showFooter && !(e.showConfirmButton || e.showCancelButton || n.footer) && Ar("vxe.modal.footPropErr"), me(() => {
        e.storage && !e.id && Ao("vxe.error.reqProp", ["modal.id"]), e.modelValue && fe(), C();
      }), e.escClosable && ut.on(g, "keydown", J);
    }), $n(() => {
      ut.off(g, "keydown"), G(), A();
    }), bn("$xeModal", g), g;
  },
  render() {
    return this.renderVN();
  }
}), e0 = (e) => ({
  title: "",
  pcVisible: e ? !!e.pcVisible : !0,
  pcVertical: !0,
  pcTitleBold: !0,
  pcTitleColon: !1,
  pcTitleAlign: "",
  pcTitleWidth: "",
  pcTitleWidthUnit: "",
  mobileVisible: e ? !!e.mobileVisible : !0,
  mobileVertical: !0,
  mobileTitleBold: !0,
  mobileTitleColon: !1,
  mobileTitleAlign: "",
  mobileTitleWidth: "",
  mobileTitleWidthUnit: ""
}), Fv = (e) => {
  const { formConfig: t } = e;
  return {
    vertical: t.pcVertical,
    titleBold: t.pcTitleBold,
    titleColon: t.pcTitleColon,
    titleAlign: t.pcTitleAlign,
    titleWidth: t.pcTitleWidth
  };
}, t0 = (e) => {
  const { formConfig: t } = e;
  return {
    vertical: t.mobileVertical,
    titleBold: t.mobileTitleBold,
    titleColon: t.mobileTitleColon,
    titleAlign: t.mobileTitleAlign,
    titleWidth: t.mobileTitleWidth
  };
}, Nr = pt({
  name: "VxeFormGroup",
  props: Nv,
  setup(e, t) {
    const { slots: n } = t, s = ke(), i = mt("$xeForm", {}), l = mt("$xeFormGroup", null), a = Rt(Od(i, e));
    a.slots = n, a.children = [], bn("xeFormItemInfo", { itemConfig: a });
    const u = {
      formItem: a,
      renderVN: () => {
        const d = i.props, p = a, { data: w, readonly: v, disabled: D } = d, { visible: S, field: x, itemRender: h, contentStyle: O } = p, g = xs(h) ? Cn.get(h.name) : null, b = g ? g.formItemStyle || g.itemStyle : null, E = g ? g.formItemContentStyle || g.itemContentStyle : null, C = n ? n.default : null, V = { data: w, disabled: D, readonly: v, field: x, property: x, item: p, $form: i, $grid: i.xegrid };
        return S === !1 ? Ve() : o("div", {
          ref: s,
          key: p.id,
          class: Td(i, p, !0),
          style: r.isFunction(b) ? b(V) : b
        }, [
          Id(i, p, !0),
          o("div", {
            class: Md(i, p, !0),
            style: Object.assign({}, r.isFunction(E) ? E(V) : E, r.isFunction(O) ? O(V) : O)
          }, C ? C({}) : [])
        ]);
      }
    };
    return Sv(e, a), wn(() => {
      const d = s.value;
      Dv(i, d, a, l);
    }), $n(() => {
      Ov(i, a);
    }), bn("$xeFormGroup", u), bn("$xeFormItem", null), u;
  },
  render() {
    return this.renderVN();
  }
}), Ti = pt({
  name: "VxeFormView",
  props: {
    modelValue: Object,
    config: Object,
    readonly: Boolean,
    disabled: Boolean,
    viewRender: Object,
    formOptions: Object,
    createFormConfig: Function,
    size: {
      type: String,
      default: () => oe().formView.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "submit",
    "reset"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), l = ke(), a = ke(), { computeSize: c } = dn(e), m = mt("$xeFormDesignLayoutStyle", null), u = Rt({
      formConfig: {},
      formRules: {},
      widgetObjList: []
    }), d = {
      refElem: l
    }, p = {
      computeSize: c
    }, w = {
      xID: i,
      props: e,
      context: t,
      reactData: u,
      getRefMaps: () => d,
      getComputeMaps: () => p
    }, v = () => D({
      formConfig: {},
      widgetData: []
    }), D = (P) => {
      if (P) {
        const { formConfig: M, widgetData: I } = P;
        h(M || {}), b(I || []);
      }
      return me();
    }, S = (P) => {
      const { formConfig: M, widgetData: I } = P || {}, B = g(I || []);
      return Object.assign(Object.assign({}, O(B)), { formConfig: x(M || {}), widgetData: B });
    }, x = (P) => {
      const { viewRender: M, createFormConfig: I, formOptions: B } = e, H = { viewRender: M, formConfig: P };
      if (I)
        return I(H);
      const { name: ce } = M || {}, A = Cn.get(ce) || {}, j = A ? A.createFormViewFormConfig : null;
      return Object.assign({}, j ? j(H) : Fv(H), B);
    }, h = (P) => (u.formConfig = x(P), me()), O = (P) => {
      const M = {}, I = {};
      return r.eachTree(P, (B) => {
        const { name: H, field: ce, required: A } = B, j = Cn.get(H) || {}, fe = j.createFormDesignWidgetFieldValue, pe = j.createFormDesignWidgetFieldRules;
        if (M[ce] = fe ? fe({ widget: B, $formView: w }) : E(B), pe) {
          const ne = pe({ widget: B, $formView: w });
          ne && ne.length && (I[ce] = ne);
        } else A && (I[ce] = C());
      }, { children: "children" }), {
        formData: M,
        formRules: I
      };
    }, g = (P) => (P || []).map((M) => Vd(M)), b = (P) => {
      const M = g(P);
      u.widgetObjList = M;
      const { formData: I, formRules: B } = O(M);
      return u.formRules = B, n("update:modelValue", Object.assign(I, e.modelValue)), me();
    }, E = (P) => {
      switch (P.name) {
        case "subtable":
          return [];
      }
      return null;
    }, C = () => [
      { required: !0, content: "该填写该字段！" }
    ], V = (P, M) => {
      const { field: I } = P, B = a.value;
      return B && B.updateStatus({ field: I }, M), me();
    }, Q = (P, M) => {
      const { modelValue: I } = e, { field: B } = P, H = a.value;
      return I && (I[B] = M), H && H.updateStatus({ field: B }, M), me();
    }, Z = (P) => {
      const { modelValue: M } = e;
      return M ? M[P.field] : null;
    }, G = (P, M, I) => {
      n(P, Zt(I, { $formView: w }, M));
    }, ue = (P) => P ? r.isArray(P) ? P.map((M) => M.name) : [P.name] : null, Y = {
      dispatchEvent: G,
      clearConfig: v,
      loadConfig: D,
      parseConfig: S,
      loadFormConfig: h,
      loadWidgetData: b,
      updateWidgetStatus: V,
      setItemValue: Q,
      getItemValue: Z,
      validate() {
        const P = a.value;
        return P ? P.validate() : me();
      },
      validateWidget(P) {
        const M = a.value;
        return M ? M.validateField(ue(P)) : me();
      },
      clearValidate(P) {
        const M = a.value;
        return M ? M.clearValidate(ue(P)) : me();
      },
      reset() {
        const { widgetObjList: P } = u, { formData: M } = O(P);
        return n("update:modelValue", Object.assign({}, M)), me();
      },
      /**
       * 已废弃
       * @deprecated
       */
      updateItemStatus(P, M) {
        return process.env.NODE_ENV === "development" && Ar("vxe.error.delFunc", ["updateItemStatus", "updateWidgetStatus"]), V(P, M);
      }
    }, K = (P) => {
      G("submit", P, P.$event);
    }, L = (P) => {
      G("reset", P, P.$event);
    };
    Object.assign(w, Y, {});
    const se = () => {
      const { readonly: P, disabled: M, modelValue: I } = e, { formConfig: B, formRules: H, widgetObjList: ce } = u, A = c.value, j = s.top, fe = s.bottom, pe = s.header, ne = s.footer;
      return o("div", {
        ref: l,
        class: ["vxe-form-view", {
          [`size--${A}`]: A
        }]
      }, [
        j ? o("div", {
          class: "vxe-form-view--top"
        }, Nt(j({ $formView: w }))) : Ve(),
        o(Nn, Object.assign(Object.assign({ ref: a }, B), {
          data: I,
          customLayout: !0,
          readonly: P,
          disabled: M,
          span: 24,
          rules: H,
          onSubmit: K,
          onReset: L
        }), {
          default() {
            const { readonly: $, disabled: J } = e;
            return [
              pe ? o(kt, {}, {
                default() {
                  return pe({});
                }
              }) : Ve(),
              ...ce.map((ge) => {
                const { name: Oe } = ge, Se = Cn.get(Oe) || {}, de = Se.renderFormDesignWidgetView, Ie = Se.renderFormDesignWidgetPreview, je = Se.renderFormDesignWidgetMobilePreview, Ue = !!m, Ae = ge, _e = { widget: ge, readonly: !!$, disabled: !!J, isEditMode: Ue, isViewMode: !Ue, $formDesign: null, $formView: w };
                return o(Nr, {
                  key: ge.id
                }, {
                  default() {
                    if (m) {
                      if (m.reactData.activeTab === 2) {
                        if (je)
                          return Nt(je(Ae, _e));
                      } else if (Ie)
                        return Nt(Ie(Ae, _e));
                    }
                    return de ? Nt(de(Ae, _e)) : [];
                  }
                });
              }),
              ne ? o(Nr, {
                span: 24
              }, {
                default() {
                  return ne({});
                }
              }) : Ve()
            ];
          }
        }),
        fe ? o("div", {
          class: "vxe-form-view--bottom"
        }, Nt(fe({ $formView: w }))) : Ve()
      ]);
    };
    return w.renderVN = se, lt(() => e.config, (P) => {
      D(P || {});
    }), e.config && D(e.config), bn("$xeFormView", w), w;
  },
  render() {
    return this.renderVN();
  }
});
function gs(e) {
  return r.isString(e) ? e.replace(/,/g, "") : e;
}
function Pc(e, t) {
  return /^-/.test("" + e) ? r.toFixed(r.ceil(e, t), t) : r.toFixed(r.floor(e, t), t);
}
const Wn = pt({
  name: "VxeInput",
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: !0
    },
    name: String,
    type: {
      type: String,
      default: "text"
    },
    clearable: {
      type: Boolean,
      default: () => oe().input.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => oe().input.size || oe().size
    },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => oe().input.exponential
    },
    // number、integer、float、password
    controls: {
      type: Boolean,
      default: () => oe().input.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: () => oe().input.digits
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => oe().input.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => oe().input.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: {
      type: [String, Number],
      default: () => oe().input.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: !0
    },
    festivalMethod: {
      type: Function,
      default: () => oe().input.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => oe().input.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => oe().input.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "search-click",
    "toggle-visible",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeSelect", null), l = mt("$xeTreeSelect", null), a = mt("$xeModal", null), c = mt("$xeDrawer", null), m = mt("$xeTable", null), u = mt("$xeForm", null), d = mt("xeFormItemInfo", null), p = r.uniqueId(), { computeSize: w } = dn(e), v = Rt({
      initialized: !1,
      panelIndex: 0,
      showPwd: !1,
      visiblePanel: !1,
      isAniVisible: !1,
      panelStyle: {},
      panelPlacement: "",
      isActivated: !1,
      inputValue: e.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    }), D = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: void 0,
      dnTimeout: void 0
    }, S = ke(), x = ke(), h = ke(), O = ke(), g = ke(), b = {
      refElem: S,
      refInput: x
    }, E = {
      xID: p,
      props: e,
      context: t,
      reactData: v,
      internalData: D,
      getRefMaps: () => b
    };
    let C = {};
    const V = (X, Le) => {
      const { type: qe } = e;
      return qe === "time" ? xv(X) : r.toStringDate(X, Le);
    }, Q = _(() => {
      const { transfer: X } = e;
      if (X === null) {
        const Le = oe().input.transfer;
        if (r.isBoolean(Le))
          return Le;
        if (m || a || c || u)
          return !0;
      }
      return X;
    }), Z = _(() => u ? u.props.readonly : !1), G = _(() => {
      const { readonly: X } = e;
      return X;
    }), ue = _(() => {
      const { disabled: X } = e;
      return X === null ? u ? u.props.disabled : !1 : X;
    }), Y = _(() => {
      const { maxLength: X, maxlength: Le } = e, qe = X || Le;
      return L.value && !r.toNumber(qe) ? 16 : qe;
    }), K = _(() => {
      const { type: X } = e;
      return X === "time" || X === "datetime";
    }), L = _(() => ["number", "integer", "float"].indexOf(e.type) > -1), ye = _(() => r.getSize(v.inputValue)), se = _(() => {
      const X = ye.value, Le = Y.value;
      return Le && X > r.toNumber(Le);
    }), P = _(() => K.value || ["date", "week", "month", "quarter", "year"].indexOf(e.type) > -1), M = _(() => e.type === "password"), I = _(() => e.type === "search"), B = _(() => r.toInteger(e.digits) || 1), H = _(() => {
      const { type: X } = e, Le = B.value, qe = e.step;
      return X === "integer" ? r.toInteger(qe) || 1 : X === "float" ? r.toNumber(qe) || 1 / Math.pow(10, Le) : r.toNumber(qe) || 1;
    }), ce = _(() => {
      const { type: X } = e, Le = L.value, qe = P.value, gt = M.value;
      return e.clearable && (gt || Le || qe || X === "text" || X === "search");
    }), A = _(() => e.startDate ? r.toStringDate(e.startDate) : null), j = _(() => e.endDate ? r.toStringDate(e.endDate) : null), fe = _(() => ["date", "week", "month", "quarter", "year"].indexOf(e.type) > -1), pe = _(() => {
      const { modelValue: X, multiple: Le } = e, qe = P.value, gt = J.value;
      return Le && X && qe ? r.toValueString(X).split(",").map((bt) => {
        const It = V(bt, gt);
        return r.isValidDate(It) ? It : null;
      }) : [];
    }), ne = _(() => {
      const X = pe.value, Le = J.value;
      return X.map((qe) => r.toDateString(qe, Le));
    }), $ = _(() => {
      const X = pe.value, Le = je.value;
      return X.map((qe) => r.toDateString(qe, Le)).join(", ");
    }), J = _(() => {
      const { type: X, valueFormat: Le } = e;
      return Le || (X === "time" ? "HH:mm:ss" : X === "datetime" ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd");
    }), ge = _(() => {
      const { modelValue: X } = e, Le = P.value, qe = J.value;
      let gt = null;
      if (X && Le) {
        const bt = V(X, qe);
        r.isValidDate(bt) && (gt = bt);
      }
      return gt;
    }), Oe = _(() => {
      const X = A.value, { selectMonth: Le } = v;
      return Le && X ? Le <= X : !1;
    }), Se = _(() => {
      const X = j.value, { selectMonth: Le } = v;
      return Le && X ? Le >= X : !1;
    }), de = _(() => {
      const { datetimePanelValue: X } = v, Le = le.value;
      return X ? r.toDateString(X, Le ? "HH:mm:ss" : "HH:mm") : "";
    }), Ie = _(() => {
      const X = ge.value, Le = K.value;
      return X && Le ? (X.getHours() * 3600 + X.getMinutes() * 60 + X.getSeconds()) * 1e3 : 0;
    }), je = _(() => {
      const { labelFormat: X } = e;
      return P.value ? X || Pe(`vxe.input.date.labelFormat.${e.type}`) : "";
    }), Ue = _(() => {
      const { selectMonth: X, currentDate: Le } = v, { yearSize: qe } = D, gt = [];
      if (X && Le) {
        const bt = Le.getFullYear(), It = X.getFullYear(), Kt = new Date(It - It % qe, 0, 1);
        for (let Ft = -4; Ft < qe + 4; Ft++) {
          const Je = r.getWhatYear(Kt, Ft, "first"), Vt = Je.getFullYear();
          gt.push({
            date: Je,
            isCurrent: !0,
            isPrev: Ft < 0,
            isNow: bt === Vt,
            isNext: Ft >= qe,
            year: Vt
          });
        }
      }
      return gt;
    }), Ae = _(() => {
      if (P.value) {
        const { datePanelType: Le, selectMonth: qe } = v, gt = Ue.value;
        let bt = "", It;
        return qe && (bt = qe.getFullYear(), It = qe.getMonth() + 1), Le === "quarter" ? Pe("vxe.input.date.quarterLabel", [bt]) : Le === "month" ? Pe("vxe.input.date.monthLabel", [bt]) : Le === "year" ? gt.length ? `${gt[0].year} - ${gt[gt.length - 1].year}` : "" : Pe("vxe.input.date.dayLabel", [bt, It ? Pe(`vxe.input.date.m${It}`) : "-"]);
      }
      return "";
    }), _e = _(() => {
      const { startDay: X, startWeek: Le } = e;
      return r.toNumber(r.isNumber(X) || r.isString(X) ? X : Le);
    }), it = _(() => {
      const X = [];
      if (P.value) {
        let qe = _e.value;
        X.push(qe);
        for (let gt = 0; gt < 6; gt++)
          qe >= 6 ? qe = 0 : qe++, X.push(qe);
      }
      return X;
    }), vt = _(() => P.value ? it.value.map((qe) => ({
      value: qe,
      label: Pe(`vxe.input.date.weeks.w${qe}`)
    })) : []), dt = _(() => {
      if (P.value) {
        const Le = vt.value;
        return [{ label: Pe("vxe.input.date.weeks.w") }].concat(Le);
      }
      return [];
    }), at = _(() => {
      const X = Ue.value;
      return r.chunk(X, 4);
    }), Et = _(() => {
      const { selectMonth: X, currentDate: Le } = v, { quarterSize: qe } = D, gt = [];
      if (X && Le) {
        const bt = Le.getFullYear(), It = ql(Le), Kt = r.getWhatYear(X, 0, "first"), Ft = Kt.getFullYear();
        for (let Je = -2; Je < qe - 2; Je++) {
          const Vt = r.getWhatQuarter(Kt, Je), un = Vt.getFullYear(), vn = ql(Vt), qn = un < Ft;
          gt.push({
            date: Vt,
            isPrev: qn,
            isCurrent: un === Ft,
            isNow: un === bt && vn === It,
            isNext: !qn && un > Ft,
            quarter: vn
          });
        }
      }
      return gt;
    }), Qe = _(() => {
      const X = Et.value;
      return r.chunk(X, 2);
    }), De = _(() => {
      const { selectMonth: X, currentDate: Le } = v, { monthSize: qe } = D, gt = [];
      if (X && Le) {
        const bt = Le.getFullYear(), It = Le.getMonth(), Kt = r.getWhatYear(X, 0, "first").getFullYear();
        for (let Ft = -4; Ft < qe - 4; Ft++) {
          const Je = r.getWhatYear(X, 0, Ft), Vt = Je.getFullYear(), un = Je.getMonth(), vn = Vt < Kt;
          gt.push({
            date: Je,
            isPrev: vn,
            isCurrent: Vt === Kt,
            isNow: Vt === bt && un === It,
            isNext: !vn && Vt > Kt,
            month: un
          });
        }
      }
      return gt;
    }), Re = _(() => {
      const X = De.value;
      return r.chunk(X, 4);
    }), Be = _(() => {
      const { selectMonth: X, currentDate: Le } = v, qe = [];
      if (X && Le) {
        const gt = Ie.value, bt = it.value, It = Le.getFullYear(), Kt = Le.getMonth(), Ft = Le.getDate(), Je = X.getFullYear(), Vt = X.getMonth(), un = X.getDay(), vn = -bt.indexOf(un), qn = new Date(r.getWhatDay(X, vn).getTime() + gt);
        for (let Ro = 0; Ro < 42; Ro++) {
          const Ko = r.getWhatDay(qn, Ro), wo = Ko.getFullYear(), eo = Ko.getMonth(), os = Ko.getDate(), Cr = Ko < X;
          qe.push({
            date: Ko,
            isPrev: Cr,
            isCurrent: wo === Je && eo === Vt,
            isNow: wo === It && eo === Kt && os === Ft,
            isNext: !Cr && Vt !== eo,
            label: os
          });
        }
      }
      return qe;
    }), ve = _(() => {
      const X = Be.value;
      return r.chunk(X, 7);
    }), Ne = _(() => {
      const X = ve.value, Le = _e.value;
      return X.map((qe) => {
        const gt = qe[0];
        return [{
          date: gt.date,
          isWeekNumber: !0,
          isPrev: !1,
          isCurrent: !1,
          isNow: !1,
          isNext: !1,
          label: r.getYearWeek(gt.date, Le)
        }].concat(qe);
      });
    }), q = _(() => {
      const X = [];
      if (K.value)
        for (let qe = 0; qe < 24; qe++)
          X.push({
            value: qe,
            label: ("" + qe).padStart(2, "0")
          });
      return X;
    }), z = _(() => {
      const X = [];
      if (K.value)
        for (let qe = 0; qe < 60; qe++)
          X.push({
            value: qe,
            label: ("" + qe).padStart(2, "0")
          });
      return X;
    }), R = _(() => {
      const X = J.value;
      return !/HH/.test(X) || /mm/.test(X);
    }), le = _(() => {
      const X = J.value;
      return !/HH/.test(X) || /ss/.test(X);
    }), F = _(() => z.value), re = _(() => {
      const { type: X, editable: Le, multiple: qe } = e;
      return G.value || qe || !Le || X === "week" || X === "quarter";
    }), N = _(() => {
      const { type: X } = e, { showPwd: Le } = v, qe = L.value, gt = P.value, bt = M.value;
      return gt || qe || bt && Le || X === "number" ? "text" : X;
    }), ee = _(() => {
      const { placeholder: X } = e;
      if (X)
        return Bn(X);
      const Le = oe().input.placeholder;
      return Le ? Bn(Le) : Pe("vxe.base.pleaseInput");
    }), be = _(() => {
      const { type: X, immediate: Le } = e;
      return Le || !(X === "text" || X === "number" || X === "integer" || X === "float");
    }), we = _(() => {
      const { type: X } = e, { inputValue: Le } = v;
      return L.value ? X === "integer" ? r.toInteger(gs(Le)) : r.toNumber(gs(Le)) : 0;
    }), Te = _(() => {
      const { min: X } = e, { inputValue: Le } = v, qe = L.value, gt = we.value;
      return (Le || Le === 0) && qe && X !== null ? gt <= r.toNumber(X) : !1;
    }), ze = _(() => {
      const { max: X } = e, { inputValue: Le } = v, qe = L.value, gt = we.value;
      return (Le || Le === 0) && qe && X !== null ? gt >= r.toNumber(X) : !1;
    }), st = (X) => {
      const { type: Le, exponential: qe } = e, gt = Y.value, bt = B.value, It = Le === "float" ? Pc(X, bt) : r.toValueString(X);
      return qe && (X === It || r.toValueString(X).toLowerCase() === r.toNumber(It).toExponential()) ? X : It.slice(0, gt);
    }, ct = (X) => {
      const { inputValue: Le } = v;
      C.dispatchEvent(X.type, { value: Le }, X);
    }, Ke = (X, Le) => {
      v.inputValue = X, s("update:modelValue", X), C.dispatchEvent("input", { value: X }, Le), r.toValueString(e.modelValue) !== X && (C.dispatchEvent("change", { value: X }, Le), !i && !l && u && d && u.triggerItemEvent(Le, d.itemConfig.field, X));
    }, wt = (X, Le) => {
      const qe = P.value, gt = be.value;
      v.inputValue = X, qe || (gt ? Ke(X, Le) : C.dispatchEvent("input", { value: X }, Le));
    }, St = (X) => {
      const qe = X.target.value;
      wt(qe, X);
    }, Dt = (X) => {
      be.value || ct(X);
    }, Wt = (X) => {
      const { inputValue: Le } = v, qe = be.value, gt = Le;
      qe || Ke(gt, X), on(), v.visiblePanel || (v.isActivated = !1), C.dispatchEvent("blur", { value: gt }, X), !i && !l && u && d && u.triggerItemEvent(X, d.itemConfig.field, gt);
    }, nn = (X) => {
      v.isActivated = !0, P.value && jt(X), ct(X);
    }, zt = (X) => {
      if (!ue.value) {
        const { inputValue: qe } = v;
        C.dispatchEvent("prefix-click", { value: qe }, X);
      }
    }, At = () => new Promise((X) => {
      v.visiblePanel = !1, D.hpTimeout = window.setTimeout(() => {
        v.isAniVisible = !1, X();
      }, 350);
    }), Ee = (X, Le) => {
      const { type: qe } = e, gt = L.value;
      P.value && At(), (gt || ["text", "search", "password"].indexOf(qe) > -1) && focus(), Ke("", X), C.dispatchEvent("clear", { value: Le }, X);
    }, Ye = (X) => {
      if (!ue.value) {
        const { inputValue: qe } = v;
        C.dispatchEvent("suffix-click", { value: qe }, X);
      }
    }, rt = (X) => {
      const { type: Le } = e, qe = je.value, gt = J.value, bt = _e.value;
      let It = null, Kt = "";
      if (X && (It = V(X, gt)), r.isValidDate(It)) {
        if (Kt = r.toDateString(It, qe, { firstDay: bt }), qe && Le === "week" && r.getWhatWeek(It, 0, bt, bt).getFullYear() < It.getFullYear()) {
          const Je = qe.indexOf("yyyy");
          if (Je > -1) {
            const Vt = Number(Kt.substring(Je, Je + 4));
            Vt && !isNaN(Vt) && (Kt = Kt.replace(`${Vt}`, `${Vt - 1}`));
          }
        }
      } else
        It = null;
      v.datePanelValue = It, v.datePanelLabel = Kt;
    }, Ot = () => {
      const X = P.value, { inputValue: Le } = v;
      X && (rt(Le), v.inputValue = e.multiple ? $.value : v.datePanelLabel);
    }, Jt = () => {
      const { type: X } = e, { inputValue: Le } = v, qe = P.value, gt = B.value;
      if (qe)
        Ot();
      else if (X === "float" && Le) {
        const bt = Pc(Le, gt);
        Le !== bt && Ke(bt, { type: "init" });
      }
    }, Bt = (X) => e.max === null || r.toNumber(X) <= r.toNumber(e.max), Gt = (X) => e.min === null || r.toNumber(X) >= r.toNumber(e.min), Qt = () => {
      v.inputValue = e.multiple ? $.value : v.datePanelLabel;
    }, U = (X) => {
      const Le = r.getWhatMonth(X, 0, "first");
      r.isEqual(Le, v.selectMonth) || (v.selectMonth = Le);
    }, Lt = (X) => {
      const { modelValue: Le, multiple: qe } = e, { datetimePanelValue: gt } = v, bt = K.value, It = J.value, Kt = _e.value;
      if (e.type === "week") {
        const Je = r.toNumber(e.selectDay);
        X = r.getWhatWeek(X, 0, Je, Kt);
      } else bt && (X.setHours(gt.getHours()), X.setMinutes(gt.getMinutes()), X.setSeconds(gt.getSeconds()));
      const Ft = r.toDateString(X, It, { firstDay: Kt });
      if (U(X), qe) {
        const Je = ne.value;
        if (bt) {
          const Vt = [...pe.value], un = [], vn = r.findIndexOf(Vt, (qn) => r.isDateSame(X, qn, "yyyyMMdd"));
          vn === -1 ? Vt.push(X) : Vt.splice(vn, 1), Vt.forEach((qn) => {
            qn && (qn.setHours(gt.getHours()), qn.setMinutes(gt.getMinutes()), qn.setSeconds(gt.getSeconds()), un.push(qn));
          }), Ke(un.map((qn) => r.toDateString(qn, It)).join(","), { type: "update" });
        } else
          Je.some((Vt) => r.isEqual(Vt, Ft)) ? Ke(Je.filter((Vt) => !r.isEqual(Vt, Ft)).join(","), { type: "update" }) : Ke(Je.concat([Ft]).join(","), { type: "update" });
      } else
        r.isEqual(Le, Ft) || Ke(Ft, { type: "update" });
    }, on = () => {
      const { type: X, min: Le, max: qe, exponential: gt } = e, { inputValue: bt, datetimePanelValue: It } = v, Kt = L.value, Ft = P.value, Je = je.value;
      if (!re.value) {
        if (Kt) {
          if (bt) {
            let un = X === "integer" ? r.toInteger(gs(bt)) : r.toNumber(gs(bt));
            if (Gt(un) ? Bt(un) || (un = qe) : un = Le, gt) {
              const vn = r.toValueString(bt).toLowerCase();
              vn === r.toNumber(un).toExponential() && (un = vn);
            }
            Ke(st(un), { type: "check" });
          }
        } else if (Ft)
          if (bt) {
            let un = V(bt, Je);
            if (r.isValidDate(un))
              if (X === "time")
                un = r.toDateString(un, Je), bt !== un && Ke(un, { type: "check" }), v.inputValue = un;
              else {
                let vn = !1;
                const qn = _e.value;
                if (X === "datetime") {
                  const Ro = ge.value;
                  (bt !== r.toDateString(Ro, Je) || bt !== r.toDateString(un, Je)) && (vn = !0, It.setHours(un.getHours()), It.setMinutes(un.getMinutes()), It.setSeconds(un.getSeconds()));
                } else
                  vn = !0;
                v.inputValue = r.toDateString(un, Je, { firstDay: qn }), vn && Lt(un);
              }
            else
              Qt();
          } else
            Ke("", { type: "check" });
      }
    }, en = (X) => {
      const { showPwd: Le } = v, qe = ue.value, gt = G.value;
      !qe && !gt && (v.showPwd = !Le), C.dispatchEvent("toggle-visible", { visible: v.showPwd }, X);
    }, hn = (X) => {
      C.dispatchEvent("search-click", {}, X);
    }, En = (X, Le) => {
      const { min: qe, max: gt, type: bt } = e, { inputValue: It } = v, Kt = H.value, Ft = bt === "integer" ? r.toInteger(gs(It)) : r.toNumber(gs(It)), Je = X ? r.add(Ft, Kt) : r.subtract(Ft, Kt);
      let Vt;
      Gt(Je) ? Bt(Je) ? Vt = Je : Vt = gt : Vt = qe, wt(st(Vt), Le);
    }, mn = (X) => {
      const Le = ue.value, qe = G.value, gt = Te.value;
      Qn(), !Le && !qe && !gt && En(!1, X), C.dispatchEvent("next-number", { value: v.inputValue }, X);
    }, gn = (X) => {
      D.dnTimeout = window.setTimeout(() => {
        mn(X), gn(X);
      }, 60);
    }, Sn = (X) => {
      const Le = ue.value, qe = G.value, gt = ze.value;
      Qn(), !Le && !qe && !gt && En(!0, X), C.dispatchEvent("prev-number", { value: v.inputValue }, X);
    }, Fn = (X) => {
      const Le = ut.hasKey(X, Yt.ARROW_UP), qe = ut.hasKey(X, Yt.ARROW_DOWN);
      (Le || qe) && (X.preventDefault(), Le ? Sn(X) : mn(X));
    }, co = (X) => {
      const { exponential: Le, controls: qe } = e;
      if (L.value) {
        const bt = X.ctrlKey, It = X.shiftKey, Kt = X.altKey, Ft = X.keyCode, Je = ut.hasKey(X, Yt.ESCAPE), Vt = ut.hasKey(X, Yt.ARROW_UP), un = ut.hasKey(X, Yt.ARROW_DOWN);
        !bt && !It && !Kt && (ut.hasKey(X, Yt.SPACEBAR) || (!Le || Ft !== 69) && Ft >= 65 && Ft <= 90 || Ft >= 186 && Ft <= 188 || Ft >= 191) && X.preventDefault(), Je ? on() : (Vt || un) && qe && Fn(X);
      }
      ct(X);
    }, Uo = (X) => {
      ct(X);
    }, Qn = () => {
      const { dnTimeout: X } = D;
      X && (clearTimeout(X), D.dnTimeout = void 0);
    }, ho = (X) => {
      D.dnTimeout = window.setTimeout(() => {
        Sn(X), ho(X);
      }, 60);
    }, Co = (X) => {
      if (Qn(), X.button === 0) {
        const Le = ta(X.currentTarget, "is--prev");
        Le ? Sn(X) : mn(X), D.dnTimeout = window.setTimeout(() => {
          Le ? ho(X) : gn(X);
        }, 500);
      }
    }, Oo = (X) => {
      if (L.value && e.controls && v.isActivated) {
        const qe = X.deltaY;
        qe > 0 ? mn(X) : qe < 0 && Sn(X), X.preventDefault();
      }
      ct(X);
    }, Po = (X, Le) => {
      v.selectMonth = r.getWhatMonth(X, Le, "first");
    }, Ys = () => {
      const X = r.getWhatDay(Date.now(), 0, "first");
      v.currentDate = X, Po(X, 0);
    }, Fs = () => {
      let { datePanelType: X } = v;
      X === "month" || X === "quarter" ? X = "year" : X = "month", v.datePanelType = X;
    }, ms = (X) => {
      const { type: Le } = e, { datePanelType: qe, selectMonth: gt, inputValue: bt } = v, { yearSize: It } = D, Kt = bt;
      if (!Oe.value) {
        let Je;
        Le === "year" ? Je = r.getWhatYear(gt, -It, "first") : Le === "month" || Le === "quarter" ? qe === "year" ? Je = r.getWhatYear(gt, -It, "first") : Je = r.getWhatYear(gt, -1, "first") : qe === "year" ? Je = r.getWhatYear(gt, -It, "first") : qe === "month" ? Je = r.getWhatYear(gt, -1, "first") : Je = r.getWhatMonth(gt, -1, "first"), v.selectMonth = Je, C.dispatchEvent("date-prev", { viewType: qe, viewDate: Je, value: Kt, type: Le }, X);
      }
    }, xr = (X) => {
      Ys(), e.multiple || (Lt(v.currentDate), At()), C.dispatchEvent("date-today", { type: e.type }, X);
    }, Es = (X) => {
      const { type: Le } = e, { datePanelType: qe, selectMonth: gt, inputValue: bt } = v, { yearSize: It } = D, Kt = bt;
      if (!Se.value) {
        let Je;
        Le === "year" ? Je = r.getWhatYear(gt, It, "first") : Le === "month" || Le === "quarter" ? qe === "year" ? Je = r.getWhatYear(gt, It, "first") : Je = r.getWhatYear(gt, 1, "first") : qe === "year" ? Je = r.getWhatYear(gt, It, "first") : qe === "month" ? Je = r.getWhatYear(gt, 1, "first") : Je = r.getWhatMonth(gt, 1, "first"), v.selectMonth = Je, C.dispatchEvent("date-next", { viewType: qe, viewDate: Je, value: Kt, type: Le }, X);
      }
    }, oo = (X) => {
      const { disabledMethod: Le } = e, { datePanelType: qe } = v, gt = A.value, bt = j.value, { date: It } = X;
      return gt && gt.getTime() > It.getTime() || bt && bt.getTime() < It.getTime() ? !0 : Le ? Le({ type: qe, viewType: qe, date: It, $input: E }) : !1;
    }, Bo = (X) => {
      const { type: Le, multiple: qe } = e, { datePanelType: gt } = v;
      Le === "month" ? gt === "year" ? (v.datePanelType = "month", U(X)) : (Lt(X), qe || At()) : Le === "year" ? (Lt(X), qe || At()) : Le === "quarter" ? gt === "year" ? (v.datePanelType = "quarter", U(X)) : (Lt(X), qe || At()) : gt === "month" ? (v.datePanelType = Le === "week" ? Le : "day", U(X)) : gt === "year" ? (v.datePanelType = "month", U(X)) : (Lt(X), Le === "datetime" || qe || At());
    }, ko = (X) => {
      oo(X) || Bo(X.date);
    }, _o = (X) => {
      oo({ date: X }) || (Be.value.some((qe) => r.isDateSame(qe.date, X, "yyyyMMdd")) || U(X), rt(X));
    }, ts = (X) => {
      oo({ date: X }) || (Ue.value.some((qe) => r.isDateSame(qe.date, X, "yyyy")) || U(X), rt(X));
    }, Kn = (X) => {
      oo({ date: X }) || (Et.value.some((qe) => r.isDateSame(qe.date, X, "yyyyq")) || U(X), rt(X));
    }, $o = (X) => {
      oo({ date: X }) || (De.value.some((qe) => r.isDateSame(qe.date, X, "yyyyMM")) || U(X), rt(X));
    }, Wo = (X) => {
      if (!oo(X)) {
        const { datePanelType: Le } = v;
        Le === "month" ? $o(X.date) : Le === "quarter" ? Kn(X.date) : Le === "year" ? ts(X.date) : _o(X.date);
      }
    }, Go = (X) => {
      if (X) {
        const Le = X.offsetHeight, qe = X.parentNode;
        qe.scrollTop = X.offsetTop - Le * 4;
      }
    }, Xs = (X) => {
      v.datetimePanelValue = new Date(v.datetimePanelValue.getTime()), Go(X.currentTarget);
    }, yr = (X, Le) => {
      v.datetimePanelValue.setHours(Le.value), Xs(X);
    }, ns = () => {
      const { multiple: X } = e, { datetimePanelValue: Le } = v, qe = ge.value, gt = K.value;
      if (gt) {
        const bt = J.value;
        if (X) {
          const It = ne.value;
          if (gt) {
            const Kt = [...pe.value], Ft = [];
            Kt.forEach((Je) => {
              Je && (Je.setHours(Le.getHours()), Je.setMinutes(Le.getMinutes()), Je.setSeconds(Le.getSeconds()), Ft.push(Je));
            }), Ke(Ft.map((Je) => r.toDateString(Je, bt)).join(","), { type: "update" });
          } else
            Ke(It.join(","), { type: "update" });
        } else
          Lt(qe || v.currentDate);
      }
      At();
    }, zr = (X, Le) => {
      v.datetimePanelValue.setMinutes(Le.value), Xs(X);
    }, mo = (X, Le) => {
      v.datetimePanelValue.setSeconds(Le.value), Xs(X);
    }, ae = (X) => {
      const { isActivated: Le, datePanelValue: qe, datePanelType: gt } = v;
      if (Le) {
        X.preventDefault();
        const bt = ut.hasKey(X, Yt.ARROW_LEFT), It = ut.hasKey(X, Yt.ARROW_UP), Kt = ut.hasKey(X, Yt.ARROW_RIGHT), Ft = ut.hasKey(X, Yt.ARROW_DOWN);
        if (gt === "year") {
          let Je = r.getWhatYear(qe || Date.now(), 0, "first");
          bt ? Je = r.getWhatYear(Je, -1) : It ? Je = r.getWhatYear(Je, -4) : Kt ? Je = r.getWhatYear(Je, 1) : Ft && (Je = r.getWhatYear(Je, 4)), ts(Je);
        } else if (gt === "quarter") {
          let Je = r.getWhatQuarter(qe || Date.now(), 0, "first");
          bt ? Je = r.getWhatQuarter(Je, -1) : It ? Je = r.getWhatQuarter(Je, -2) : Kt ? Je = r.getWhatQuarter(Je, 1) : Ft && (Je = r.getWhatQuarter(Je, 2)), Kn(Je);
        } else if (gt === "month") {
          let Je = r.getWhatMonth(qe || Date.now(), 0, "first");
          bt ? Je = r.getWhatMonth(Je, -1) : It ? Je = r.getWhatMonth(Je, -4) : Kt ? Je = r.getWhatMonth(Je, 1) : Ft && (Je = r.getWhatMonth(Je, 4)), $o(Je);
        } else {
          let Je = qe || r.getWhatDay(Date.now(), 0, "first");
          const Vt = _e.value;
          bt ? Je = r.getWhatDay(Je, -1) : It ? Je = r.getWhatWeek(Je, -1, Vt) : Kt ? Je = r.getWhatDay(Je, 1) : Ft && (Je = r.getWhatWeek(Je, 1, Vt)), _o(Je);
        }
      }
    }, We = (X) => {
      const { isActivated: Le } = v;
      if (Le) {
        const qe = ut.hasKey(X, Yt.PAGE_UP);
        X.preventDefault(), qe ? ms(X) : Es(X);
      }
    }, Ze = () => {
      const { type: X } = e, Le = K.value, qe = ge.value;
      ["year", "quarter", "month", "week"].indexOf(X) > -1 ? v.datePanelType = X : v.datePanelType = "day", v.currentDate = r.getWhatDay(Date.now(), 0, "first"), qe ? (Po(qe, 0), rt(qe)) : Ys(), Le && (v.datetimePanelValue = v.datePanelValue || r.getWhatDay(Date.now(), 0, "first"), me(() => {
        const gt = g.value;
        r.arrayEach(gt.querySelectorAll("li.is--selected"), (bt) => {
          Go(bt);
        });
      }));
    }, ft = () => {
      v.panelIndex < ws() && (v.panelIndex = ds());
    }, $t = () => me().then(() => {
      const { placement: X } = e, { panelIndex: Le } = v, qe = x.value, gt = h.value, bt = Q.value;
      if (qe && gt) {
        const It = qe.offsetHeight, Kt = qe.offsetWidth, Ft = gt.offsetHeight, Je = gt.offsetWidth, Vt = 5, un = {
          zIndex: Le
        }, { boundingTop: vn, boundingLeft: qn, visibleHeight: Ro, visibleWidth: Ko } = br(qe);
        let wo = "bottom";
        if (bt) {
          let eo = qn, os = vn + It;
          X === "top" ? (wo = "top", os = vn - Ft) : X || (os + Ft + Vt > Ro && (wo = "top", os = vn - Ft), os < Vt && (wo = "bottom", os = vn + It)), eo + Je + Vt > Ko && (eo -= eo + Je + Vt - Ko), eo < Vt && (eo = Vt), Object.assign(un, {
            left: `${eo}px`,
            top: `${os}px`,
            minWidth: `${Kt}px`
          });
        } else
          X === "top" ? (wo = "top", un.bottom = `${It}px`) : X || (un.top = `${It}px`, vn + It + Ft > Ro && vn - It - Ft > Vt && (wo = "top", un.top = "", un.bottom = `${It}px`));
        return v.panelStyle = un, v.panelPlacement = wo, me();
      }
    }), Mt = () => {
      const { visiblePanel: X } = v, { hpTimeout: Le } = D, qe = ue.value, gt = P.value;
      return !qe && !X ? (v.initialized || (v.initialized = !0), Le && (clearTimeout(Le), D.hpTimeout = void 0), v.isActivated = !0, v.isAniVisible = !0, gt && Ze(), setTimeout(() => {
        v.visiblePanel = !0;
      }, 10), ft(), $t()) : me();
    }, jt = (X) => {
      G.value || (X.preventDefault(), Mt());
    }, qt = (X) => {
      ct(X);
    }, tt = (X) => {
      const { visiblePanel: Le, isActivated: qe } = v, gt = P.value, bt = S.value, It = O.value;
      !ue.value && qe && (v.isActivated = jn(X, bt).flag || jn(X, It).flag, v.isActivated || (gt ? Le && (At(), on()) : on()));
    }, _t = (X) => {
      const { clearable: Le } = e, { visiblePanel: qe } = v, gt = ue.value, bt = P.value;
      if (!gt) {
        const It = ut.hasKey(X, Yt.TAB), Kt = ut.hasKey(X, Yt.DELETE), Ft = ut.hasKey(X, Yt.ESCAPE), Je = ut.hasKey(X, Yt.ENTER), Vt = ut.hasKey(X, Yt.ARROW_LEFT), un = ut.hasKey(X, Yt.ARROW_UP), vn = ut.hasKey(X, Yt.ARROW_RIGHT), qn = ut.hasKey(X, Yt.ARROW_DOWN), Ro = ut.hasKey(X, Yt.PAGE_UP), Ko = ut.hasKey(X, Yt.PAGE_DOWN), wo = Vt || un || vn || qn;
        let eo = v.isActivated;
        It ? (eo && on(), eo = !1, v.isActivated = eo) : wo ? bt && eo && (qe ? ae(X) : (un || qn) && jt(X)) : Je ? bt && (qe ? v.datePanelValue ? Bo(v.datePanelValue) : At() : eo && jt(X)) : (Ro || Ko) && bt && eo && We(X), It || Ft ? qe && At() : Kt && Le && eo && Ee(X, null);
      }
    }, In = (X) => {
      const { visiblePanel: Le } = v;
      if (!ue.value && Le) {
        const gt = O.value;
        jn(X, gt).flag ? $t() : (At(), on());
      }
    }, yn = () => {
      const { isActivated: X, visiblePanel: Le } = v;
      Le ? (At(), on()) : X && on();
    }, Rn = (X, Le) => {
      const { festivalMethod: qe } = e;
      if (qe) {
        const { datePanelType: gt } = v, bt = qe({ type: gt, viewType: gt, date: X.date, $input: E }), It = bt ? r.isString(bt) ? { label: bt } : bt : {}, Kt = It.extra ? r.isString(It.extra) ? { label: It.extra } : It.extra : null, Ft = [
          o("span", {
            class: ["vxe-input--date-label", {
              "is-notice": It.notice
            }]
          }, Kt && Kt.label ? [
            o("span", `${Le || ""}`),
            o("span", {
              class: ["vxe-input--date-label--extra", Kt.important ? "is-important" : "", Kt.className],
              style: Kt.style
            }, r.toValueString(Kt.label))
          ] : [`${Le || ""}`])
        ], Je = It.label;
        if (Je) {
          const Vt = r.toValueString(Je).split(",");
          Ft.push(o("span", {
            class: ["vxe-input--date-festival", It.important ? "is-important" : "", It.className],
            style: It.style
          }, [
            Vt.length > 1 ? o("span", {
              class: ["vxe-input--date-festival--overlap", `overlap--${Vt.length}`]
            }, Vt.map((un) => o("span", un.substring(0, 3)))) : o("span", {
              class: "vxe-input--date-festival--label"
            }, Vt[0].substring(0, 3))
          ]));
        }
        return Ft;
      }
      return [`${Le || ""}`];
    }, To = () => {
      const { multiple: X } = e, { datePanelType: Le, datePanelValue: qe } = v, gt = ge.value, bt = vt.value, It = ve.value, Kt = pe.value, Ft = "yyyyMMdd";
      return [
        o("table", {
          class: `vxe-input--date-${Le}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("thead", [
            o("tr", bt.map((Je) => o("th", Je.label)))
          ]),
          o("tbody", It.map((Je) => o("tr", Je.map((Vt) => o("td", {
            class: {
              "is--prev": Vt.isPrev,
              "is--current": Vt.isCurrent,
              "is--now": Vt.isNow,
              "is--next": Vt.isNext,
              "is--disabled": oo(Vt),
              "is--selected": X ? Kt.some((un) => r.isDateSame(un, Vt.date, Ft)) : r.isDateSame(gt, Vt.date, Ft),
              "is--hover": r.isDateSame(qe, Vt.date, Ft)
            },
            onClick: () => ko(Vt),
            onMouseenter: () => Wo(Vt)
          }, Rn(Vt, Vt.label))))))
        ])
      ];
    }, vo = () => {
      const { multiple: X } = e, { datePanelType: Le, datePanelValue: qe } = v, gt = ge.value, bt = dt.value, It = Ne.value, Kt = pe.value, Ft = "yyyyMMdd";
      return [
        o("table", {
          class: `vxe-input--date-${Le}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("thead", [
            o("tr", bt.map((Je) => o("th", Je.label)))
          ]),
          o("tbody", It.map((Je) => {
            const Vt = X ? Je.some((vn) => Kt.some((qn) => r.isDateSame(qn, vn.date, Ft))) : Je.some((vn) => r.isDateSame(gt, vn.date, Ft)), un = Je.some((vn) => r.isDateSame(qe, vn.date, Ft));
            return o("tr", Je.map((vn) => o("td", {
              class: {
                "is--prev": vn.isPrev,
                "is--current": vn.isCurrent,
                "is--now": vn.isNow,
                "is--next": vn.isNext,
                "is--disabled": oo(vn),
                "is--selected": Vt,
                "is--hover": un
              },
              // event
              onClick: () => ko(vn),
              onMouseenter: () => Wo(vn)
            }, Rn(vn, vn.label))));
          }))
        ])
      ];
    }, go = () => {
      const { multiple: X } = e, { datePanelType: Le, datePanelValue: qe } = v, gt = ge.value, bt = Re.value, It = pe.value, Kt = "yyyyMM";
      return [
        o("table", {
          class: `vxe-input--date-${Le}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tbody", bt.map((Ft) => o("tr", Ft.map((Je) => o("td", {
            class: {
              "is--prev": Je.isPrev,
              "is--current": Je.isCurrent,
              "is--now": Je.isNow,
              "is--next": Je.isNext,
              "is--disabled": oo(Je),
              "is--selected": X ? It.some((Vt) => r.isDateSame(Vt, Je.date, Kt)) : r.isDateSame(gt, Je.date, Kt),
              "is--hover": r.isDateSame(qe, Je.date, Kt)
            },
            onClick: () => ko(Je),
            onMouseenter: () => Wo(Je)
          }, Rn(Je, Pe(`vxe.input.date.months.m${Je.month}`)))))))
        ])
      ];
    }, Xn = () => {
      const { multiple: X } = e, { datePanelType: Le, datePanelValue: qe } = v, gt = ge.value, bt = Qe.value, It = pe.value, Kt = "yyyyq";
      return [
        o("table", {
          class: `vxe-input--date-${Le}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tbody", bt.map((Ft) => o("tr", Ft.map((Je) => o("td", {
            class: {
              "is--prev": Je.isPrev,
              "is--current": Je.isCurrent,
              "is--now": Je.isNow,
              "is--next": Je.isNext,
              "is--disabled": oo(Je),
              "is--selected": X ? It.some((Vt) => r.isDateSame(Vt, Je.date, Kt)) : r.isDateSame(gt, Je.date, Kt),
              "is--hover": r.isDateSame(qe, Je.date, Kt)
            },
            onClick: () => ko(Je),
            onMouseenter: () => Wo(Je)
          }, Rn(Je, Pe(`vxe.input.date.quarters.q${Je.quarter}`)))))))
        ])
      ];
    }, bo = () => {
      const { multiple: X } = e, { datePanelType: Le, datePanelValue: qe } = v, gt = ge.value, bt = at.value, It = pe.value, Kt = "yyyy";
      return [
        o("table", {
          class: `vxe-input--date-${Le}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          o("tbody", bt.map((Ft) => o("tr", Ft.map((Je) => o("td", {
            class: {
              "is--prev": Je.isPrev,
              "is--current": Je.isCurrent,
              "is--now": Je.isNow,
              "is--next": Je.isNext,
              "is--disabled": oo(Je),
              "is--selected": X ? It.some((Vt) => r.isDateSame(Vt, Je.date, Kt)) : r.isDateSame(gt, Je.date, Kt),
              "is--hover": r.isDateSame(qe, Je.date, Kt)
            },
            onClick: () => ko(Je),
            onMouseenter: () => Wo(Je)
          }, Rn(Je, Je.year))))))
        ])
      ];
    }, Zs = () => {
      const { datePanelType: X } = v;
      switch (X) {
        case "week":
          return vo();
        case "month":
          return go();
        case "quarter":
          return Xn();
        case "year":
          return bo();
      }
      return To();
    }, Jl = () => {
      const { multiple: X } = e, { datePanelType: Le } = v, qe = Oe.value, gt = Se.value, bt = Ae.value;
      return [
        o("div", {
          class: "vxe-input--date-picker-header"
        }, [
          o("div", {
            class: "vxe-input--date-picker-type-wrapper"
          }, [
            Le === "year" ? o("span", {
              class: "vxe-input--date-picker-label"
            }, bt) : o("span", {
              class: "vxe-input--date-picker-btn",
              onClick: Fs
            }, bt)
          ]),
          o("div", {
            class: "vxe-input--date-picker-btn-wrapper"
          }, [
            o("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-prev-btn", {
                "is--disabled": qe
              }],
              onClick: ms
            }, [
              o("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            o("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-current-btn",
              onClick: xr
            }, [
              o("i", {
                class: "vxe-icon-dot"
              })
            ]),
            o("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-next-btn", {
                "is--disabled": gt
              }],
              onClick: Es
            }, [
              o("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            X && fe.value ? o("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn"
            }, [
              o("button", {
                class: "vxe-input--date-picker-confirm",
                type: "button",
                onClick: ns
              }, Pe("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        o("div", {
          class: "vxe-input--date-picker-body"
        }, Zs())
      ];
    }, sa = () => {
      const { datetimePanelValue: X } = v, Le = de.value, qe = q.value, gt = R.value, bt = z.value, It = le.value, Kt = F.value;
      return [
        o("div", {
          class: "vxe-input--time-picker-header"
        }, [
          gt ? o("span", {
            class: "vxe-input--time-picker-title"
          }, Le) : Ve(),
          o("div", {
            class: "vxe-input--time-picker-btn"
          }, [
            o("button", {
              class: "vxe-input--time-picker-confirm",
              type: "button",
              onClick: ns
            }, Pe("vxe.button.confirm"))
          ])
        ]),
        o("div", {
          ref: g,
          class: "vxe-input--time-picker-body"
        }, [
          o("ul", {
            class: "vxe-input--time-picker-hour-list"
          }, qe.map((Ft, Je) => o("li", {
            key: Je,
            class: {
              "is--selected": X && X.getHours() === Ft.value
            },
            onClick: (Vt) => yr(Vt, Ft)
          }, Ft.label))),
          gt ? o("ul", {
            class: "vxe-input--time-picker-minute-list"
          }, bt.map((Ft, Je) => o("li", {
            key: Je,
            class: {
              "is--selected": X && X.getMinutes() === Ft.value
            },
            onClick: (Vt) => zr(Vt, Ft)
          }, Ft.label))) : Ve(),
          gt && It ? o("ul", {
            class: "vxe-input--time-picker-second-list"
          }, Kt.map((Ft, Je) => o("li", {
            key: Je,
            class: {
              "is--selected": X && X.getSeconds() === Ft.value
            },
            onClick: (Vt) => mo(Vt, Ft)
          }, Ft.label))) : Ve()
        ])
      ];
    }, ra = () => {
      const { type: X } = e, { initialized: Le, isAniVisible: qe, visiblePanel: gt, panelPlacement: bt, panelStyle: It } = v, Kt = w.value, Ft = Q.value, Je = P.value, Vt = [];
      return Je ? (X === "datetime" ? Vt.push(o("div", {
        key: X,
        ref: O,
        class: "vxe-input--panel-layout-wrapper"
      }, [
        o("div", {
          class: "vxe-input--panel-left-wrapper"
        }, Jl()),
        o("div", {
          class: "vxe-input--panel-right-wrapper"
        }, sa())
      ])) : X === "time" ? Vt.push(o("div", {
        key: X,
        ref: O,
        class: "vxe-input--panel-wrapper"
      }, sa())) : Vt.push(o("div", {
        key: X || "default",
        ref: O,
        class: "vxe-input--panel-wrapper"
      }, Jl())), o(ks, {
        to: "body",
        disabled: Ft ? !Le : !0
      }, [
        o("div", {
          ref: h,
          class: ["vxe-table--ignore-clear vxe-input--panel", `type--${X}`, {
            [`size--${Kt}`]: Kt,
            "is--transfer": Ft,
            "ani--leave": qe,
            "ani--enter": gt
          }],
          placement: bt,
          style: It
        }, gt || qe ? Vt : [])
      ])) : Ve();
    }, cl = () => {
      const X = ze.value, Le = Te.value;
      return o("div", {
        class: "vxe-input--control-icon"
      }, [
        o("div", {
          class: "vxe-input--number-icon"
        }, [
          o("div", {
            class: ["vxe-input--number-btn is--prev", {
              "is--disabled": X
            }],
            onMousedown: Co,
            onMouseup: Qn,
            onMouseleave: Qn
          }, [
            o("i", {
              class: ht().NUMBER_INPUT_PREV_NUM
            })
          ]),
          o("div", {
            class: ["vxe-input--number-btn is--next", {
              "is--disabled": Le
            }],
            onMousedown: Co,
            onMouseup: Qn,
            onMouseleave: Qn
          }, [
            o("i", {
              class: ht().NUMBER_INPUT_NEXT_NUM
            })
          ])
        ])
      ]);
    }, la = () => o("div", {
      class: "vxe-input--control-icon",
      onClick: jt
    }, [
      o("i", {
        class: ["vxe-input--date-picker-icon", ht().DATE_PICKER_DATE]
      })
    ]), Zc = () => o("div", {
      class: "vxe-input--control-icon",
      onClick: hn
    }, [
      o("i", {
        class: ["vxe-input--search-icon", ht().INPUT_SEARCH]
      })
    ]), ia = () => {
      const { showPwd: X } = v;
      return o("div", {
        class: "vxe-input--control-icon",
        onClick: en
      }, [
        o("i", {
          class: ["vxe-input--password-icon", X ? ht().PASSWORD_INPUT_SHOW_PWD : ht().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    }, Ql = () => {
      const { prefixIcon: X } = e, Le = n.prefix;
      return Le || X ? o("div", {
        class: "vxe-input--prefix",
        onClick: zt
      }, [
        o("div", {
          class: "vxe-input--prefix-icon"
        }, Le ? Nt(Le({})) : [
          o("i", {
            class: X
          })
        ])
      ]) : null;
    }, ul = () => {
      const { suffixIcon: X } = e, { inputValue: Le } = v, qe = n.suffix, gt = ue.value, bt = L.value, It = P.value, Kt = M.value, Ft = I.value, Je = ce.value, Vt = Kt || bt || It || Ft;
      return Je || qe || X || Vt ? o("div", {
        class: ["vxe-input--suffix", {
          "is--clear": Je && !gt && !(Le === "" || r.eqNull(Le))
        }]
      }, [
        Je ? o("div", {
          class: "vxe-input--clear-icon",
          onClick: Ee
        }, [
          o("i", {
            class: ht().INPUT_CLEAR
          })
        ]) : Ve(),
        Vt ? ei() : Ve(),
        qe || X ? o("div", {
          class: "vxe-input--suffix-icon",
          onClick: Ye
        }, qe ? Nt(qe({})) : [
          o("i", {
            class: X
          })
        ]) : Ve()
      ]) : null;
    }, ei = () => {
      const { controls: X } = e, Le = L.value, qe = P.value, gt = M.value, bt = I.value;
      return gt ? ia() : Le && X ? cl() : qe ? la() : bt ? Zc() : Ve();
    };
    C = {
      dispatchEvent: (X, Le, qe) => {
        s(X, Zt(qe, { $input: E }, Le));
      },
      focus() {
        const X = x.value;
        return v.isActivated = !0, X.focus(), me();
      },
      blur() {
        return x.value.blur(), v.isActivated = !1, me();
      },
      select() {
        return x.value.select(), v.isActivated = !1, me();
      },
      showPanel: Mt,
      hidePanel: At,
      updatePlacement: $t
    }, Object.assign(E, C);
    const Jc = () => {
      const { className: X, controls: Le, type: qe, align: gt, showWordCount: bt, countMethod: It, name: Kt, autoComplete: Ft, autocomplete: Je } = e, { inputValue: Vt, visiblePanel: un, isActivated: vn } = v, qn = w.value, Ro = ue.value;
      if (Z.value)
        return o("div", {
          ref: S,
          class: ["vxe-input--readonly", `type--${qe}`, X]
        }, Vt);
      const wo = se.value, eo = ye.value, os = re.value, Cr = Y.value, Qc = N.value, ti = ee.value, eu = ce.value, Hr = bt && ["text", "search"].includes(qe), Js = Ql(), dl = ul();
      return o("div", {
        ref: S,
        class: ["vxe-input", `type--${qe}`, X, {
          [`size--${qn}`]: qn,
          [`is--${gt}`]: gt,
          "is--controls": Le,
          "is--prefix": !!Js,
          "is--suffix": !!dl,
          "is--visible": un,
          "is--count": Hr,
          "is--disabled": Ro,
          "is--active": vn,
          "show--clear": eu && !Ro && !(Vt === "" || r.eqNull(Vt))
        }],
        spellcheck: !1
      }, [
        Js || Ve(),
        o("div", {
          class: "vxe-input--wrapper"
        }, [
          o("input", {
            ref: x,
            class: "vxe-input--inner",
            value: Vt,
            name: Kt,
            type: Qc,
            placeholder: ti,
            maxlength: Cr,
            readonly: os,
            disabled: Ro,
            autocomplete: Ft || Je,
            onKeydown: co,
            onKeyup: Uo,
            onWheel: Oo,
            onClick: qt,
            onInput: St,
            onChange: Dt,
            onFocus: nn,
            onBlur: Wt
          })
        ]),
        dl || Ve(),
        // 下拉面板
        ra(),
        // 字数统计
        Hr ? o("span", {
          class: ["vxe-input--count", {
            "is--error": wo
          }]
        }, It ? `${It({ value: Vt })}` : `${eo}${Cr ? `/${Cr}` : ""}`) : Ve()
      ]);
    };
    return lt(() => e.modelValue, (X) => {
      v.inputValue = X, Ot();
    }), lt(() => e.type, () => {
      Object.assign(v, {
        inputValue: e.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      }), Jt();
    }), lt(je, () => {
      P.value && (rt(v.datePanelValue), v.inputValue = e.multiple ? $.value : v.datePanelLabel);
    }), wn(() => {
      ut.on(E, "mousewheel", In), ut.on(E, "mousedown", tt), ut.on(E, "keydown", _t), ut.on(E, "blur", yn);
    }), Us(() => {
      Qn(), on(), ut.off(E, "mousewheel"), ut.off(E, "mousedown"), ut.off(E, "keydown"), ut.off(E, "blur");
    }), Jt(), E.renderVN = Jc, E;
  },
  render() {
    return this.renderVN();
  }
}), Mi = pt({
  name: "VxeRadio",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    name: String,
    strict: {
      type: Boolean,
      default: () => oe().radio.strict
    },
    size: {
      type: String,
      default: () => oe().radio.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeForm", null), l = mt("xeFormItemInfo", null), a = mt("$xeRadioGroup", null), c = r.uniqueId(), m = Rt({}), u = {
      xID: c,
      props: e,
      context: t,
      reactData: m
    }, { computeSize: d } = dn(e), p = _(() => {
      const { disabled: C } = e;
      if (C === null && a) {
        const { computeIsDisabled: V } = a.getComputeMaps();
        return V.value;
      }
      return C;
    }), w = _(() => a ? a.name : e.name), v = _(() => a ? a.props.strict : e.strict), D = _(() => {
      const { label: C } = e;
      return a ? a.props.modelValue === C : e.modelValue === C;
    }), S = (C, V) => {
      a ? a.handleChecked({ label: C }, V) : (s("update:modelValue", C), O("change", { label: C }, V), i && l && i.triggerItemEvent(V, l.itemConfig.field, C));
    }, x = (C) => {
      p.value || S(e.label, C);
    }, h = (C) => {
      const V = p.value, Q = v.value;
      !V && !Q && e.label === (a ? a.props.modelValue : e.modelValue) && S(null, C);
    }, O = (C, V, Q) => {
      s(C, Zt(Q, { $radio: u }, V));
    };
    Object.assign(u, {
      dispatchEvent: O
    }, {});
    const E = () => {
      const C = d.value, V = p.value, Q = w.value, Z = D.value;
      return o("label", {
        class: ["vxe-radio", {
          [`size--${C}`]: C,
          "is--checked": Z,
          "is--disabled": V
        }],
        title: e.title
      }, [
        o("input", {
          class: "vxe-radio--input",
          type: "radio",
          name: Q,
          checked: Z,
          disabled: V,
          onChange: x,
          onClick: h
        }),
        o("span", {
          class: ["vxe-radio--icon", Z ? ht().RADIO_CHECKED : ht().RADIO_UNCHECKED]
        }),
        o("span", {
          class: "vxe-radio--label"
        }, n.default ? n.default({}) : Bn(e.content))
      ]);
    };
    return u.renderVN = E, u;
  },
  render() {
    return this.renderVN();
  }
}), Ii = pt({
  name: "VxeRadioButton",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    strict: {
      type: Boolean,
      default: () => oe().radioButton.strict
    },
    size: {
      type: String,
      default: () => oe().radioButton.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeForm", null), l = mt("xeFormItemInfo", null), a = mt("$xeRadioGroup", null), c = r.uniqueId(), m = Rt({}), { computeSize: u } = dn(e), d = {
      xID: c,
      props: e,
      context: t,
      reactData: m
    }, p = _(() => {
      const { disabled: E } = e;
      if (E === null && a) {
        const { computeIsDisabled: C } = a.getComputeMaps();
        return C.value;
      }
      return E;
    }), w = _(() => a ? a.name : null), v = _(() => a ? a.props.strict : e.strict), D = _(() => {
      const { label: E } = e;
      return a ? a.props.modelValue === E : e.modelValue === E;
    }), S = {
      dispatchEvent(E, C, V) {
        s(E, Zt(V, { $radioButton: d }, C));
      }
    };
    Object.assign(d, S, {});
    const h = (E, C) => {
      a ? a.handleChecked({ label: E }, C) : (s("update:modelValue", E), S.dispatchEvent("change", { label: E }, C), i && l && i.triggerItemEvent(C, l.itemConfig.field, E));
    }, O = (E) => {
      p.value || h(e.label, E);
    }, g = (E) => {
      const C = p.value, V = v.value;
      !C && !V && e.label === (a ? a.props.modelValue : e.modelValue) && h(null, E);
    }, b = () => {
      const E = u.value, C = p.value, V = w.value, Q = D.value;
      return o("label", {
        class: ["vxe-radio", "vxe-radio-button", {
          [`size--${E}`]: E,
          "is--disabled": C
        }],
        title: e.title
      }, [
        o("input", {
          class: "vxe-radio--input",
          type: "radio",
          name: V,
          checked: Q,
          disabled: C,
          onChange: O,
          onClick: g
        }),
        o("span", {
          class: "vxe-radio--label"
        }, n.default ? n.default({}) : Bn(e.content))
      ]);
    };
    return d.renderVN = b, b;
  }
}), Jo = pt({
  name: "VxeRadioGroup",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    type: String,
    options: Array,
    optionProps: Object,
    strict: {
      type: Boolean,
      default: () => oe().radioGroup.strict
    },
    size: {
      type: String,
      default: () => oe().radioGroup.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeForm", null), l = mt("xeFormItemInfo", null), a = r.uniqueId();
    dn(e);
    const c = Rt({}), u = {
      computeIsDisabled: _(() => {
        const { disabled: g } = e;
        return g === null ? i ? i.props.readonly || i.props.disabled : !1 : g;
      })
    }, d = {
      xID: a,
      props: e,
      context: t,
      reactData: c,
      name: r.uniqueId("xe_group_"),
      getComputeMaps: () => u
    }, p = _(() => Object.assign({}, e.optionProps)), w = _(() => p.value.label || "label"), v = _(() => p.value.value || "value"), D = _(() => p.value.disabled || "disabled"), S = (g, b, E) => {
      s(g, Zt(E, { $radioGroup: d }, b));
    };
    Object.assign(d, {
      dispatchEvent: S
    }, {
      handleChecked(g, b) {
        const E = g.label;
        s("update:modelValue", E), S("change", g, b), i && l && i.triggerItemEvent(b, l.itemConfig.field, E);
      }
    });
    const O = () => {
      const { options: g, type: b } = e, E = n.default, C = v.value, V = w.value, Q = D.value, Z = b === "button" ? Ii : Mi;
      return o("div", {
        class: "vxe-radio-group"
      }, E ? E({}) : g ? g.map((G) => o(Z, {
        label: G[C],
        content: G[V],
        disabled: G[Q]
      })) : []);
    };
    return bn("$xeRadioGroup", d), d.renderVN = O, d;
  },
  render() {
    return this.renderVN();
  }
});
function Ta(e) {
  return e.visible !== !1;
}
function n0() {
  return r.uniqueId("opt_");
}
const vs = pt({
  name: "VxeSelect",
  props: {
    modelValue: [String, Number, Boolean, Array],
    clearable: Boolean,
    placeholder: String,
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    multiCharOverflow: {
      type: [Number, String],
      default: () => oe().select.multiCharOverflow
    },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => oe().select.size || oe().size
    },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    transfer: {
      type: Boolean,
      default: null
    },
    scrollY: Object,
    // 已废弃，被 option-config.keyField 替换
    optionId: {
      type: String,
      default: () => oe().select.optionId
    },
    // 已废弃，被 option-config.useKey 替换
    optionKey: Boolean
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "scroll"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeModal", null), l = mt("$xeDrawer", null), a = mt("$xeTable", null), c = mt("$xeForm", null), m = mt("xeFormItemInfo", null), u = r.uniqueId(), d = ke(), p = ke(), w = ke(), v = ke(), D = ke(), S = ke(), { computeSize: x } = dn(e), h = Rt({
      initialized: !1,
      scrollYLoad: !1,
      bodyHeight: 0,
      topSpaceHeight: 0,
      optList: [],
      afterVisibleList: [],
      staticOptions: [],
      reactFlag: 0,
      currentOption: null,
      searchValue: "",
      searchLoading: !1,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: !1,
      visiblePanel: !1,
      isAniVisible: !1,
      isActivated: !1
    }), O = {
      synchData: [],
      fullData: [],
      optGroupKeyMaps: {},
      optFullValMaps: {},
      remoteValMaps: {},
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      },
      lastScrollTime: 0,
      hpTimeout: void 0
    }, g = {
      refElem: d
    }, b = {
      xID: u,
      props: e,
      context: t,
      reactData: h,
      internalData: O,
      getRefMaps: () => g
    }, E = _(() => {
      const { readonly: Ee } = e;
      return Ee === null ? c ? c.props.readonly : !1 : Ee;
    }), C = _(() => {
      const { disabled: Ee } = e;
      return Ee === null ? c ? c.props.disabled : !1 : Ee;
    }), V = _(() => {
      const { transfer: Ee } = e;
      if (Ee === null) {
        const Ye = oe().select.transfer;
        if (r.isBoolean(Ye))
          return Ye;
        if (a || i || l || c)
          return !0;
      }
      return Ee;
    }), Q = _(() => {
      const { placeholder: Ee } = e;
      if (Ee)
        return Bn(Ee);
      const Ye = oe().select.placeholder;
      return Ye ? Bn(Ye) : Pe("vxe.base.pleaseSelect");
    }), Z = _(() => Object.assign({}, e.optionProps)), G = _(() => Object.assign({}, e.optionGroupProps)), ue = _(() => Z.value.label || "label"), Y = _(() => Z.value.value || "value"), K = _(() => G.value.label || "label"), L = _(() => G.value.options || "options"), ye = _(() => {
      const { modelValue: Ee, multiple: Ye, max: rt } = e;
      return Ye && rt ? (r.isArray(Ee) ? Ee.length : r.eqNull(Ee) ? 0 : 1) >= r.toNumber(rt) : !1;
    }), se = _(() => Object.assign({}, oe().select.scrollY, e.scrollY)), P = _(() => Object.assign({}, oe().select.optionConfig, e.optionConfig)), M = _(() => r.toNumber(e.multiCharOverflow)), I = _(() => {
      const { modelValue: Ee, remote: Ye, multiple: rt } = e, Ot = M.value;
      if (r.eqNull(Ee))
        return "";
      const Jt = r.isArray(Ee) ? Ee : [Ee];
      return Ye ? Jt.map((Bt) => fe(Bt)).join(", ") : Jt.map((Bt) => {
        const Gt = pe(Bt);
        return rt && Ot > 0 && Gt.length > Ot ? `${Gt.substring(0, Ot)}...` : Gt;
      }).join(", ");
    }), B = (Ee, Ye) => Ee && (r.isString(Ee) && (Ee = n[Ee] || null), r.isFunction(Ee)) ? Nt(Ee(Ye)) : [], H = (Ee, Ye, rt) => {
      s(Ee, Zt(rt, { $select: b }, Ye));
    }, ce = (Ee) => {
      s("update:modelValue", Ee);
    }, A = () => P.value.keyField || e.optionId || "_X_OPTION_KEY", j = (Ee) => {
      const Ye = Ee[A()];
      return Ye ? encodeURIComponent(Ye) : "";
    }, fe = (Ee) => {
      const { remoteValMaps: Ye } = O, rt = ue.value, Ot = Ye[Ee], Jt = Ot ? Ot.item : null;
      return r.toValueString(Jt ? Jt[rt] : Ee);
    }, pe = (Ee) => {
      const { optFullValMaps: Ye } = O, rt = ue.value, Ot = h.reactFlag ? Ye[Ee] : null;
      return Ot ? Ot.item[rt] : r.toValueString(Ee);
    }, ne = (Ee) => {
      const Ye = L.value, rt = Y.value, Ot = A(), Jt = {}, Bt = {}, Gt = [], Qt = (U) => {
        Gt.push(U);
        let Lt = j(U);
        Lt || (Lt = n0(), U[Ot] = Lt), Bt[U[rt]] = {
          key: Lt,
          item: U,
          _index: -1
        };
      };
      Ee.forEach((U) => {
        Qt(U), U[Ye] && (Jt[U[Ot]] = U, U[Ye].forEach(Qt));
      }), O.fullData = Gt, O.optGroupKeyMaps = Jt, O.optFullValMaps = Bt, h.reactFlag++, $();
    }, $ = () => {
      const { filterable: Ee, filterMethod: Ye } = e, { searchValue: rt } = h, { fullData: Ot, optFullValMaps: Jt } = O, Bt = ue.value, Gt = Y.value, Qt = `${rt || ""}`.toLowerCase();
      let U = [];
      return Ee && Ye ? U = Ot.filter((Lt) => Ta(Lt) && Ye({ group: null, option: Lt, searchValue: Qt })) : Ee ? U = Ot.filter((Lt) => Ta(Lt) && (!Qt || `${Lt[Bt]}`.toLowerCase().indexOf(Qt) > -1)) : U = Ot.filter(Ta), U.forEach((Lt, on) => {
        const en = Jt[Lt[Gt]];
        en && (en._index = on);
      }), h.afterVisibleList = U, me();
    }, J = (Ee) => {
      Ee && (h.currentOption = Ee);
    }, ge = () => {
      h.panelIndex < ws() && (h.panelIndex = ds());
    }, Oe = () => me().then(() => {
      const { placement: Ee } = e, { panelIndex: Ye } = h, rt = d.value, Ot = D.value, Jt = V.value;
      if (Ot && rt) {
        const Bt = rt.offsetHeight, Gt = rt.offsetWidth, Qt = Ot.offsetHeight, U = Ot.offsetWidth, Lt = 5, on = {
          zIndex: Ye
        }, { boundingTop: en, boundingLeft: hn, visibleHeight: En, visibleWidth: mn } = br(rt);
        let gn = "bottom";
        if (Jt) {
          let Sn = hn, Fn = en + Bt;
          Ee === "top" ? (gn = "top", Fn = en - Qt) : Ee || (Fn + Qt + Lt > En && (gn = "top", Fn = en - Qt), Fn < Lt && (gn = "bottom", Fn = en + Bt)), Sn + U + Lt > mn && (Sn -= Sn + U + Lt - mn), Sn < Lt && (Sn = Lt), Object.assign(on, {
            left: `${Sn}px`,
            top: `${Fn}px`,
            minWidth: `${Gt}px`
          });
        } else
          Ee === "top" ? (gn = "top", on.bottom = `${Bt}px`) : Ee || en + Bt + Qt > En && en - Bt - Qt > Lt && (gn = "top", on.bottom = `${Bt}px`);
        return h.panelStyle = on, h.panelPlacement = gn, me();
      }
    }), Se = () => {
      const { loading: Ee, filterable: Ye } = e, { hpTimeout: rt } = O, Ot = C.value;
      !Ee && !Ot && (rt && (clearTimeout(rt), O.hpTimeout = void 0), h.initialized || (h.initialized = !0), h.isActivated = !0, h.isAniVisible = !0, Ye && ($(), N()), setTimeout(() => {
        h.visiblePanel = !0, Qe(), ze().then(() => Te());
      }, 10), setTimeout(() => {
        ze().then(() => Te());
      }, 100), ge(), Oe());
    }, de = () => {
      h.searchValue = "", h.searchLoading = !1, h.visiblePanel = !1, O.hpTimeout = window.setTimeout(() => {
        h.isAniVisible = !1;
      }, 350);
    }, Ie = (Ee, Ye) => {
      ce(Ye), Ye !== e.modelValue && (H("change", { value: Ye }, Ee), c && m && c.triggerItemEvent(Ee, m.itemConfig.field, Ye));
    }, je = (Ee, Ye) => {
      O.remoteValMaps = {}, Ie(Ee, Ye), H("clear", { value: Ye }, Ee);
    }, Ue = (Ee, Ye) => {
      je(Ye, null), de();
    }, Ae = (Ee, Ye) => {
      const { modelValue: rt, multiple: Ot } = e, { remoteValMaps: Jt } = O, Bt = Y.value, Gt = Ye[Bt], Qt = Jt[Gt];
      if (Qt ? Qt.item = Ye : Jt[Gt] = {
        key: j(Ye),
        item: Ye,
        _index: -1
      }, Ot) {
        let U = [];
        const Lt = r.eqNull(rt) ? [] : r.isArray(rt) ? rt : [rt];
        r.findIndexOf(Lt, (en) => en === Gt) === -1 ? U = Lt.concat([Gt]) : U = Lt.filter((en) => en !== Gt), Ie(Ee, U);
      } else
        Ie(Ee, Gt), de();
      h.reactFlag++;
    }, _e = (Ee) => {
      const { visiblePanel: Ye } = h;
      if (!C.value && Ye) {
        const Ot = D.value;
        jn(Ee, Ot).flag ? Oe() : de();
      }
    }, it = (Ee) => {
      const { visiblePanel: Ye } = h;
      if (!C.value) {
        const Ot = d.value, Jt = D.value;
        h.isActivated = jn(Ee, Ot).flag || jn(Ee, Jt).flag, Ye && !h.isActivated && de();
      }
    }, vt = (Ee) => {
      const Ye = Ee.disabled, rt = j(Ee);
      return !Ye && !Dt(rt);
    }, dt = (Ee, Ye) => {
      const { afterVisibleList: rt } = h, { optFullValMaps: Ot } = O, Jt = Y.value;
      if (!Ee)
        for (let Gt = 0; Gt < rt.length - 1; Gt++) {
          const Qt = rt[Gt];
          if (vt(Qt))
            return Qt;
        }
      const Bt = Ot[Ee[Jt]];
      if (Bt) {
        const Gt = Bt._index;
        if (Gt > -1) {
          if (Ye)
            for (let Qt = Gt + 1; Qt <= rt.length - 1; Qt++) {
              const U = rt[Qt];
              if (vt(U))
                return U;
            }
          else if (Gt > 0)
            for (let Qt = Gt - 1; Qt >= 0; Qt--) {
              const U = rt[Qt];
              if (vt(U))
                return U;
            }
        }
      }
      return null;
    }, at = (Ee) => {
      const { clearable: Ye } = e, { visiblePanel: rt, currentOption: Ot } = h;
      if (!C.value) {
        const Bt = ut.hasKey(Ee, Yt.TAB), Gt = ut.hasKey(Ee, Yt.ENTER), Qt = ut.hasKey(Ee, Yt.ESCAPE), U = ut.hasKey(Ee, Yt.ARROW_UP), Lt = ut.hasKey(Ee, Yt.ARROW_DOWN), on = ut.hasKey(Ee, Yt.DELETE), en = ut.hasKey(Ee, Yt.SPACEBAR);
        if (Bt && (h.isActivated = !1), rt)
          if (Qt || Bt)
            de();
          else if (Gt)
            Ee.preventDefault(), Ee.stopPropagation(), Ae(Ee, Ot);
          else if (U || Lt) {
            Ee.preventDefault();
            const hn = dt(Ot, Lt);
            hn && (J(hn), be(hn, Lt));
          } else en && Ee.preventDefault();
        else (U || Lt || Gt || en) && h.isActivated && (Ee.preventDefault(), Se());
        h.isActivated && on && Ye && je(Ee, null);
      }
    }, Et = () => {
      de();
    }, Qe = () => {
      e.filterable && me(() => {
        const Ee = w.value;
        Ee && Ee.focus();
      });
    }, De = (Ee) => {
      C.value || h.visiblePanel || (h.triggerFocusPanel = !0, Se(), setTimeout(() => {
        h.triggerFocusPanel = !1;
      }, 150)), H("focus", {}, Ee);
    }, Re = (Ee) => {
      R(Ee), H("click", {}, Ee);
    }, Be = (Ee) => {
      h.isActivated = !1, H("blur", {}, Ee);
    }, ve = (Ee) => {
      h.searchValue = Ee;
    }, Ne = () => {
      h.isActivated = !0;
    }, q = () => {
      const { remote: Ee, remoteMethod: Ye } = e, { searchValue: rt } = h;
      Ee && Ye ? (h.searchLoading = !0, Promise.resolve(Ye({ searchValue: rt })).then(() => me()).catch(() => me()).finally(() => {
        h.searchLoading = !1, $(), N();
      })) : ($(), N());
    }, z = r.debounce(q, 350, { trailing: !0 }), R = (Ee) => {
      const { $event: Ye } = Ee;
      Ye.preventDefault(), h.triggerFocusPanel ? h.triggerFocusPanel = !1 : h.visiblePanel ? de() : Se();
    }, le = (Ee, Ye, rt) => !!(Ye.disabled || ye.value && !Ee), F = () => {
      const { scrollYLoad: Ee, afterVisibleList: Ye } = h, { scrollYStore: rt } = O;
      h.bodyHeight = Ee ? Ye.length * rt.rowHeight : 0, h.topSpaceHeight = Ee ? Math.max(rt.startIndex * rt.rowHeight, 0) : 0;
    }, re = () => {
      const { scrollYLoad: Ee, afterVisibleList: Ye } = h, { scrollYStore: rt } = O;
      return h.optList = Ee ? Ye.slice(rt.startIndex, rt.endIndex) : Ye.slice(0), me();
    }, N = () => {
      re(), F();
    }, ee = () => me().then(() => {
      const { scrollYLoad: Ee } = h, { scrollYStore: Ye } = O, rt = S.value, Ot = se.value;
      let Jt = 0, Bt;
      if (rt && (Ot.sItem && (Bt = rt.querySelector(Ot.sItem)), Bt || (Bt = rt.children[0])), Bt && (Jt = Bt.offsetHeight), Jt = Math.max(20, Jt), Ye.rowHeight = Jt, Ee) {
        const Gt = v.value, Qt = Math.max(8, Gt ? Math.ceil(Gt.clientHeight / Jt) : 0), U = Math.max(0, Math.min(2, r.toNumber(Ot.oSize)));
        Ye.offsetSize = U, Ye.visibleSize = Qt, Ye.endIndex = Math.max(Ye.startIndex, Qt + U, Ye.endIndex), N();
      } else
        F();
    }), be = (Ee, Ye) => {
      const { scrollYLoad: rt } = h, { optFullValMaps: Ot, scrollYStore: Jt } = O, Bt = Y.value, Gt = Ot[Ee[Bt]];
      if (Gt) {
        const Qt = Gt.key, U = Gt._index;
        if (U > -1) {
          const Lt = v.value, en = D.value.querySelector(`[optid='${Qt}']`);
          if (Lt)
            if (en) {
              const hn = Lt.offsetHeight, En = 1;
              Ye ? en.offsetTop + en.offsetHeight - Lt.scrollTop > hn && (Lt.scrollTop = en.offsetTop + en.offsetHeight - hn) : (en.offsetTop + En < Lt.scrollTop || en.offsetTop + En > Lt.scrollTop + Lt.clientHeight) && (Lt.scrollTop = en.offsetTop - En);
            } else rt && (Ye ? Lt.scrollTop = U * Jt.rowHeight - Lt.clientHeight + Jt.rowHeight : Lt.scrollTop = U * Jt.rowHeight);
        }
      }
    }, we = (Ee, Ye) => {
      const rt = v.value;
      return rt && (r.isNumber(Ee) && (rt.scrollLeft = Ee), r.isNumber(Ye) && (rt.scrollTop = Ye)), h.scrollYLoad ? new Promise((Ot) => {
        setTimeout(() => {
          me(() => {
            Ot();
          });
        }, 50);
      }) : me();
    }, Te = () => {
      const { lastScrollLeft: Ee, lastScrollTop: Ye } = O;
      return St().then(() => {
        if (Ee || Ye)
          return O.lastScrollLeft = 0, O.lastScrollTop = 0, we(Ee, Ye);
      });
    }, ze = () => {
      const Ee = d.value;
      return Ee && Ee.clientWidth && Ee.clientHeight ? ee() : Promise.resolve();
    }, st = (Ee) => {
      const { scrollYStore: Ye } = O, { startIndex: rt, endIndex: Ot, visibleSize: Jt, offsetSize: Bt, rowHeight: Gt } = Ye, U = Ee.target.scrollTop, Lt = Math.floor(U / Gt), on = Math.max(0, Lt - 1 - Bt), en = Lt + Jt + Bt;
      (Lt <= rt || Lt >= Ot - Jt - 1) && (rt !== on || Ot !== en) && (Ye.startIndex = on, Ye.endIndex = en, N());
    }, ct = () => {
      const { lastScrollTime: Ye } = O;
      return !!(Ye && Date.now() < Ye + 250);
    }, Ke = (Ee) => {
      const Ye = Ee.target, rt = Ye.scrollTop, Ot = Ye.scrollLeft, Jt = Ot !== O.lastScrollLeft, Bt = rt !== O.lastScrollTop;
      O.lastScrollTop = rt, O.lastScrollLeft = Ot, h.scrollYLoad && st(Ee), O.lastScrollTime = Date.now(), H("scroll", { scrollLeft: Ot, scrollTop: rt, isX: Jt, isY: Bt }, Ee);
    }, wt = (Ee) => {
      ne(Ee || []);
      const { fullData: Ye, scrollYStore: rt } = O, Ot = se.value;
      return Object.assign(rt, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      }), O.synchData = Ee || [], h.scrollYLoad = !!Ot.enabled && Ot.gt > -1 && (Ot.gt === 0 || Ot.gt <= Ye.length), re(), ee().then(() => {
        Te();
      });
    }, St = () => {
      const Ee = v.value;
      return Ee && (Ee.scrollTop = 0, Ee.scrollLeft = 0), O.lastScrollTop = 0, O.lastScrollLeft = 0, me();
    }, Dt = (Ee) => {
      const { optGroupKeyMaps: Ye } = O;
      return !!Ye[Ee];
    };
    Object.assign(b, {
      dispatchEvent: H,
      loadData: wt,
      reloadData(Ee) {
        return St(), wt(Ee);
      },
      isPanelVisible() {
        return h.visiblePanel;
      },
      togglePanel() {
        return h.visiblePanel ? de() : Se(), me();
      },
      hidePanel() {
        return h.visiblePanel && de(), me();
      },
      showPanel() {
        return h.visiblePanel || Se(), me();
      },
      refreshOption() {
        return $(), N(), me();
      },
      focus() {
        const Ee = p.value;
        return h.isActivated = !0, Ee.blur(), me();
      },
      blur() {
        return p.value.blur(), h.isActivated = !1, me();
      },
      recalculate: ze,
      clearScroll: St
    });
    const nn = (Ee, Ye) => {
      const { optionKey: rt, modelValue: Ot } = e, { currentOption: Jt } = h, Bt = P.value, Gt = ue.value, Qt = Y.value, U = K.value, { useKey: Lt } = Bt, on = n.option;
      return Ee.map((en, hn) => {
        const { slots: En, className: mn } = en, gn = j(en), Sn = en[Qt], Fn = Dt(gn), co = r.isArray(Ot) ? Ot.indexOf(Sn) > -1 : Ot === Sn, Uo = !Fn || Ta(en), Qn = le(co, en), ho = En ? En.default : null, Co = { option: en, group: null, $select: b };
        return Uo ? o("div", {
          key: Lt || rt ? gn : hn,
          class: ["vxe-select-option", mn ? r.isFunction(mn) ? mn(Co) : mn : "", {
            "vxe-select-optgroup": Fn,
            "is--disabled": Qn,
            "is--selected": co,
            "is--hover": Jt && j(Jt) === gn
          }],
          // attrs
          optid: gn,
          // event
          onMousedown: (Oo) => {
            Oo.button === 0 && Oo.stopPropagation();
          },
          onClick: (Oo) => {
            !Qn && !Fn && Ae(Oo, en);
          },
          onMouseenter: () => {
            !Qn && !Fn && !ct() && J(en);
          }
        }, on ? B(on, Co) : ho ? B(ho, Co) : Bn(en[Fn ? U : Gt])) : Ve();
      });
    }, zt = () => {
      const { optList: Ee, searchLoading: Ye } = h;
      return Ye ? [
        o("div", {
          class: "vxe-select--search-loading"
        }, [
          o("i", {
            class: ["vxe-select--search-icon", ht().SELECT_LOADED]
          }),
          o("span", {
            class: "vxe-select--search-text"
          }, Pe("vxe.select.loadingText"))
        ])
      ] : Ee.length ? nn(Ee) : [
        o("div", {
          class: "vxe-select--empty-placeholder"
        }, e.emptyText || Pe("vxe.select.emptyText"))
      ];
    }, At = () => {
      const { className: Ee, popupClassName: Ye, loading: rt, filterable: Ot } = e, { initialized: Jt, isActivated: Bt, isAniVisible: Gt, visiblePanel: Qt, bodyHeight: U, topSpaceHeight: Lt } = h, on = x.value, en = C.value, hn = I.value, En = V.value, mn = E.value, gn = Q.value, Sn = n.default, Fn = n.header, co = n.footer, Uo = n.prefix;
      return mn ? o("div", {
        ref: d,
        class: ["vxe-select--readonly", Ee]
      }, [
        o("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, Sn ? Sn({}) : []),
        o("span", {
          class: "vxe-select-label"
        }, hn)
      ]) : o("div", {
        ref: d,
        class: ["vxe-select", Ee ? r.isFunction(Ee) ? Ee({ $select: b }) : Ee : "", {
          [`size--${on}`]: on,
          "is--visible": Qt,
          "is--disabled": en,
          "is--filter": Ot,
          "is--loading": rt,
          "is--active": Bt
        }]
      }, [
        o("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, Sn ? Sn({}) : []),
        o(Wn, {
          ref: p,
          clearable: e.clearable,
          placeholder: gn,
          readonly: !0,
          disabled: en,
          type: "text",
          prefixIcon: e.prefixIcon,
          suffixIcon: rt ? ht().SELECT_LOADED : Qt ? ht().SELECT_OPEN : ht().SELECT_CLOSE,
          modelValue: hn,
          onClear: Ue,
          onClick: Re,
          onFocus: De,
          onBlur: Be,
          onSuffixClick: R
        }, Uo ? {
          prefix: () => Uo({})
        } : {}),
        o(ks, {
          to: "body",
          disabled: En ? !Jt : !0
        }, [
          o("div", {
            ref: D,
            class: ["vxe-table--ignore-clear vxe-select--panel", Ye ? r.isFunction(Ye) ? Ye({ $select: b }) : Ye : "", {
              [`size--${on}`]: on,
              "is--transfer": En,
              "ani--leave": !rt && Gt,
              "ani--enter": !rt && Qt
            }],
            placement: h.panelPlacement,
            style: h.panelStyle
          }, Jt && (Qt || Gt) ? [
            o("div", {
              class: "vxe-select--panel-wrapper"
            }, [
              Ot ? o("div", {
                class: "vxe-select--panel-search"
              }, [
                o(Wn, {
                  ref: w,
                  class: "vxe-select-search--input",
                  modelValue: h.searchValue,
                  clearable: !0,
                  disabled: !1,
                  readonly: !1,
                  placeholder: Pe("vxe.select.search"),
                  prefixIcon: ht().INPUT_SEARCH,
                  "onUpdate:modelValue": ve,
                  onFocus: Ne,
                  onChange: z,
                  onSearch: z
                })
              ]) : Ve(),
              Fn ? o("div", {
                class: "vxe-select--panel-header"
              }, Fn({})) : Ve(),
              o("div", {
                class: "vxe-select--panel-body"
              }, [
                o("div", {
                  ref: v,
                  class: "vxe-select-option--wrapper",
                  onScroll: Ke
                }, [
                  o("div", {
                    class: "vxe-select--y-space",
                    style: {
                      height: U ? `${U}px` : ""
                    }
                  }),
                  o("div", {
                    ref: S,
                    class: "vxe-select--body",
                    style: {
                      marginTop: Lt ? `${Lt}px` : ""
                    }
                  }, zt())
                ])
              ]),
              co ? o("div", {
                class: "vxe-select--panel-footer"
              }, co({})) : Ve()
            ])
          ] : [])
        ])
      ]);
    };
    return lt(() => h.staticOptions, (Ee) => {
      wt(Ee);
    }), lt(() => e.options, (Ee) => {
      wt(Ee || []);
    }), lt(() => e.optionGroups, (Ee) => {
      wt(Ee || []);
    }), wn(() => {
      me(() => {
        const { options: Ee, optionGroups: Ye } = e;
        Ye ? wt(Ye) : Ee && wt(Ee);
      }), ut.on(b, "mousewheel", _e), ut.on(b, "mousedown", it), ut.on(b, "keydown", at), ut.on(b, "blur", Et);
    }), $n(() => {
      ut.off(b, "mousewheel"), ut.off(b, "mousedown"), ut.off(b, "keydown"), ut.off(b, "blur");
    }), bn("$xeSelect", b), b.renderVN = At, b;
  },
  render() {
    return this.renderVN();
  }
}), Lv = () => [
  { label: Pe("vxe.formDesign.styleSetting.fontNormal"), value: !1 },
  { label: Pe("vxe.formDesign.styleSetting.fontBold"), value: !0 }
], Av = () => [
  { label: Pe("vxe.formDesign.styleSetting.colonVisible"), value: !0 },
  { label: Pe("vxe.formDesign.styleSetting.colonHidden"), value: !1 }
], Bv = () => [
  { label: Pe("vxe.formDesign.styleSetting.alignLeft"), value: "" },
  { label: Pe("vxe.formDesign.styleSetting.alignRight"), value: "right" }
], _v = () => [
  { label: Pe("vxe.formDesign.styleSetting.unitPx"), value: "" },
  { label: Pe("vxe.formDesign.styleSetting.unitPct"), value: "%" }
], kc = (e, t, n, s) => {
  const i = n === "vertical";
  return o("div", {
    class: ["vxe-form-design--widget-form-item-option", `is--${n}`, {
      "is--active": i ? e[t] : !e[t]
    }],
    onClick() {
      e[t] = i, s();
    }
  }, [
    o("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    o("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    o("div", {}, Pe(i ? "vxe.formDesign.styleSetting.verticalLayout" : "vxe.formDesign.styleSetting.horizontalLayout"))
  ]);
}, o0 = pt({
  name: "DefaultPCStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormDesign", null), n = "pcVertical", s = ke(Lv()), i = ke(Av()), l = ke(Bv()), a = ke(_v()), c = () => {
      t && t.refreshPreviewView();
    }, m = () => {
      const { formData: u } = e;
      u.pcTitleWidth || (u.pcTitleWidth = 100), c();
    };
    return () => {
      const { formData: u } = e;
      return o(Nn, {
        data: u,
        span: 24,
        vertical: !0,
        titleBold: !0
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.styleSetting.layoutTitle"),
              field: n
            }, {
              default() {
                return [
                  o("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    kc(u, n, "vertical", m),
                    kc(u, n, "horizontal", m)
                  ])
                ];
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  o("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, Pe("vxe.formDesign.styleSetting.boldTitle")),
                    o(Jo, {
                      modelValue: u.pcTitleBold,
                      options: s.value,
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.pcTitleBold = d;
                      }
                    })
                  ]),
                  o("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, Pe("vxe.formDesign.styleSetting.colonTitle")),
                    o(Jo, {
                      modelValue: u.pcTitleColon,
                      options: i.value,
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.pcTitleColon = d;
                      }
                    })
                  ]),
                  u.pcVertical ? Ve() : o("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, Pe("vxe.formDesign.styleSetting.alignTitle")),
                    o(Jo, {
                      modelValue: u.pcTitleAlign,
                      options: l.value,
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.pcTitleAlign = d;
                      }
                    })
                  ]),
                  u.pcVertical ? Ve() : o("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, Pe("vxe.formDesign.styleSetting.widthTitle")),
                    o(Wn, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: u.pcTitleWidth,
                      type: "integer",
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.pcTitleWidth = d;
                      }
                    }),
                    o(vs, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: u.pcTitleWidthUnit,
                      options: a.value,
                      transfer: !0,
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.pcTitleWidthUnit = d;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
}), s0 = pt({
  name: "DefaultMobileStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormDesign", null), n = "mobileVertical", s = ke(Lv()), i = ke(Av()), l = ke(Bv()), a = ke(_v()), c = () => {
      t && t.refreshPreviewView();
    }, m = () => {
      const { formData: u } = e;
      u.mobileTitleWidth || (u.mobileTitleWidth = 100), c();
    };
    return () => {
      const { formData: u } = e;
      return o(Nn, {
        data: u,
        span: 24,
        vertical: !0,
        titleBold: !0
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.styleSetting.layoutTitle"),
              field: n
            }, {
              default() {
                return [
                  o("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    kc(u, n, "vertical", m),
                    kc(u, n, "horizontal", m)
                  ])
                ];
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  o("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, Pe("vxe.formDesign.styleSetting.boldTitle")),
                    o(Jo, {
                      modelValue: u.mobileTitleBold,
                      options: s.value,
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.mobileTitleBold = d;
                      }
                    })
                  ]),
                  o("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, Pe("vxe.formDesign.styleSetting.colonTitle")),
                    o(Jo, {
                      modelValue: u.mobileTitleColon,
                      options: i.value,
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.mobileTitleColon = d;
                      }
                    })
                  ]),
                  u.mobileVertical ? Ve() : o("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, Pe("vxe.formDesign.styleSetting.alignTitle")),
                    o(Jo, {
                      modelValue: u.mobileTitleAlign,
                      options: l.value,
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.mobileTitleAlign = d;
                      }
                    })
                  ]),
                  u.mobileVertical ? Ve() : o("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, Pe("vxe.formDesign.styleSetting.widthTitle")),
                    o(Wn, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: u.mobileTitleWidth,
                      type: "integer",
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.mobileTitleWidth = d;
                      }
                    }),
                    o(vs, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: u.mobileTitleWidthUnit,
                      options: a.value,
                      transfer: !0,
                      onChange: c,
                      "onUpdate:modelValue"(d) {
                        u.mobileTitleWidthUnit = d;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
}), r0 = pt({
  name: "FormDesignLayoutStyle",
  props: {},
  emits: [],
  setup() {
    const e = mt("$xeFormDesign", null), t = Rt({
      activeTab: 1
    }), n = {
      reactData: t,
      renderVN() {
        return [];
      }
    };
    if (!e)
      return n;
    const { props: s, reactData: i } = e, l = ke(!1), a = ke(null), c = ke({}), m = () => {
      a.value = e.getConfig();
    }, u = (x) => {
      const { viewRender: h } = x, { activeTab: O } = t, { name: g } = h || {}, b = Cn.get(g) || {}, E = b ? b.createFormViewFormConfig : null, C = b ? b.createFormViewMobileFormConfig : null;
      return O === 2 ? C ? C(x) : t0(x) : E ? E(x) : Fv(x);
    };
    Object.assign(n, {
      updatePreviewView: m,
      openStylePreview() {
        const { showPc: x } = s;
        m(), t.activeTab = x ? 1 : 2, l.value = !0;
      }
    });
    const p = () => {
      const { activeTab: x } = t;
      return o("div", {
        class: ["vxe-form-design--layout-style-preview", `is--${x === 2 ? "mobile" : "pc"}`]
      }, [
        o(Ti, {
          modelValue: c.value,
          config: a.value,
          createFormConfig: u,
          "onUpdate:modelValue"(h) {
            c.value = h;
          }
        })
      ]);
    }, w = () => {
      const { formRender: x } = s, { formData: h } = i;
      if (x) {
        const O = Cn.get(x.name), g = O ? O.renderFormDesignMobileStyleFormView : null;
        if (g)
          return o("div", {
            class: "vxe-form-design--custom-setting-mobile-form-view"
          }, Nt(g({}, { $formDesign: e, formConfig: h })));
      }
      return o(s0, {
        formData: h
      });
    }, v = () => {
      const { formRender: x } = s, { formData: h } = i;
      if (x) {
        const O = Cn.get(x.name), g = O ? O.renderFormDesignStyleFormView : null;
        if (g)
          return o("div", {
            class: "vxe-form-design--custom-setting-pc-form-view"
          }, Nt(g({}, { $formDesign: e, formConfig: h })));
      }
      return o(o0, {
        formData: h
      });
    }, D = () => {
      const { showPc: x, showMobile: h } = s, { activeTab: O } = t;
      return o("div", {
        class: "vxe-form-design--layout-style-setting"
      }, [
        o(ol, {
          modelValue: O,
          titleWidth: x && h ? "50%" : "100%",
          titleAlign: "center",
          padding: !0,
          onChange: m,
          "onUpdate:modelValue"(g) {
            t.activeTab = g;
          }
        }, {
          default() {
            const g = [];
            return x && g.push(o(qs, {
              title: Pe("vxe.formDesign.widgetProp.displaySetting.pc"),
              icon: ht().FORM_DESIGN_PROPS_PC,
              k: 1,
              name: 1
            }, {
              default() {
                return v();
              }
            })), h && g.push(o(qs, {
              title: Pe("vxe.formDesign.widgetProp.displaySetting.mobile"),
              icon: ht().FORM_DESIGN_PROPS_MOBILE,
              key: 2,
              name: 2
            }, {
              default() {
                return w();
              }
            })), g;
          }
        })
      ]);
    }, S = () => {
      const { showPc: x, showMobile: h } = s;
      return o(Oi, {
        modelValue: l.value,
        title: Pe("vxe.formDesign.styleSetting.title"),
        height: "90vh",
        width: "90vw",
        escClosable: !0,
        maskClosable: !0,
        destroyOnClose: !0,
        showMaximize: !0,
        transfer: !0,
        "onUpdate:modelValue"(O) {
          l.value = O;
        }
      }, {
        default() {
          return o("div", {
            class: "vxe-form-design--layout-style"
          }, [
            p(),
            x || h ? D() : Ve()
          ]);
        }
      });
    };
    return n.renderVN = S, bn("$xeFormDesignLayoutStyle", n), n;
  },
  render() {
    return this.renderVN();
  }
}), Za = pt({
  name: "VxeFormDesign",
  props: {
    size: {
      type: String,
      default: () => oe().formDesign.size || oe().size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => oe().formDesign.height
    },
    widgets: {
      type: Array,
      default: () => r.clone(oe().formDesign.widgets) || []
    },
    showHeader: {
      type: Boolean,
      default: () => oe().formDesign.showHeader
    },
    showPc: {
      type: Boolean,
      default: () => oe().formDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => oe().formDesign.showMobile
    },
    formRender: Object
  },
  emits: [
    "click-widget",
    "add-widget",
    "copy-widget",
    "remove-widget",
    "drag-widget"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), l = ke(), a = ke(), { computeSize: c } = dn(e), m = Rt({
      formData: {},
      widgetConfigs: [],
      widgetObjList: [],
      dragWidget: null,
      sortWidget: null,
      activeWidget: null
    }), u = Rt({}), d = {
      refElem: l
    }, p = {
      computeSize: c
    }, w = {
      xID: i,
      props: e,
      context: t,
      reactData: m,
      internalData: u,
      getRefMaps: () => d,
      getComputeMaps: () => p
    }, v = (P) => new sd(w, P, m.widgetObjList), D = () => new sd(w, "", m.widgetObjList), S = (P) => {
      if (P) {
        const { formConfig: B, widgetData: H } = P;
        B && O(B), H && E(H);
      }
      const { activeWidget: M, widgetObjList: I } = m;
      if (M) {
        const B = r.findTree(I, (H) => H.id === M.id, { children: "children" });
        B ? m.activeWidget = B.item : m.activeWidget = I[0] || null;
      } else
        m.activeWidget = I[0] || null;
      return me();
    }, x = (P) => (V(), S(P)), h = () => r.clone(m.formData, !0), O = (P) => (m.formData = Object.assign({}, Y(), P), me()), g = (P) => {
      const { widgetObjList: M } = m;
      if (P) {
        const I = r.toNumber(P), B = r.findTree(M, (H) => H && H.id === I, { children: "children" });
        if (B)
          return B.item;
      }
      return null;
    }, b = () => {
      const P = r.clone(m.widgetObjList, !0);
      return r.eachTree(P, (M) => {
        M.model.value = null;
      }, { children: "children" }), P;
    }, E = (P) => (m.widgetObjList = (P || []).map((M) => Vd(M)), me()), C = () => {
      const P = a.value;
      return P && P.openStylePreview(), me();
    }, V = () => (m.widgetObjList = [], K(), me()), Q = {
      dispatchEvent(P, M, I) {
        n(P, Zt(I, { $xeFormDesign: w }, M));
      },
      createWidget: v,
      createEmptyWidget: D,
      getConfig() {
        return {
          formConfig: h(),
          widgetData: b()
        };
      },
      clearConfig: V,
      loadConfig: S,
      reloadConfig: x,
      getFormConfig: h,
      loadFormConfig: O,
      getWidgetById: g,
      getFormData() {
        const { widgetObjList: P } = m, M = {};
        return r.eachTree(P, (I) => {
          M[I.field] = null;
        }, { children: "children" }), M;
      },
      getWidgetData: b,
      loadWidgetData: E,
      refreshPreviewView() {
        const P = a.value;
        return P && P.updatePreviewView(), me();
      },
      openStyleSetting: C
    }, Z = () => {
      const { widgets: P } = e, M = [], I = [], B = [], H = [], ce = [];
      Cn.forEach((A, j) => {
        const { createFormDesignWidgetConfig: fe } = A;
        if (fe) {
          const pe = v(j), ne = Ul(j), $ = qL(j, w);
          if ($) {
            const J = ce.find((ge) => ge.title === $);
            J ? J.children.push(pe) : ce.push({
              title: $,
              children: [pe]
            });
          } else
            switch (ne.group) {
              case "layout":
                B.push(pe);
                break;
              case "advanced":
                H.push(pe);
                break;
              default:
                ["title"].includes(pe.name) || I.push(pe);
                break;
            }
        }
      }), I.length && M.push({
        group: "base",
        children: I
      }), B.length && M.push({
        group: "layout",
        children: B
      }), H.length && M.push({
        group: "advanced",
        children: H
      }), ce.length && M.push(...ce), P && P.length ? m.widgetConfigs = e.widgets.map((A) => ({
        title: A.customGroup,
        group: A.group,
        children: A.children ? A.children.map((j) => v(j)) : []
      })) : m.widgetConfigs = M;
    }, G = (P) => {
      const { widgetObjList: M } = m;
      if (Ul(P).unique) {
        const B = [];
        r.eachTree(M, (ce) => {
          ce.name === P && B.push(ce);
        }, { children: "children" });
        const H = B.length < 1;
        return H || Ce.modal && Ce.modal.message({
          content: Pe("vxe.formDesign.error.wdFormUni"),
          status: "error",
          id: "wdFormUni"
        }), H;
      }
      return !0;
    }, ue = {
      validWidgetUnique: G,
      handleClickWidget(P, M) {
        M && M.name && (P.stopPropagation(), m.activeWidget = M, Q.dispatchEvent("click-widget", { widget: M }, P));
      },
      handleCopyWidget(P, M) {
        const { widgetObjList: I } = m, B = r.findTree(I, (H) => H.id === M.id, { children: "children" });
        if (B && (P.stopPropagation(), G(M.name))) {
          const { path: H } = B, ce = Number(H[0]), A = v(M.name);
          A.title && (A.title = Pe("vxe.formDesign.widget.copyTitle", [`${M.title}`.replace(Pe("vxe.formDesign.widget.copyTitle", [""]), "")])), ce >= I.length - 1 ? I.push(A) : I.splice(ce + 1, 0, A), m.activeWidget = A, m.widgetObjList = [...I], Q.dispatchEvent("copy-widget", { widget: M, newWidget: A }, P);
        }
      },
      handleRemoveWidget(P, M) {
        const { widgetObjList: I } = m, B = r.findTree(I, (H) => H.id === M.id, { children: "children" });
        if (B) {
          const { index: H, parent: ce, items: A } = B;
          P.stopPropagation(), H >= A.length - 1 ? m.activeWidget = A[H - 1] : m.activeWidget = A[H + 1] || null, ce && ce.name === "row" ? A[H] = D() : A.splice(H, 1), m.widgetObjList = [...I], Q.dispatchEvent("remove-widget", { widget: M }, P);
        }
      }
    }, Y = () => {
      const { formRender: P, showPc: M, showMobile: I } = e;
      let B = e0({
        pcVisible: M,
        mobileVisible: I
      });
      if (P) {
        const H = Cn.get(P.name), ce = H ? H.createFormDesignSettingFormConfig : null;
        B = (ce ? ce({}) : {}) || {};
      }
      return B;
    }, K = () => {
      m.formData = Y();
    }, L = () => {
      C();
    };
    Object.assign(w, Q, ue);
    const ye = () => {
      const P = s.extra;
      return o("div", {
        class: "vxe-form-design--header-wrapper"
      }, [
        o("div", {
          class: "vxe-form-design--header-left"
        }),
        o("div", {
          class: "vxe-form-design--header-middle"
        }),
        o("div", {
          class: "vxe-form-design--header-right"
        }, [
          P ? o("div", {
            class: "vxe-form-design--header-extra"
          }, P({})) : Yn(),
          o("div", {
            class: "vxe-form-design--header-setting"
          }, [
            o(Vn, {
              mode: "text",
              status: "primary",
              icon: ht().FORM_DESIGN_STYLE_SETTING,
              content: Pe("vxe.formDesign.styleSetting.btn"),
              onClick: L
            })
          ])
        ])
      ]);
    }, se = () => {
      const { height: P, showHeader: M } = e, I = c.value, B = s.header, H = s.footer;
      return o("div", {
        ref: l,
        class: ["vxe-form-design", {
          [`size--${I}`]: I
        }],
        style: P ? {
          height: cn(P)
        } : null
      }, [
        M || B ? o("div", {
          class: "vxe-form-design--header"
        }, B ? B({}) : ye()) : Ve(),
        o("div", {
          class: "vxe-form-design--body"
        }, [
          o(GL),
          o(YL),
          o(QL),
          o(r0, {
            ref: a
          })
        ]),
        H ? o("div", {
          class: "vxe-form-design--footer"
        }, H ? H({}) : []) : Ve()
      ]);
    };
    return w.renderVN = se, lt(() => e.widgets, () => {
      Z();
    }), lt(() => e.widgets, () => {
      Z();
    }), lt(() => e.config, (P) => {
      S(P || {});
    }), K(), Z(), e.config && S(e.config), bn("$xeFormDesign", w), w;
  },
  render() {
    return this.renderVN();
  }
});
function Dn(e) {
  return {
    computeKebabCaseName: _(() => {
      const { renderOpts: n } = e;
      return n ? r.kebabCase(n.name) : "";
    })
  };
}
function l0(e) {
  const t = _(() => {
    const { renderParams: a } = e;
    return a.widget;
  }), n = _(() => {
    const { renderParams: a } = e;
    return a.isEditMode || !1;
  }), s = _(() => {
    const { renderParams: a } = e;
    return a.isViewMode || !1;
  }), i = _(() => {
    const { renderParams: a } = e, { widget: c } = a;
    return c ? c.options : {};
  }), l = _({
    get() {
      const { renderParams: a } = e, { $formView: c, widget: m } = a;
      return c ? c.getItemValue(m) : null;
    },
    set(a) {
      const { renderParams: c } = e, { $formView: m, widget: u } = c;
      m && m.setItemValue(u, a);
    }
  });
  return {
    currWidget: t,
    widgetOptions: i,
    widgetModel: l,
    isEditMode: n,
    isViewMode: s
  };
}
function i0(e) {
  const t = _(() => {
    const { renderParams: a } = e;
    return a.widget;
  }), n = _(() => {
    const { renderParams: a } = e;
    return a.column;
  }), s = _(() => {
    const { renderParams: a } = e;
    return a.row;
  }), i = _(() => {
    const { renderParams: a } = e, { widget: c } = a;
    return c ? c.options : {};
  }), l = _({
    get() {
      const { renderParams: a } = e, { row: c, column: m } = a;
      return r.get(c, m.field);
    },
    set(a) {
      const { renderParams: c } = e, { row: m, column: u } = c;
      return r.set(m, u.field, a);
    }
  });
  return {
    currColumn: n,
    currRow: s,
    currWidget: t,
    widgetOptions: i,
    cellModel: l
  };
}
let rr;
const Wl = pt({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: !0
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: {
      type: Boolean,
      default: !0
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: {
      type: [String, Number],
      default: null
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: () => oe().textarea.resize
    },
    size: {
      type: String,
      default: () => oe().textarea.size || oe().size
    },
    // 已废弃
    maxlength: [String, Number]
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur"
  ],
  setup(e, t) {
    const { emit: n } = t, s = mt("$xeForm", null), i = mt("xeFormItemInfo", null), l = r.uniqueId(), { computeSize: a } = dn(e), c = Rt({
      inputValue: e.modelValue
    }), m = ke(), u = ke(), d = {
      refElem: m,
      refTextarea: u
    }, p = {
      xID: l,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => d
    };
    let w = {};
    const v = _(() => {
      const { readonly: K } = e;
      return K === null ? s ? s.props.readonly : !1 : K;
    }), D = _(() => {
      const { disabled: K } = e;
      return K === null ? s ? s.props.disabled : !1 : K;
    }), S = _(() => {
      const { editable: K } = e;
      return v.value || !K;
    }), x = _(() => {
      const { placeholder: K } = e;
      if (K)
        return Bn(K);
      const L = oe().textarea.placeholder;
      return L ? Bn(L) : Pe("vxe.base.pleaseInput");
    }), h = _(() => {
      const { maxLength: K, maxlength: L } = e;
      return K || L;
    }), O = _(() => r.getSize(c.inputValue)), g = _(() => {
      const K = O.value, L = h.value;
      return L && K > r.toNumber(L);
    }), b = _(() => Object.assign({ minRows: 1, maxRows: 10 }, oe().textarea.autosize, e.autosize)), E = () => {
      const { size: K, autosize: L } = e, { inputValue: ye } = c;
      if (L) {
        rr || (rr = document.createElement("div")), rr.parentNode || document.body.appendChild(rr);
        const se = u.value;
        if (!se)
          return;
        const P = getComputedStyle(se);
        rr.className = ["vxe-textarea--autosize", K ? `size--${K}` : ""].join(" "), rr.style.width = `${se.clientWidth}px`, rr.style.padding = P.padding, rr.innerText = ("" + (ye || "　")).replace(/\n$/, `
　`);
      }
    }, C = () => {
      e.autosize && me(() => {
        const K = b.value, { minRows: L, maxRows: ye } = K, se = u.value;
        if (!se)
          return;
        const P = rr.clientHeight, M = getComputedStyle(se), I = r.toNumber(M.lineHeight), B = r.toNumber(M.paddingTop), H = r.toNumber(M.paddingBottom), ce = r.toNumber(M.borderTopWidth), A = r.toNumber(M.borderBottomWidth), j = B + H + ce + A, fe = (P - j) / I, pe = fe && /[0-9]/.test("" + fe) ? fe : Math.floor(fe) + 1;
        let ne = pe;
        pe < L ? ne = L : pe > ye && (ne = ye), se.style.height = `${ne * I + j}px`;
      });
    }, V = (K) => {
      const L = c.inputValue;
      p.dispatchEvent(K.type, { value: L }, K);
    }, Q = (K, L) => {
      c.inputValue = K, n("update:modelValue", K), r.toValueString(e.modelValue) !== K && (w.dispatchEvent("change", { value: K }, L), s && i && s.triggerItemEvent(L, i.itemConfig.field, K));
    }, Z = (K) => {
      const { immediate: L } = e, se = K.target.value;
      c.inputValue = se, L && Q(se, K), p.dispatchEvent("input", { value: se }, K), C();
    }, G = (K) => {
      const { immediate: L } = e;
      L ? V(K) : Q(c.inputValue, K);
    }, ue = (K) => {
      const { immediate: L } = e, { inputValue: ye } = c;
      L || Q(ye, K), p.dispatchEvent("blur", { value: ye }, K);
    };
    w = {
      dispatchEvent(K, L, ye) {
        n(K, Zt(ye, { $textarea: p }, L));
      },
      focus() {
        return u.value.focus(), me();
      },
      blur() {
        return u.value.blur(), me();
      }
    }, Object.assign(p, w), lt(() => e.modelValue, (K) => {
      c.inputValue = K, E();
    }), lt(b, () => {
      E(), C();
    }), me(() => {
      const { autosize: K } = e;
      K && (E(), C());
    });
    const Y = () => {
      const { className: K, resize: L, autosize: ye, showWordCount: se, countMethod: P, rows: M, cols: I } = e, { inputValue: B } = c, H = a.value, ce = D.value, A = g.value, j = O.value, fe = S.value, pe = v.value, ne = x.value, $ = h.value;
      return pe ? o("div", {
        ref: m,
        class: ["vxe-textarea--readonly", K]
      }, B) : o("div", {
        ref: m,
        class: ["vxe-textarea", K, {
          [`size--${H}`]: H,
          "is--autosize": ye,
          "is--count": se,
          "is--disabled": ce,
          "is--rows": !r.eqNull(M),
          "is--cols": !r.eqNull(I)
        }],
        spellcheck: !1
      }, [
        o("textarea", {
          ref: u,
          class: "vxe-textarea--inner",
          value: B,
          name: e.name,
          placeholder: ne,
          maxlength: $,
          readonly: fe,
          disabled: ce,
          rows: M,
          cols: I,
          style: L ? {
            resize: L
          } : null,
          onInput: Z,
          onChange: G,
          onKeydown: V,
          onKeyup: V,
          onClick: V,
          onFocus: V,
          onBlur: ue
        }),
        se ? o("span", {
          class: ["vxe-textarea--count", {
            "is--error": A
          }]
        }, P ? `${P({ value: B })}` : `${j}${$ ? `/${$}` : ""}`) : null
      ]);
    };
    return p.renderVN = Y, p;
  },
  render() {
    return this.renderVN();
  }
}), Vl = pt({
  name: "VxeTip",
  props: {
    title: {
      type: [String, Number],
      default: () => oe().tip.title
    },
    content: [String, Number],
    status: String,
    icon: {
      type: String,
      default: () => oe().tip.icon
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => oe().tip.size || oe().size
    }
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), { computePermissionInfo: a } = Qi(e), c = ke(), m = Rt({}), u = {
      refElem: c
    }, d = {}, p = {
      xID: i,
      props: e,
      context: t,
      reactData: m,
      getRefMaps: () => u,
      getComputeMaps: () => d
    };
    Object.assign(p, {
      dispatchEvent: (x, h, O) => {
        s(x, Zt(O, { $tip: p }, h));
      }
    }, {});
    const S = () => {
      const { status: x, content: h, icon: O, title: g } = e, b = n.default, E = n.title, C = n.icon, V = a.value, Q = l.value;
      return V.visible ? o("div", {
        ref: c,
        class: ["vxe-tip", {
          [`size--${Q}`]: Q,
          [`theme--${x}`]: x,
          "has--title": !!(E || g)
        }]
      }, [
        C || O ? o("div", {
          class: "vxe-tip--icon"
        }, C ? Nt(C({})) : [
          o("i", {
            class: O
          })
        ]) : Ve(),
        o("div", {
          class: "vxe-tip--body"
        }, [
          E || g ? o("div", {
            class: "vxe-tip--title"
          }, E ? Nt(E({})) : r.toValueString(g)) : Ve(),
          o("div", {
            class: "vxe-tip--content"
          }, b ? Nt(b({})) : r.toValueString(h))
        ])
      ]) : Ve();
    };
    return p.renderVN = S, p;
  },
  render() {
    return this.renderVN();
  }
});
function na(e, t) {
  const s = Object.assign({}, t).isSubOption, i = ke(""), l = ke([]), a = () => {
    const { renderParams: h } = e, { widget: O } = h, g = O.options.options || [];
    g.push({
      value: Pe("vxe.formDesign.widgetProp.dataSource.defValue", [g.length + 1])
    }), O.options.options = [...g];
  }, c = /^(\s|\t)+/, m = (h) => c.test(h), u = () => {
    const { renderParams: h } = e, { widget: O } = h, g = O.options.options || [], b = [];
    g.forEach((E, C) => {
      const { options: V } = E;
      V && V.length && b.push(C);
    }), l.value = b;
  }, d = (h, O) => {
    l.value.includes(O) ? l.value = l.value.filter((g) => g !== O) : l.value.push(O);
  }, p = (h, O) => {
    const { renderParams: g } = e, { widget: b } = g, { options: E } = b;
    O ? O.options && (O.options = O.options.filter((C) => C !== h)) : E.options = E.options.filter((C) => C !== h);
  }, w = () => {
    const { renderParams: h } = e, { widget: O } = h, g = [], b = i.value.split(`
`);
    let E = null;
    s ? b.forEach((C, V) => {
      const Q = b[V + 1], Z = C.trim();
      if (!Z)
        return;
      const G = {
        value: Z
      };
      if (E) {
        if (m(C)) {
          E.options.push(G);
          return;
        }
        E = null, g.push(G);
      } else
        g.push(G);
      Q && m(Q) && (E = Object.assign(G, { options: [] }));
    }) : b.forEach((C) => {
      g.push({
        value: C.trim()
      });
    }), O.options.options = g, u();
  }, v = () => {
    var h;
    const { renderParams: O } = e, { widget: g } = O, b = [];
    (h = g.options.options) === null || h === void 0 || h.forEach((E) => {
      var C;
      b.push(E.value), (C = E.options) === null || C === void 0 || C.forEach((V) => {
        b.push(`	${V.value}`);
      });
    }), i.value = b.join(`
`), Ce.modal.open({
      title: `${g.title} - ${Pe("vxe.formDesign.widgetProp.dataSource.batchEditOption")}`,
      width: 500,
      height: "50vh ",
      resize: !0,
      showFooter: !0,
      showCancelButton: !0,
      showConfirmButton: !0,
      confirmButtonText: Pe("vxe.formDesign.widgetProp.dataSource.buildOption"),
      onConfirm: w,
      slots: {
        default() {
          return o("div", {
            class: "vxe-form-design--widget-form-item-data-source-popup"
          }, [
            o(Vl, {
              status: "primary",
              title: "",
              content: Pe(`vxe.formDesign.widgetProp.dataSource.${s ? "batchEditSubTip" : "batchEditTip"}`)
            }),
            o(Wl, {
              resize: "none",
              modelValue: i.value,
              "onUpdate:modelValue"(E) {
                i.value = E;
              }
            })
          ]);
        }
      }
    });
  }, D = (h, O, g, b, E, C, V) => o("div", {
    class: ["vxe-form-design--widget-form-item-data-source-option", {
      "is--first": C,
      "is--last": V
    }]
  }, [
    o("div", {
      class: "vxe-form-design--widget-expand-btn"
    }, !O && E ? [
      o("i", {
        class: g ? ht().FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE : ht().FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN,
        onClick() {
          d(h, b);
        }
      })
    ] : []),
    o("input", {
      class: "vxe-default-input",
      value: h.value,
      onInput(Z) {
        h.value = Z.target.value;
      }
    }),
    o(Vn, {
      status: "danger",
      mode: "text",
      icon: ht().FORM_DESIGN_WIDGET_DELETE,
      onClick() {
        p(h, O);
      }
    })
  ]), S = () => {
    const { renderParams: h } = e, { widget: O } = h, { options: g } = O, b = g.options, E = [];
    return b && b.forEach((C, V) => {
      const { options: Q } = C, Z = l.value.includes(V);
      Q && Q.length ? (E.push(D(C, null, Z, V, !0, V === 0, V === b.length - 1)), Z && E.push(o("div", {
        class: "vxe-form-design--widget-form-item-data-source-sub-option"
      }, Q.map((G) => D(G, C, Z, 0, !1, !1, !1))))) : E.push(D(C, null, Z, V, !1, V === 0, V === b.length - 1));
    }), E;
  };
  lt(() => e.renderParams.widget, () => {
    u();
  }), wn(() => {
    u();
  });
  const x = () => [
    o("div", {}, [
      o(Vn, {
        status: "primary",
        mode: "text",
        content: Pe("vxe.formDesign.widgetProp.dataSource.addOption"),
        onClick: a
      }),
      o(Vn, {
        status: "primary",
        mode: "text",
        content: Pe("vxe.formDesign.widgetProp.dataSource.batchEditOption"),
        onClick: v
      })
    ]),
    o("div", {
      class: "vxe-form-design--widget-form-item-data-source-wrapper"
    }, S())
  ];
  return {
    renderDataSourceFormItem() {
      return o(kt, {
        title: Pe("vxe.formDesign.widgetProp.dataSource.name"),
        field: "options"
      }, {
        default() {
          return x();
        }
      });
    },
    renderDataSourceFormItemContent: x
  };
}
const a0 = (e) => Pe(`vxe.formDesign.widget.component.${e}`), yo = (e) => a0(e.name), pm = () => ({
  title: yo,
  icon: "vxe-icon-text",
  group: "layout",
  options: {
    color: "",
    align: "",
    bold: !1,
    fontSize: ""
  }
}), c0 = () => r.range(12, 27).map((e) => ({ label: `${e}px`, value: `${e}px` })), u0 = () => [
  { label: Pe("vxe.formDesign.widgetProp.textProp.alignLeft"), value: "" },
  { label: Pe("vxe.formDesign.widgetProp.textProp.alignCenter"), value: "center" },
  { label: Pe("vxe.formDesign.widgetProp.textProp.alignRight"), value: "right" }
], d0 = () => [
  { label: Pe("vxe.formDesign.widgetProp.textProp.fontNormal"), value: !1 },
  { label: Pe("vxe.formDesign.widgetProp.textProp.fontBold"), value: !0 }
], mm = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e), n = ke(u0()), s = ke(d0()), i = ke(c0());
    return () => {
      const { renderParams: l } = e, { widget: a } = l, c = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${c}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: a.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.textProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: a.title,
                  "onUpdate:modelValue"(m) {
                    a.title = m;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.textProp.boldTitle"),
              field: "bold",
              itemRender: { name: "VxeRadioGroup", options: s.value }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.textProp.alignTitle"),
              field: "align",
              itemRender: { name: "VxeRadioGroup", options: n.value }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.textProp.sizeTitle"),
              field: "fontSize",
              itemRender: { name: "VxeSelect", options: i.value }
            })
          ];
        }
      });
    };
  }
}), gm = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, { options: i } = s, l = t.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${l}`],
        align: i.align
      }, {
        default() {
          return o("div", {
            style: {
              fontSize: i.fontSize,
              fontWeight: i.bold ? "bold" : ""
            }
          }, s.title);
        }
      });
    };
  }
}), f0 = (e) => {
  const { $formDesign: t } = e, n = 2;
  return {
    title: yo,
    group: "layout",
    icon: "vxe-icon-row-col",
    options: {
      colSize: n,
      colSpan: "12,12"
    },
    children: t ? r.range(0, n).map(() => t.createEmptyWidget()) : []
  };
}, zl = pt({
  name: "VxeRow",
  props: {
    gutter: [Number, String, Array],
    wrap: {
      type: Boolean,
      default: () => oe().row.wrap
    },
    vertical: Boolean,
    size: {
      type: String,
      default: () => oe().row.size || oe().size
    }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId();
    dn(e);
    const l = ke(), a = Rt({}), c = {
      refElem: l
    }, m = _(() => {
      const { gutter: x, vertical: h } = e, O = {};
      if (x) {
        let [g, b] = r.isArray(x) ? x : [x];
        if (h && (b = g, g = ""), g) {
          const E = r.isNumber(g) ? cn(-(g / 2)) : `calc(${cn(g)} / 2 * -1)`;
          O.marginLeft = E, O.marginRight = E;
        }
        if (b) {
          const E = r.isNumber(b) ? cn(-(b / 2)) : `calc(${cn(b)} / 2 * -1)`;
          O.marginTop = E, O.marginBottom = E;
        }
      }
      return O;
    }), u = {}, d = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => u
    }, p = (x) => {
      w("click", {}, x);
    }, w = (x, h, O) => {
      s(x, Zt(O, { $row: d }, h));
    };
    Object.assign(d, {
      dispatchEvent: w
    }, {});
    const S = () => {
      const { vertical: x, wrap: h } = e, O = m.value, g = n.default;
      return o("div", {
        ref: l,
        class: ["vxe-row", {
          "is--vertical": x,
          "is--wrap": h
        }],
        style: O,
        onClick: p
      }, g ? g({}) : []);
    };
    return bn("$xeRow", d), d.renderVN = S, d;
  },
  render() {
    return this.renderVN();
  }
}), p0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormDesign", null);
    if (!t)
      return () => [];
    const { computeKebabCaseName: n } = Dn(e), s = ke([
      {
        label: Pe("vxe.formDesign.widgetProp.rowProp.col2"),
        value: 2,
        list: [
          { value: "12,12", spans: [12, 12] },
          { value: "8,16", spans: [8, 16] },
          { value: "16,8", spans: [16, 8] },
          { value: "6,18", spans: [6, 18] },
          { value: "18,6", spans: [18, 6] }
        ]
      },
      {
        label: Pe("vxe.formDesign.widgetProp.rowProp.col3"),
        value: 3,
        list: [
          { value: "8,8,8", spans: [8, 8, 8] },
          { value: "6,6,12", spans: [6, 6, 12] },
          { value: "12,6,6", spans: [12, 6, 6] },
          { value: "6,12,6", spans: [6, 12, 6] }
        ]
      },
      {
        label: Pe("vxe.formDesign.widgetProp.rowProp.col4"),
        value: 4,
        list: [
          { value: "6,6,6,6", spans: [6, 6, 6, 6] }
        ]
      },
      {
        label: Pe("vxe.formDesign.widgetProp.rowProp.col6"),
        value: 6,
        list: [
          { value: "4,4,4,4,4,4", spans: [4, 4, 4, 4, 4, 4] }
        ]
      }
    ]), i = {
      18: "3/4",
      16: "2/3",
      12: "1/2",
      8: "1/3",
      6: "1/4",
      4: "1/6"
    }, l = _(() => {
      const { renderParams: c } = e, { widget: m } = c, { options: u } = m;
      return s.value.find((d) => d.value === u.colSize);
    }), a = (c) => {
      const { renderParams: m } = e, { widget: u } = m, { options: d } = u, { reactData: p } = t, { widgetObjList: w } = p, v = u.children.filter((S) => S.name), D = v.slice(d.colSize);
      if (D.length) {
        const S = r.findTree(w, (x) => x.id === u.id, { children: "children" });
        if (S) {
          const { items: x, index: h } = S;
          h >= x.length - 1 ? x.push(...D) : x.splice(h + 1, 0, ...D);
        }
      }
      d.colSpan = c.value, u.children = r.range(0, d.colSize).map((S, x) => v[x] || t.createEmptyWidget());
    };
    return () => {
      const { renderParams: c } = e, { widget: m } = c, u = n.value;
      return o(Nn, {
        class: `vxe-form-design--widget-${u}-form`,
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: m.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.rowProp.colSize"),
              field: "colSize",
              itemRender: { name: "VxeRadioGroup", options: s.value, props: { type: "button" } }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.rowProp.layout")
            }, {
              default() {
                const d = l.value;
                return d ? d.list.map((p, w) => o(zl, {
                  key: w,
                  class: [`vxe-form-design--widget-${u}-form-row`, {
                    "is--active": p.value === m.options.colSpan
                  }],
                  onClick() {
                    a(p);
                  }
                }, {
                  default() {
                    return p.spans.map((v, D) => o(Bl, {
                      key: `${w}${D}`,
                      class: `vxe-form-design--widget-${u}-form-col`,
                      span: v
                    }, {
                      default() {
                        return o("div", {}, `${i[v]}`);
                      }
                    }));
                  }
                })) : [];
              }
            })
          ];
        }
      });
    };
  }
}), m0 = pt({
  name: "ViewColItem",
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    span: Number,
    colItemIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormDesign", null);
    if (!t)
      return () => [];
    const { reactData: n } = t, s = (l) => {
      l.stopPropagation();
      const a = l.currentTarget, c = l.dataTransfer, m = a.getAttribute("data-widget-id") || "", u = t.getWidgetById(m);
      c && c.setData("text/plain", m), n.sortWidget = u, n.dragWidget = null;
    }, i = (l) => {
      const { parentWidget: a, colItemIndex: c } = e, { widgetObjList: m, sortWidget: u } = n, d = a.children[c], p = t.internalData;
      if (l.stopPropagation(), u && a && u.id !== a.id) {
        if (rl(u))
          return;
        if (!rl(d)) {
          const w = r.findTree(m, (v) => v && v.id === u.id, { children: "children" });
          if (w) {
            const { item: v, index: D, items: S, parent: x } = w;
            if (a.children.length !== a.options.colSize && (a.children = r.range(0, a.options.colSize).map((h) => a.children[h] || t.createEmptyWidget())), x && x.id === a.id)
              a.children[c] = v, a.children[D] = d;
            else {
              if (d && d.name)
                return;
              a.children[c] = v, S.splice(D, 1);
            }
            l.preventDefault(), p.lastDragTime = Date.now(), t.dispatchEvent("drag-widget", { widget: v }, l);
          }
        }
      }
    };
    return () => {
      const { widget: l, span: a } = e, { dragWidget: c, activeWidget: m, sortWidget: u } = n;
      return o(kt, {
        span: a,
        padding: !1
      }, {
        default() {
          const d = l ? l.name : "", p = Cn.get(d) || {}, w = p.renderFormDesignWidgetEdit || p.renderFormDesignWidgetView, v = l || { name: d }, D = { widget: l, readonly: !1, disabled: !1, isEditMode: !0, isViewMode: !1, $formDesign: t, $formView: null }, S = m && l && m.id === l.id, x = !w;
          return o("div", {
            class: "vxe-form-design--widget-row-view",
            "data-widget-id": l.id,
            draggable: !x,
            onDragstart: s,
            onDragenter: i,
            onClick(h) {
              l && t.handleClickWidget(h, l);
            }
          }, [
            o("div", {
              class: ["vxe-form-design--widget-row-view-item-inner", {
                "is--empty": x,
                "is--active": S,
                "is--sort": u && l && u.id === l.id,
                "is--drag": c && l && c.id === l.id
              }]
            }, [
              w ? o("div", {
                class: "vxe-form-design--widget-row-view-item-wrapper"
              }, [
                o("div", {
                  class: "vxe-form-design--widget-row-view-item-box vxe-form--item-row"
                }, Nt(w(v, D))),
                S ? o("div", {
                  class: "vxe-form-design--preview-item-operate"
                }, [
                  o(Vn, {
                    icon: ht().FORM_DESIGN_WIDGET_COPY,
                    status: "primary",
                    size: "mini",
                    circle: !0,
                    onClick(h) {
                      t.handleCopyWidget(h.$event, l);
                    }
                  }),
                  o(Vn, {
                    icon: ht().FORM_DESIGN_WIDGET_DELETE,
                    status: "danger",
                    size: "mini",
                    circle: !0,
                    onClick(h) {
                      t.handleRemoveWidget(h.$event, l);
                    }
                  })
                ]) : Ve()
              ]) : o("div", {
                class: "vxe-form-design--widget-row-view-empty"
              }, "控件位置")
            ])
          ]);
        }
      });
    };
  }
}), g0 = pt({
  name: "WidgetRowEdit",
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = _(() => {
      const { renderParams: n } = e, { widget: s } = n, { options: i } = s, { colSpan: l } = i;
      return (l ? `${l}`.split(",") : []).map((m) => Number(m));
    });
    return () => {
      const { renderParams: n } = e, { widget: s } = n;
      return o(Nr, {
        field: s.field
      }, {
        default() {
          return t.value.map((l, a) => o(m0, {
            key: a,
            parentWidget: s,
            widget: s.children[a],
            span: l,
            colItemIndex: a
          }));
        }
      });
    };
  }
}), h0 = pt({
  name: "WidgetRowView",
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormDesign", null), n = mt("$xeFormView", null), s = _(() => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, { colSpan: c } = a;
      return (c ? `${c}`.split(",") : []).map((d) => Number(d));
    });
    return () => {
      const { renderParams: i } = e, { widget: l } = i, a = s.value;
      return o(zl, {}, {
        default() {
          return a.map((c, m) => o(Bl, {
            key: m,
            class: "vxe-form--item-row",
            span: c
          }, {
            default() {
              const u = l.children[m];
              if (u) {
                const { name: d } = u, w = (Cn.get(d) || {}).renderFormDesignWidgetView, v = u, D = !!t, S = { widget: u, readonly: !1, disabled: !1, isEditMode: D, isViewMode: !D, $formDesign: t, $formView: n };
                if (w)
                  return Nt(w(v, S));
              }
              return Ve();
            }
          }));
        }
      });
    };
  }
}), v0 = () => ({
  title: yo,
  group: "layout",
  icon: "vxe-icon-subtable",
  options: {
    showCheckbox: !1
  }
}), b0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    if (!mt("$xeFormDesign", null))
      return () => [];
    const { computeKebabCaseName: n } = Dn(e);
    return () => {
      const { renderParams: s } = e, { widget: i } = s, { options: l } = i, a = n.value;
      return o(Nn, {
        class: `vxe-form-design--widget-${a}-form`,
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: l
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: i.title,
                  "onUpdate:modelValue"(c) {
                    i.title = c;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.subtableProp.showCheckbox"),
              field: "showCheckbox"
            }, {
              default() {
                return o(ao, {
                  modelValue: l.showCheckbox,
                  "onUpdate:modelValue"(c) {
                    l.showCheckbox = c;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), x0 = pt({
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    childIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormDesign", null), n = mt("$xeFormView", null);
    if (!t)
      return () => [];
    const { reactData: s } = t, i = (a) => {
      a.stopPropagation();
      const c = a.currentTarget, m = a.dataTransfer, u = c.getAttribute("data-widget-id") || "", d = t.getWidgetById(u);
      m && m.setData("text/plain", u), s.sortWidget = d, s.dragWidget = null;
    }, l = (a) => {
      const { parentWidget: c, childIndex: m } = e, { widgetObjList: u, sortWidget: d } = s, p = c.children[m], w = t.internalData, { lastDragTime: v } = w;
      if (a.stopPropagation(), v && v > Date.now() - 300) {
        a.preventDefault();
        return;
      }
      if (d && p && c) {
        if (d.id === c.id || d.id === p.id || rl(d))
          return;
        if (p && !rl(p)) {
          const D = r.findTree(u, (S) => S.id === d.id, { children: "children" });
          if (D) {
            const { item: S, index: x, items: h, parent: O } = D;
            O && O.id === c.id ? (c.children[m] = S, c.children[x] = p) : (c.children.splice(m, 0, S), h.splice(x, 1)), w.lastDragTime = Date.now(), t.dispatchEvent("drag-widget", { widget: S }, a);
          }
        }
      }
    };
    return () => {
      const { widget: a } = e, { dragWidget: c, activeWidget: m, sortWidget: u } = s, d = a ? a.name : "", p = Cn.get(d) || {}, w = p.renderFormDesignWidgetSubtableEditView || p.renderFormDesignWidgetSubtableCellView || p.renderFormDesignWidgetSubtableDefaultView, v = p.renderFormDesignWidgetEdit || p.renderFormDesignWidgetView, D = a || { name: d }, S = !!t, x = { widget: a, readonly: !1, disabled: !1, isEditMode: S, isViewMode: !S, $formDesign: t, $formView: n }, h = m && a && m.id === a.id, O = { name: d }, g = {
        $table: null,
        $grid: null,
        seq: "",
        column: {
          field: a.field,
          title: a.title
        },
        columnIndex: 0,
        $columnIndex: 0,
        _columnIndex: 0,
        rowid: "",
        row: {},
        rowIndex: 0,
        $rowIndex: 0,
        _rowIndex: 0,
        isEdit: !1,
        isHidden: !1,
        fixed: null,
        type: "",
        level: 1,
        visibleData: [],
        items: [],
        data: [],
        widget: a
      };
      return o("div", {
        class: ["vxe-form-design--widget-subtable-view-item", {
          "is--active": h,
          "is--sort": u && a && u.id === a.id,
          "is--drag": c && a && c.id === a.id
        }],
        draggable: !0,
        "data-widget-id": a.id,
        onDragstart: i,
        onDragenter: l,
        onClick(b) {
          a && t.handleClickWidget(b, a);
        }
      }, [
        o("div", {
          class: "vxe-form-design--widget-subtable-view-item-wrapper"
        }, [
          o("div", {
            class: "vxe-form-design--widget-subtable-view-item-box vxe-form--item-row"
          }, w ? o(kt, {
            class: ["vxe-form-design--widget-render-form-item"],
            title: a.title,
            field: a.field,
            itemRender: {}
          }, {
            default() {
              return Nt(w(O, g));
            }
          }) : v ? Nt(v(D, x)) : []),
          h ? o("div", {
            class: "vxe-form-design--preview-item-operate"
          }, [
            o(Vn, {
              icon: ht().FORM_DESIGN_WIDGET_COPY,
              status: "primary",
              size: "mini",
              circle: !0,
              onClick(b) {
                t.handleCopyWidget(b.$event, a);
              }
            }),
            o(Vn, {
              icon: ht().FORM_DESIGN_WIDGET_DELETE,
              status: "danger",
              size: "mini",
              circle: !0,
              onClick(b) {
                t.handleRemoveWidget(b.$event, a);
              }
            })
          ]) : Ve()
        ])
      ]);
    };
  }
}), y0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormDesign", null);
    if (!t)
      return () => [];
    const { reactData: n } = t, s = (l) => {
      const { sortWidget: a, widgetObjList: c } = n, { renderParams: m } = e, { widget: u } = m;
      if (l.stopPropagation(), !(!a || !u || u.id === a.id)) {
        if (rl(a)) {
          Ce.modal && Ce.modal.message({
            content: Pe("vxe.formDesign.widgetProp.subtableProp.errSubDrag"),
            status: "error",
            id: "errSubDrag"
          });
          return;
        }
        if (u.name && !u.children.some((d) => d.id === a.id)) {
          const d = r.findTree(c, (p) => p.id === a.id, { children: "children" });
          if (d) {
            const { item: p, index: w, items: v } = d;
            n.sortWidget = null, n.activeWidget = p, u.children.push(p), v.splice(w, 1), n.sortWidget = p;
          }
        }
      }
    }, i = (l) => {
      l.stopPropagation();
    };
    return () => {
      const { renderParams: l } = e, { widget: a } = l, { title: c, children: m, options: u } = a, { showCheckbox: d } = u;
      return o(kt, {
        title: c,
        className: "vxe-form-design--widget-subtable-form-item"
      }, {
        default() {
          return o("div", {
            class: "vxe-form-design--widget-subtable-view",
            onDragenter: i,
            onDragover: s
          }, [
            o("div", {
              class: "vxe-form-design--widget-subtable-view-left"
            }, [
              d ? o("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                o("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, [
                  o(nl)
                ]),
                o("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, [
                  o(nl)
                ])
              ]) : Ve(),
              o("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                o("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, Pe("vxe.formDesign.widgetProp.subtableProp.seqTitle")),
                o("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, "1")
              ])
            ]),
            o("div", {
              class: "vxe-form-design--widget-subtable-view-right"
            }, [
              o("div", {
                class: "vxe-form-design--widget-subtable-view-wrapper"
              }, [
                o(Fr, {
                  class: "vxe-form-design--widget-subtable-view-list",
                  tag: "div",
                  name: "vxe-form-design--widget-subtable-view-list"
                }, {
                  default: () => m ? m.map((p, w) => o(x0, {
                    key: p.id,
                    parentWidget: a,
                    widget: p,
                    childIndex: w
                  })) : []
                }),
                o("div", {
                  key: "empty",
                  class: "vxe-form-design--widget-subtable-view-empty"
                }, Pe("vxe.formDesign.widgetProp.subtableProp.colPlace"))
              ])
            ])
          ]);
        }
      });
    };
  }
}), C0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = Ce.getComponent("VxeGrid"), n = mt("$xeFormView", null), { computeKebabCaseName: s } = Dn(e), i = ke(), l = ke([
      {}
    ]), a = _(() => n ? n.props.readonly : !1), c = _(() => {
      const { renderParams: w } = e, { widget: v } = w, { children: D, options: S } = v, x = a.value, h = [];
      return S.showCheckbox && h.push({
        type: "checkbox",
        width: 60,
        fixed: "left"
      }), h.push({
        type: "seq",
        width: 60,
        fixed: "left"
      }), D && D.forEach((O) => {
        const { name: g } = O, b = Cn.get(g) || {}, E = b.parseFormDesignWidgetSubtableColumn;
        let C = {
          field: O.field,
          title: O.title
        };
        E ? C = Object.assign(C, E({
          $formView: n,
          name: O.name,
          widget: O,
          readonly: !!x
        })) : x ? C.cellRender = {
          name: O.name,
          props: O.options
        } : C.editRender = {
          name: O.name,
          props: O.options
        };
        const V = b.renderFormDesignWidgetSubtableDefaultView, Q = b.renderFormDesignWidgetSubtableCellView || V, Z = b.renderFormDesignWidgetSubtableEditView, G = {};
        (V || Q) && (G.default = (ue) => {
          const { isEdit: Y, column: K } = ue, { editRender: L, cellRender: ye } = K, se = Object.assign({ widget: O }, ue);
          return Y && L && Q ? Nt(Q(L, se)) : V ? Nt(V(ye || {}, se)) : [];
        }), Z && (G.edit = (ue) => {
          const { column: Y } = ue, { editRender: K } = Y, L = Object.assign({ widget: O }, ue);
          return Nt(Z(K, L));
        }), C.slots = G, h.push(C);
      }), x || h.push({
        field: "action",
        title: "操作",
        fixed: "right",
        width: 80,
        slots: {
          default({ row: O }) {
            return o(Vn, {
              mode: "text",
              icon: "vxe-icon-delete",
              status: "error",
              onClick() {
                p(O);
              }
            });
          }
        }
      }), h;
    }), m = _(() => {
      const { renderParams: w } = e, { widget: v, isEditMode: D } = w, S = c.value, x = a.value, h = {
        border: !0,
        showOverflow: !0,
        height: 300,
        columnConfig: {
          resizable: !0,
          minWidth: 140
        },
        rowConfig: {
          keyField: "_id"
        },
        data: D ? l.value : n ? n.getItemValue(v) : null,
        columns: S,
        toolbarConfig: {
          zoom: !0,
          custom: !1,
          slots: {
            buttons: "toolbarButtons"
          }
        }
      };
      return x || (h.keepSource = !0, h.editConfig = {
        mode: "row",
        trigger: "click",
        showStatus: !0
      }), h;
    }), u = () => {
      const { renderParams: w } = e, { widget: v } = w, D = {
        _id: Date.now()
      };
      return r.each(v.children, (S) => {
        D[S.field] = null;
      }), D;
    }, d = () => {
      const { renderParams: w } = e, { widget: v } = w;
      if (n) {
        let D = n.getItemValue(v);
        r.isArray(D) || (D = []);
        const S = u();
        D.unshift(S), n.setItemValue(v, D.slice(0)).then(() => me().then(() => {
          const x = i.value;
          x && x.setEditRow(S);
        }));
      }
    }, p = (w) => {
      const { renderParams: v } = e, { widget: D } = v;
      if (n) {
        const S = n.getItemValue(D);
        S && n.setItemValue(D, S.filter((x) => x._id !== w._id));
      }
    };
    return () => {
      const { renderParams: w } = e, { widget: v } = w, D = s.value, S = m.value, x = a.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${D}`],
        title: v.title,
        field: v.field,
        span: 24
      }, {
        default() {
          return t ? o(t, Object.assign(Object.assign({}, S), { ref: i }), {
            toolbarButtons() {
              return x ? [] : [
                o(Vn, {
                  content: "新增",
                  icon: "vxe-icon-add",
                  status: "primary",
                  onClick: d
                })
              ];
            }
          }) : Ve();
        }
      });
    };
  }
}), w0 = () => ({
  title: yo,
  icon: "vxe-icon-input",
  query: !0,
  options: {
    placeholder: ""
  }
}), E0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: s.required,
                  "onUpdate:modelValue"(l) {
                    s.required = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), S0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        field: l.field,
        title: l.title,
        itemRender: {}
      }, {
        default() {
          return o("input", {
            class: "vxe-default-input",
            type: "text",
            placeholder: a.placeholder || Pe("vxe.base.pleaseInput"),
            value: t ? t.getItemValue(l) : null,
            onChange: s,
            onInput(m) {
              t && t.setItemValue(l, m.target.value);
            }
          });
        }
      });
    };
  }
}), D0 = () => ({
  title: yo,
  icon: "vxe-icon-textarea",
  query: !0,
  options: {
    placeholder: ""
  }
}), O0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: s.required,
                  "onUpdate:modelValue"(l) {
                    s.required = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), T0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o("textarea", {
            class: "vxe-default-textarea",
            placeholder: a.placeholder || Pe("vxe.base.pleaseInput"),
            value: t ? t.getItemValue(l) : null,
            onChange: s,
            onInput(m) {
              t && t.setItemValue(l, m.target.value);
            }
          });
        }
      });
    };
  }
}), M0 = () => ({
  title: yo,
  icon: "vxe-icon-select",
  query: !0,
  options: {
    options: r.range(0, 3).map((e, t) => ({
      value: Pe("vxe.formDesign.widgetProp.dataSource.defValue", [t + 1])
    }))
  }
}), I0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { renderDataSourceFormItem: t } = na(e, {
      isSubOption: !0
    }), { computeKebabCaseName: n } = Dn(e);
    return () => {
      const { renderParams: s } = e, { widget: i } = s, l = n.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${l}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: i.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: i.title,
                  "onUpdate:modelValue"(a) {
                    i.title = a;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: i.required,
                  "onUpdate:modelValue"(a) {
                    i.required = a;
                  }
                });
              }
            }),
            t()
          ];
        }
      });
    };
  }
}), V0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: l } = e, { widget: a } = l;
      if (t) {
        const c = t ? t.getItemValue(a) : null;
        t.updateWidgetStatus(a, c);
      }
    }, i = () => {
      const { renderParams: l } = e, { widget: a } = l, { options: c } = a.options;
      return c ? c.map((m) => m.options ? o("optgroup", {
        label: m.value
      }, m.options.map((u) => o("option", {
        value: u.value
      }, u.value))) : o("option", {}, m.value)) : [];
    };
    return () => {
      const { renderParams: l } = e, { widget: a, isViewMode: c } = l, m = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${m}`],
        field: a.field,
        title: a.title,
        itemRender: {}
      }, {
        default() {
          return o("select", {
            class: "vxe-default-select",
            value: t ? t.getItemValue(a) : null,
            onChange: s
          }, c ? i() : []);
        }
      });
    };
  }
}), P0 = () => ({
  title: yo,
  icon: "vxe-icon-input",
  query: !0,
  options: {
    placeholder: ""
  }
}), k0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: s.required,
                  "onUpdate:modelValue"(l) {
                    s.required = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), $0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        field: l.field,
        title: l.title,
        itemRender: {}
      }, {
        default() {
          return o(Wn, {
            modelValue: t ? t.getItemValue(l) : null,
            placeholder: a.placeholder,
            onChange: s,
            "onUpdate:modelValue"(m) {
              t && t.setItemValue(l, m);
            }
          });
        }
      });
    };
  }
}), R0 = () => ({
  title: yo,
  icon: "vxe-icon-number",
  query: !0,
  options: {
    placeholder: ""
  }
}), N0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: s.required,
                  "onUpdate:modelValue"(l) {
                    s.required = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), Vi = pt({
  name: "VxeNumberInput",
  props: {
    modelValue: [String, Number],
    immediate: {
      type: Boolean,
      default: !0
    },
    name: String,
    type: {
      type: String,
      default: "number"
    },
    clearable: {
      type: Boolean,
      default: () => oe().numberInput.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => oe().numberInput.size || oe().size
    },
    multiple: Boolean,
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => oe().numberInput.exponential
    },
    // number、integer、float
    controls: {
      type: Boolean,
      default: () => oe().numberInput.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: null
    },
    prefixIcon: String,
    suffixIcon: String,
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeForm", null), l = mt("xeFormItemInfo", null), a = r.uniqueId(), { computeSize: c } = dn(e), m = Rt({
      isFocus: !1,
      isActivated: !1,
      inputValue: e.modelValue
    }), u = {
      dnTimeout: void 0
    }, d = ke(), p = ke(), w = ke(), v = {
      refElem: d,
      refInput: p
    }, D = {
      xID: a,
      props: e,
      context: t,
      reactData: m,
      internalData: u,
      getRefMaps: () => v
    };
    let S = {};
    const x = _(() => {
      const { readonly: z } = e;
      return z === null ? i ? i.props.readonly : !1 : z;
    }), h = _(() => {
      const { disabled: z } = e;
      return z === null ? i ? i.props.disabled : !1 : z;
    }), O = _(() => {
      const { type: z, digits: R } = e;
      let le = R;
      return le === null && (le = oe().numberInput.digits, le === null && z === "amount" && (le = 2)), r.toInteger(le) || 1;
    }), g = _(() => {
      const { type: z } = e;
      return z === "float" || z === "amount";
    }), b = _(() => {
      const { type: z } = e, R = O.value, le = g.value, F = e.step;
      return z === "integer" ? r.toInteger(F) || 1 : le ? r.toNumber(F) || 1 / Math.pow(10, R) : r.toNumber(F) || 1;
    }), E = _(() => e.clearable), C = _(() => {
      const { multiple: z } = e;
      return x.value || z;
    }), V = _(() => {
      const { placeholder: z } = e;
      if (z)
        return Bn(z);
      const R = oe().numberInput.placeholder;
      return R ? Bn(R) : Pe("vxe.base.pleaseInput");
    }), Q = _(() => {
      const { maxLength: z, maxlength: R } = e;
      return r.toNumber(z || R) || 16;
    }), Z = _(() => {
      const { immediate: z } = e;
      return z;
    }), G = _(() => {
      const { type: z } = e, { inputValue: R } = m;
      return z === "integer" ? r.toInteger(gs(R)) : r.toNumber(gs(R));
    }), ue = _(() => {
      const { type: z } = e, { inputValue: R } = m, le = O.value;
      return z === "amount" ? r.commafy(r.toNumber(R), { digits: le }) : r.toString(R);
    }), Y = _(() => {
      const { min: z } = e, { inputValue: R } = m, le = G.value;
      return (R || R === 0) && z !== null ? le <= r.toNumber(z) : !1;
    }), K = _(() => {
      const { max: z } = e, { inputValue: R } = m, le = G.value;
      return (R || R === 0) && z !== null ? le >= r.toNumber(z) : !1;
    }), L = (z) => r.eqNull(z) ? "" : `${z}`, ye = (z) => {
      const { exponential: R } = e, le = Q.value, F = O.value, N = g.value ? Pc(z, F) : L(z);
      return R && (z === N || L(z).toLowerCase() === r.toNumber(N).toExponential()) ? z : N.slice(0, le);
    }, se = (z) => {
      const { inputValue: R } = m;
      S.dispatchEvent(z.type, { value: R }, z);
    }, P = (z, R, le) => {
      const F = Ei(z) ? null : Number(z), re = F !== e.modelValue;
      re && s("update:modelValue", F), m.inputValue !== R && me(() => {
        m.inputValue = R || "";
      }), S.dispatchEvent("input", { value: F }, le), re && (S.dispatchEvent("change", { value: F }, le), i && l && i.triggerItemEvent(le, l.itemConfig.field, F));
    }, M = (z, R) => {
      const le = Z.value, F = z === "" || r.eqNull(z) ? null : r.toNumber(z);
      m.inputValue = z, le ? P(F, z, R) : S.dispatchEvent("input", { value: F }, R);
    }, I = (z) => {
      const le = z.target.value;
      M(le, z);
    }, B = (z) => {
      Z.value || se(z);
    }, H = (z) => {
      m.isFocus = !0, m.isActivated = !0, se(z);
    }, ce = (z) => {
      if (!h.value) {
        const { inputValue: le } = m;
        S.dispatchEvent("prefix-click", { value: le }, z);
      }
    }, A = (z, R) => {
      focus(), P(null, "", z), S.dispatchEvent("clear", { value: R }, z);
    }, j = (z) => {
      if (!h.value) {
        const { inputValue: le } = m;
        S.dispatchEvent("suffix-click", { value: le }, z);
      }
    }, fe = () => {
      const { inputValue: z } = m, R = O.value;
      if (g.value && z) {
        let F = "", re = null;
        z && (F = Pc(z, R), re = Number(F)), z !== re && P(re, F, { type: "init" });
      }
    }, pe = (z) => e.max === null || r.toNumber(z) <= r.toNumber(e.max), ne = (z) => e.min === null || r.toNumber(z) >= r.toNumber(e.min), $ = () => {
      const { type: z, min: R, max: le, exponential: F } = e, { inputValue: re } = m;
      if (!C.value) {
        if (Ei(re)) {
          let ee = null, be = re;
          (R || R === 0) && (ee = r.toNumber(R), be = `${ee}`), P(ee, `${be || ""}`, { type: "check" });
          return;
        }
        if (re || R || le) {
          let ee = z === "integer" ? r.toInteger(gs(re)) : r.toNumber(gs(re));
          if (ne(ee) ? pe(ee) || (ee = le) : ee = R, F) {
            const we = L(re).toLowerCase();
            we === r.toNumber(ee).toExponential() && (ee = we);
          }
          const be = ye(ee);
          P(Ei(be) ? null : Number(be), be, { type: "check" });
        }
      }
    }, J = (z) => {
      const { inputValue: R } = m, le = Z.value, F = R ? Number(R) : null;
      le || P(F, L(R), z), $(), m.isFocus = !1, m.isActivated = !1, S.dispatchEvent("blur", { value: F }, z), i && l && i.triggerItemEvent(z, l.itemConfig.field, F);
    }, ge = (z, R) => {
      const { min: le, max: F, type: re } = e, { inputValue: N } = m, ee = b.value, be = re === "integer" ? r.toInteger(gs(N)) : r.toNumber(gs(N)), we = z ? r.add(be, ee) : r.subtract(be, ee);
      let Te;
      ne(we) ? pe(we) ? Te = we : Te = F : Te = le, M(ye(Te), R);
    }, Oe = (z) => {
      const R = h.value, le = x.value, F = Y.value;
      Ae(), !R && !le && !F && ge(!1, z), S.dispatchEvent("next-number", { value: m.inputValue }, z);
    }, Se = (z) => {
      u.dnTimeout = window.setTimeout(() => {
        Oe(z), Se(z);
      }, 60);
    }, de = (z) => {
      const R = h.value, le = x.value, F = K.value;
      Ae(), !R && !le && !F && ge(!0, z), S.dispatchEvent("prev-number", { value: m.inputValue }, z);
    }, Ie = (z) => {
      const R = ut.hasKey(z, Yt.ARROW_UP), le = ut.hasKey(z, Yt.ARROW_DOWN);
      (R || le) && (z.preventDefault(), R ? de(z) : Oe(z));
    }, je = (z) => {
      const { exponential: R, controls: le } = e, F = z.ctrlKey, re = z.shiftKey, N = z.altKey, ee = z.keyCode, be = ut.hasKey(z, Yt.ESCAPE), we = ut.hasKey(z, Yt.ARROW_UP), Te = ut.hasKey(z, Yt.ARROW_DOWN);
      !F && !re && !N && (ut.hasKey(z, Yt.SPACEBAR) || (!R || ee !== 69) && ee >= 65 && ee <= 90 || ee >= 186 && ee <= 188 || ee >= 191) && z.preventDefault(), be ? $() : (we || Te) && le && Ie(z), se(z);
    }, Ue = (z) => {
      se(z);
    }, Ae = () => {
      const { dnTimeout: z } = u;
      z && (clearTimeout(z), u.dnTimeout = void 0);
    }, _e = (z) => {
      u.dnTimeout = window.setTimeout(() => {
        de(z), _e(z);
      }, 60);
    }, it = (z) => {
      if (Ae(), z.button === 0) {
        const R = ta(z.currentTarget, "is--prev");
        R ? de(z) : Oe(z), u.dnTimeout = window.setTimeout(() => {
          R ? _e(z) : Se(z);
        }, 500);
      }
    }, vt = (z) => {
      if (e.controls && m.isActivated) {
        const R = z.deltaY;
        R > 0 ? Oe(z) : R < 0 && de(z), z.preventDefault();
      }
      se(z);
    }, dt = (z) => {
      se(z);
    }, at = (z) => {
      const { isActivated: R } = m, le = d.value, F = w.value;
      !h.value && R && (m.isActivated = jn(z, le).flag || jn(z, F).flag, m.isActivated || $());
    }, Et = (z) => {
      const { clearable: R } = e;
      if (!h.value) {
        const F = ut.hasKey(z, Yt.TAB), re = ut.hasKey(z, Yt.DELETE);
        let N = m.isActivated;
        F && (N && $(), N = !1, m.isActivated = N), re && R && N && A(z, null);
      }
    }, Qe = () => {
      const { isActivated: z } = m;
      z && $();
    }, De = () => {
      const z = K.value, R = Y.value;
      return o("div", {
        class: "vxe-input--control-icon"
      }, [
        o("div", {
          class: "vxe-input--number-icon"
        }, [
          o("div", {
            class: ["vxe-input--number-btn is--prev", {
              "is--disabled": z
            }],
            onMousedown: it,
            onMouseup: Ae,
            onMouseleave: Ae
          }, [
            o("i", {
              class: ht().NUMBER_INPUT_PREV_NUM
            })
          ]),
          o("div", {
            class: ["vxe-input--number-btn is--next", {
              "is--disabled": R
            }],
            onMousedown: it,
            onMouseup: Ae,
            onMouseleave: Ae
          }, [
            o("i", {
              class: ht().NUMBER_INPUT_NEXT_NUM
            })
          ])
        ])
      ]);
    }, Re = () => {
      const { prefixIcon: z } = e, R = n.prefix;
      return R || z ? o("div", {
        class: "vxe-number-input--prefix",
        onClick: ce
      }, [
        o("div", {
          class: "vxe-number-input--prefix-icon"
        }, R ? Nt(R({})) : [
          o("i", {
            class: z
          })
        ])
      ]) : null;
    }, Be = () => {
      const { suffixIcon: z } = e, { inputValue: R } = m, le = n.suffix, F = h.value, re = E.value;
      return o("div", {
        class: ["vxe-number-input--suffix", {
          "is--clear": re && !F && !(R === "" || r.eqNull(R))
        }]
      }, [
        re ? o("div", {
          class: "vxe-number-input--clear-icon",
          onClick: A
        }, [
          o("i", {
            class: ht().INPUT_CLEAR
          })
        ]) : Ve(),
        ve(),
        le || z ? o("div", {
          class: "vxe-number-input--suffix-icon",
          onClick: j
        }, le ? Nt(le({})) : [
          o("i", {
            class: z
          })
        ]) : Ve()
      ]);
    }, ve = () => {
      const { controls: z } = e;
      return z ? De() : Ve();
    };
    S = {
      dispatchEvent: (z, R, le) => {
        s(z, Zt(le, { $numberInput: D }, R));
      },
      focus() {
        const z = p.value;
        return m.isActivated = !0, z.focus(), me();
      },
      blur() {
        return p.value.blur(), m.isActivated = !1, me();
      },
      select() {
        return p.value.select(), m.isActivated = !1, me();
      }
    }, Object.assign(D, S);
    const q = () => {
      const { className: z, controls: R, type: le, align: F, name: re, autocomplete: N, autoComplete: ee } = e, { inputValue: be, isFocus: we, isActivated: Te } = m, ze = c.value, st = h.value, ct = x.value, Ke = ue.value;
      if (ct)
        return o("div", {
          ref: d,
          class: ["vxe-number-input--readonly", `type--${le}`, z]
        }, Ke);
      const wt = C.value, St = Q.value, Dt = V.value, Wt = E.value, nn = Re(), zt = Be();
      return o("div", {
        ref: d,
        class: ["vxe-number-input", `type--${le}`, z, {
          [`size--${ze}`]: ze,
          [`is--${F}`]: F,
          "is--controls": R,
          "is--prefix": !!nn,
          "is--suffix": !!zt,
          "is--disabled": st,
          "is--active": Te,
          "show--clear": Wt && !st && !(be === "" || r.eqNull(be))
        }],
        spellcheck: !1
      }, [
        nn || Ve(),
        o("div", {
          class: "vxe-number-input--wrapper"
        }, [
          o("input", {
            ref: p,
            class: "vxe-number-input--inner",
            value: !we && le === "amount" ? Ke : be,
            name: re,
            type: "text",
            placeholder: Dt,
            maxlength: St,
            readonly: wt,
            disabled: st,
            autocomplete: ee || N,
            onKeydown: je,
            onKeyup: Ue,
            onWheel: vt,
            onClick: dt,
            onInput: I,
            onChange: B,
            onFocus: H,
            onBlur: J
          })
        ]),
        zt || Ve()
      ]);
    };
    return D.renderVN = q, lt(() => e.modelValue, (z) => {
      m.inputValue = z;
    }), lt(() => e.type, () => {
      Object.assign(m, {
        inputValue: e.modelValue
      }), fe();
    }), wn(() => {
      ut.on(D, "mousedown", at), ut.on(D, "keydown", Et), ut.on(D, "blur", Qe);
    }), Us(() => {
      m.isFocus = !1, Ae(), $(), ut.off(D, "mousedown"), ut.off(D, "keydown"), ut.off(D, "blur");
    }), fe(), D;
  },
  render() {
    return this.renderVN();
  }
}), F0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o(Vi, {
            modelValue: t ? t.getItemValue(l) : null,
            placeholder: a.placeholder,
            onChange: s,
            "onUpdate:modelValue"(m) {
              t && t.setItemValue(l, m);
            }
          });
        }
      });
    };
  }
}), L0 = () => ({
  title: yo,
  icon: "vxe-icon-calendar",
  options: {
    placeholder: "",
    defaultValue: {
      type: "",
      value: ""
    }
  }
}), A0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            // renderDefaultValueFormItem(),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: s.required,
                  "onUpdate:modelValue"(l) {
                    s.required = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), B0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o(Il, {
            modelValue: t ? t.getItemValue(l) : null,
            placeholder: a.placeholder,
            onChange: s,
            "onUpdate:modelValue"(m) {
              t && t.setItemValue(l, m);
            }
          });
        }
      });
    };
  }
}), _0 = () => ({
  title: yo,
  icon: "vxe-icon-textarea",
  options: {
    placeholder: ""
  }
}), W0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: s.required,
                  "onUpdate:modelValue"(l) {
                    s.required = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), z0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o(Wl, {
            modelValue: t ? t.getItemValue(l) : null,
            placeholder: a.placeholder,
            resize: "node",
            onChange: s,
            "onUpdate:modelValue"(m) {
              t && t.setItemValue(l, m);
            }
          });
        }
      });
    };
  }
}), H0 = () => ({
  title: yo,
  icon: "vxe-icon-switch",
  query: !0,
  options: {}
}), j0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), q0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, a = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${a}`],
        field: l.field,
        title: l.title,
        itemRender: {}
      }, {
        default() {
          return o(ao, {
            modelValue: t ? t.getItemValue(l) : null,
            onChange: s,
            "onUpdate:modelValue"(c) {
              t && t.setItemValue(l, c);
            }
          });
        }
      });
    };
  }
}), U0 = () => ({
  title: yo,
  icon: "vxe-icon-select",
  query: !0,
  options: {
    placeholder: "",
    options: r.range(0, 3).map((e, t) => ({
      value: Pe("vxe.formDesign.widgetProp.dataSource.defValue", [t + 1])
    })),
    multiple: !1
  }
}), G0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { renderDataSourceFormItem: t } = na(e, {
      isSubOption: !1
    }), { computeKebabCaseName: n } = Dn(e);
    return () => {
      const { renderParams: s } = e, { widget: i } = s, l = n.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${l}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: i.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: i.title,
                  "onUpdate:modelValue"(a) {
                    i.title = a;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            t(),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: i.required,
                  "onUpdate:modelValue"(a) {
                    i.required = a;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), K0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l, isViewMode: a } = i, { options: c } = l, m = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${m}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o(vs, {
            modelValue: t ? t.getItemValue(l) : null,
            placeholder: c.placeholder || Pe("vxe.base.pleaseSelect"),
            options: a ? c.options : [],
            optionProps: { label: "value", value: "value" },
            onChange: s,
            "onUpdate:modelValue"(u) {
              t && t.setItemValue(l, u);
            }
          });
        }
      });
    };
  }
}), Y0 = () => ({
  title: yo,
  icon: "vxe-icon-tree-select",
  query: !0,
  options: {
    placeholder: "",
    options: r.range(0, 3).map((e, t) => ({
      value: Pe("vxe.formDesign.widgetProp.dataSource.defValue", [t + 1])
    })),
    multiple: !1
  }
}), X0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: s.required,
                  "onUpdate:modelValue"(l) {
                    s.required = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});
function hm() {
  return r.uniqueId("node_");
}
const Pi = pt({
  name: "VxeTree",
  props: {
    data: Array,
    height: [String, Number],
    minHeight: {
      type: [String, Number],
      default: () => oe().tree.minHeight
    },
    loading: Boolean,
    loadingConfig: Object,
    accordion: {
      type: Boolean,
      default: () => oe().tree.accordion
    },
    childrenField: {
      type: String,
      default: () => oe().tree.childrenField
    },
    valueField: {
      type: String,
      default: () => oe().tree.valueField
    },
    keyField: {
      type: String,
      default: () => oe().tree.keyField
    },
    parentField: {
      type: String,
      default: () => oe().tree.parentField
    },
    titleField: {
      type: String,
      default: () => oe().tree.titleField
    },
    hasChildField: {
      type: String,
      default: () => oe().tree.hasChildField
    },
    // mapChildrenField: {
    //   type: String as PropType<VxeTreePropTypes.MapChildrenField>,
    //   default: () => getConfig().tree.mapChildrenField
    // },
    transform: Boolean,
    // 已废弃
    isCurrent: Boolean,
    // 已废弃
    isHover: Boolean,
    showLine: {
      type: Boolean,
      default: () => oe().tree.showLine
    },
    trigger: String,
    indent: {
      type: Number,
      default: () => oe().tree.indent
    },
    showRadio: {
      type: Boolean,
      default: () => oe().tree.showRadio
    },
    checkNodeKey: {
      type: [String, Number],
      default: () => oe().tree.checkNodeKey
    },
    radioConfig: Object,
    showCheckbox: {
      type: Boolean,
      default: () => oe().tree.showCheckbox
    },
    checkNodeKeys: {
      type: Array,
      default: () => oe().tree.checkNodeKeys
    },
    checkboxConfig: Object,
    nodeConfig: Object,
    lazy: Boolean,
    toggleMethod: Function,
    loadMethod: Function,
    showIcon: {
      type: Boolean,
      default: !0
    },
    iconOpen: {
      type: String,
      default: () => oe().tree.iconOpen
    },
    iconClose: {
      type: String,
      default: () => oe().tree.iconClose
    },
    iconLoaded: {
      type: String,
      default: () => oe().tree.iconLoaded
    },
    size: {
      type: String,
      default: () => oe().tree.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "update:checkNodeKey",
    "update:checkNodeKeys",
    "node-click",
    "node-dblclick",
    "current-change",
    "radio-change",
    "checkbox-change",
    "load-success",
    "load-error"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = ke(), c = Rt({
      currentNode: null,
      nodeMaps: {},
      selectRadioKey: e.checkNodeKey,
      treeList: [],
      treeExpandedMaps: {},
      treeExpandLazyLoadedMaps: {},
      selectCheckboxMaps: {},
      indeterminateCheckboxMaps: {}
    }), m = {}, u = {
      refElem: a
    }, d = _(() => e.titleField || "title"), p = _(() => e.keyField || "id"), w = _(() => {
      const q = p.value;
      return e.valueField || q;
    }), v = _(() => e.parentField || "parentId"), D = _(() => e.childrenField || "children"), S = _(() => e.hasChildField || "hasChild"), x = _(() => {
      const q = b.value, { isCurrent: z } = q;
      return r.isBoolean(z) ? z : e.isCurrent;
    }), h = _(() => {
      const q = b.value, { isHover: z } = q;
      return r.isBoolean(z) ? z : e.isHover;
    }), O = _(() => Object.assign({ showIcon: !0 }, oe().tree.radioConfig, e.radioConfig)), g = _(() => Object.assign({ showIcon: !0 }, oe().tree.checkboxConfig, e.checkboxConfig)), b = _(() => Object.assign({}, oe().tree.nodeConfig, e.nodeConfig)), E = _(() => Object.assign({}, oe().tree.loadingConfig, e.loadingConfig)), C = _(() => {
      const { height: q, minHeight: z } = e, R = {};
      return q && (R.height = cn(q)), z && (R.minHeight = cn(z)), R;
    }), V = {
      computeRadioOpts: O,
      computeCheckboxOpts: g,
      computeNodeOpts: b
    }, Q = {
      xID: i,
      props: e,
      context: t,
      internalData: m,
      reactData: c,
      getRefMaps: () => u,
      getComputeMaps: () => V
    }, Z = (q) => {
      const z = w.value, R = r.get(q, z);
      return r.eqNull(R) ? "" : encodeURIComponent(R);
    }, G = (q) => {
      const { treeExpandedMaps: z } = c, R = Z(q);
      return !!z[R];
    }, ue = (q) => {
      const { selectRadioKey: z } = c;
      return z === q;
    }, Y = (q) => ue(Z(q)), K = (q) => {
      const { selectCheckboxMaps: z } = c;
      return !!z[q];
    }, L = (q) => K(Z(q)), ye = (q) => {
      const { indeterminateCheckboxMaps: z } = c;
      return !!z[q];
    }, se = (q) => ye(Z(q)), P = (q) => {
      n("update:checkNodeKeys", q);
    }, M = (q) => {
      n("update:checkNodeKey", q);
    }, I = (q) => (q && (c.selectRadioKey = Z(q)), me()), B = (q, z) => (q && (r.isArray(q) || (q = [q]), ce(q.map((R) => Z(R)), z)), me()), H = (q, z) => (q && (r.isArray(q) || (q = [q]), ce(q, z)), me()), ce = (q, z) => {
      const R = Object.assign({}, c.selectCheckboxMaps);
      q.forEach((le) => {
        z ? R[le] = !0 : R[le] && delete R[le];
      }), c.selectCheckboxMaps = R;
    }, A = (q) => {
      const z = {};
      q && q.forEach((R) => {
        z[R] = !0;
      }), c.selectCheckboxMaps = z;
    }, j = (q, z, R) => {
      z ? R[q] || (R[q] = !0) : R[q] && delete R[q];
    }, fe = (q, z, R) => {
      n(q, Zt(R, { $tree: Q }, z));
    }, pe = (q) => {
      const z = w.value;
      return Promise.resolve(q.map((R) => {
        const le = Object.assign({}, R);
        let F = Z(le);
        return F || (F = hm(), r.set(le, z, F)), le;
      }));
    }, ne = {
      dispatchEvent: fe,
      clearCurrentNode() {
        return c.currentNode = null, me();
      },
      getCurrentNodeId() {
        const { currentNode: q } = c;
        return q ? Z(q) : null;
      },
      getCurrentNode() {
        const { currentNode: q, nodeMaps: z } = c;
        if (q) {
          const R = z[q];
          if (R)
            return R.item;
        }
        return null;
      },
      setCurrentNodeId(q) {
        const { nodeMaps: z } = c, R = z[q];
        return c.currentNode = R ? R.item : null, me();
      },
      setCurrentNode(q) {
        return c.currentNode = q, me();
      },
      clearRadioNode() {
        return c.selectRadioKey = null, me();
      },
      getRadioNodeId() {
        return c.selectRadioKey || null;
      },
      getRadioNode() {
        const { selectRadioKey: q, nodeMaps: z } = c;
        if (q) {
          const R = z[q];
          if (R)
            return R.item;
        }
        return null;
      },
      setRadioNodeId(q) {
        return c.selectRadioKey = q, me();
      },
      setRadioNode: I,
      setCheckboxNode: B,
      setCheckboxByNodeId: H,
      getCheckboxNodeIds() {
        const { selectCheckboxMaps: q } = c;
        return Object.keys(q);
      },
      getCheckboxNodes() {
        const { nodeMaps: q, selectCheckboxMaps: z } = c, R = [];
        return r.each(z, (le, F) => {
          const re = q[F];
          re && R.push(re.item);
        }), R;
      },
      clearCheckboxNode() {
        return c.selectCheckboxMaps = {}, me();
      },
      setAllCheckboxNode(q) {
        const z = {}, R = D.value;
        return q && r.eachTree(c.treeList, (le) => {
          const F = Z(le);
          z[F] = !0;
        }, { children: R }), c.selectCheckboxMaps = z, me();
      },
      clearExpandNode() {
        return ne.clearAllExpandNode();
      },
      clearAllExpandNode() {
        return r.each(c.nodeMaps, (q) => {
          q.treeLoaded = !1;
        }), c.treeExpandedMaps = {}, me();
      },
      setExpandByNodeId(q, z) {
        const R = Object.assign({}, c.treeExpandedMaps);
        return q && (r.isArray(q) || (q = [q]), q.forEach((le) => {
          j(le, z, R);
        }), c.treeExpandedMaps = R), me();
      },
      getExpandNodeIds() {
        const { treeExpandedMaps: q } = c;
        return Object.keys(q);
      },
      getExpandNodes() {
        const { nodeMaps: q, treeExpandedMaps: z } = c, R = [];
        return r.each(z, (le, F) => {
          const re = q[F];
          re && R.push(re.item);
        }), R;
      },
      setExpandNode(q, z) {
        const R = Object.assign({}, c.treeExpandedMaps);
        return q && (r.isArray(q) || (q = [q]), q.forEach((le) => {
          const F = Z(le);
          j(F, z, R);
        }), c.treeExpandedMaps = R), me();
      },
      toggleExpandByNodeId(q) {
        const z = Object.assign({}, c.treeExpandedMaps);
        return q && (r.isArray(q) || (q = [q]), q.forEach((R) => {
          j(R, !z[R], z);
        }), c.treeExpandedMaps = z), me();
      },
      toggleExpandNode(q) {
        const z = Object.assign({}, c.treeExpandedMaps);
        return q && (r.isArray(q) || (q = [q]), q.forEach((R) => {
          const le = Z(R);
          j(le, !z[le], z);
        }), c.treeExpandedMaps = z), me();
      },
      setAllExpandNode(q) {
        const z = {}, R = D.value;
        return q && r.eachTree(c.treeList, (le) => {
          const F = r.get(le, R);
          if (F && F.length) {
            const N = Z(le);
            z[N] = !0;
          }
        }, { children: R }), c.treeExpandedMaps = z, me();
      },
      reloadExpandNode(q) {
        const { lazy: z } = e;
        return z ? (ne.clearExpandLoaded(q), Ie(q)) : me();
      },
      clearExpandLoaded(q) {
        const { lazy: z } = e, { nodeMaps: R } = c;
        if (z) {
          const le = R[Z(q)];
          le && (le.treeLoaded = !1);
        }
        return me();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadChildrenNode(q, z) {
        const { lazy: R, transform: le } = e, { nodeMaps: F } = c;
        if (!R)
          return Promise.resolve([]);
        const re = D.value, N = F[Z(q)], ee = N ? N.level : 0, be = N ? N.nodes : [];
        return pe(z).then((we) => (r.eachTree(we, (Te, ze, st, ct, Ke, wt) => {
          const St = Z(Te);
          F[St] = {
            item: q,
            itemIndex: -1,
            items: st,
            parent: Ke || N.item,
            nodes: be.concat(wt),
            level: ee + wt.length,
            lineCount: 0,
            treeLoaded: !1
          };
        }, { children: re }), q[re] = we, le && (q[re] = we), Oe(q), we));
      },
      isExpandByNode: G,
      isCheckedByRadioNodeId: ue,
      isCheckedByRadioNode: Y,
      isCheckedByCheckboxNodeId: K,
      isIndeterminateByCheckboxNode: se,
      isCheckedByCheckboxNode: L
    }, $ = () => {
      const { treeList: q } = c, z = w.value, R = D.value, le = {};
      r.eachTree(q, (F, re, N, ee, be, we) => {
        let Te = Z(F);
        Te || (Te = hm(), r.set(F, z, Te)), le[Te] = {
          item: F,
          itemIndex: re,
          items: N,
          parent: be,
          nodes: we,
          level: we.length,
          lineCount: 0,
          treeLoaded: !1
        };
      }, { children: R }), c.nodeMaps = le;
    }, J = (q) => {
      const { transform: z } = e, R = p.value, le = v.value, F = D.value;
      z ? c.treeList = r.toArrayTree(q, { key: R, parentKey: le, mapChildren: F }) : c.treeList = q ? q.slice(0) : [], $();
    }, ge = (q, z, R) => {
      const { treeExpandedMaps: le } = c, F = D.value, re = Z(q);
      R.lineCount++, le[re] && r.arrayEach(q[F], (N, ee, be) => {
        (!z || ee < be.length - 1) && ge(N, !1, R);
      });
    }, Oe = (q) => {
      const { nodeMaps: z } = c;
      if (q) {
        const R = Z(q), le = z[R];
        le && r.lastArrayEach(le.nodes, (F) => {
          const re = Z(F), N = z[re];
          N && (N.lineCount = 0, ge(F, !0, N));
        });
      }
    }, Se = (q, z) => {
      const { showRadio: R, showCheckbox: le, trigger: F } = e, re = O.value, N = g.value, ee = x.value;
      let be = !1, we = !1, Te = !1, ze = !1;
      ee ? (be = !0, vt(q, z)) : c.currentNode && (c.currentNode = null), F === "node" && (ze = !0, Ue(q, z)), R && re.trigger === "node" && (we = !0, dt(q, z)), le && N.trigger === "node" && (Te = !0, it(q, z)), fe("node-click", { node: z, triggerCurrent: be, triggerRadio: we, triggerCheckbox: Te, triggerExpand: ze }, q);
    }, de = (q, z) => {
      fe("node-dblclick", { node: z }, q);
    }, Ie = (q) => {
      const z = g.value, { loadMethod: R } = e, { checkStrictly: le } = z;
      return new Promise((F) => {
        if (R) {
          const re = Object.assign({}, c.treeExpandLazyLoadedMaps), { nodeMaps: N } = c, ee = Z(q), be = N[ee];
          re[ee] = !0, c.treeExpandLazyLoadedMaps = re, Promise.resolve(R({ $tree: Q, node: q })).then((we) => {
            const { treeExpandLazyLoadedMaps: Te } = c;
            if (be.treeLoaded = !0, Te[ee] && (Te[ee] = !1), r.isArray(we) || (we = []), we)
              return ne.loadChildrenNode(q, we).then((ze) => {
                const st = Object.assign({}, c.treeExpandedMaps);
                return ze.length && !st[ee] && (st[ee] = !0), c.treeExpandedMaps = st, !le && ne.isCheckedByCheckboxNodeId(ee) && ce(ze.map((ct) => Z(ct)), !0), Oe(q), fe("load-success", { node: q, data: we }, new Event("load-success")), me();
              });
            Oe(q), fe("load-success", { node: q, data: we }, new Event("load-success"));
          }).catch((we) => {
            const { treeExpandLazyLoadedMaps: Te } = c;
            be.treeLoaded = !1, Te[ee] && (Te[ee] = !1), Oe(q), fe("load-error", { node: q, data: we }, new Event("load-error"));
          }).finally(() => me());
        } else
          F();
      });
    }, je = (q, z) => {
      const { lazy: R, accordion: le, toggleMethod: F } = e, { nodeMaps: re, treeExpandLazyLoadedMaps: N } = c, ee = Object.assign({}, c.treeExpandedMaps), be = D.value, we = S.value, Te = [];
      let ze = F ? q.filter((ct) => F({ $tree: Q, expanded: z, node: ct })) : q;
      if (le) {
        ze = ze.length ? [ze[ze.length - 1]] : [];
        const ct = Z(ze[0]), Ke = re[ct];
        Ke && Ke.items.forEach((wt) => {
          const St = Z(wt);
          ee[St] && delete ee[St];
        });
      }
      const st = [];
      return z ? ze.forEach((ct) => {
        const Ke = Z(ct);
        if (!ee[Ke]) {
          const wt = re[Ke];
          R && ct[we] && !wt.treeLoaded && !N[Ke] ? Te.push(Ie(ct)) : ct[be] && ct[be].length && (ee[Ke] = !0, st.push(ct));
        }
      }) : ze.forEach((ct) => {
        const Ke = Z(ct);
        ee[Ke] && (delete ee[Ke], st.push(ct));
      }), c.treeExpandedMaps = ee, st.forEach(Oe), Promise.all(Te);
    }, Ue = (q, z) => {
      const { lazy: R } = e, { treeExpandedMaps: le, treeExpandLazyLoadedMaps: F } = c, re = Z(z), N = !le[re];
      q.stopPropagation(), (!R || !F[re]) && je([z], N);
    }, Ae = (q, z, R) => {
      const le = D.value, F = r.get(q, le), re = Z(q);
      if (F && F.length) {
        let N = !1, ee = 0;
        F.forEach((we) => {
          const Te = Z(we), ze = z[Te];
          (ze || R[Te]) && (ze && ee++, N = !0);
        }), ee === F.length ? (z[re] || (z[re] = !0), R[re] && delete R[re]) : (z[re] && delete z[re], R[re] = N);
      } else
        R[re] && delete R[re];
    }, _e = () => {
      const { treeList: q } = c, z = D.value, R = g.value, { checkStrictly: le } = R;
      if (!le) {
        const F = Object.assign({}, c.selectCheckboxMaps), re = {};
        r.eachTree(q, (N, ee, be, we, Te, ze) => {
          const st = r.get(N, z);
          if ((!st || !st.length) && Ae(N, F, re), ee === be.length - 1)
            for (let ct = ze.length - 2; ct >= 0; ct--) {
              const Ke = ze[ct];
              Ae(Ke, F, re);
            }
        }), c.selectCheckboxMaps = F, c.indeterminateCheckboxMaps = re;
      }
    }, it = (q, z) => {
      q.preventDefault(), q.stopPropagation();
      const R = g.value, { checkStrictly: le, checkMethod: F } = R;
      let re = !!F;
      if (F && (re = !F({ node: z })), re)
        return;
      const N = Object.assign({}, c.selectCheckboxMaps), ee = D.value, be = Z(z);
      let we = !1;
      N[be] ? delete N[be] : (we = !0, N[be] = we), le || r.eachTree(r.get(z, ee), (ze) => {
        const st = Z(ze);
        we ? N[st] || (N[st] = !0) : N[st] && delete N[st];
      }, { children: ee }), c.selectCheckboxMaps = N, _e();
      const Te = Object.keys(c.selectCheckboxMaps);
      P(Te), fe("checkbox-change", { node: z, value: Te, checked: we }, q);
    }, vt = (q, z) => {
      q.preventDefault();
      const R = b.value, { currentMethod: le, trigger: F } = R, re = D.value, N = r.get(z, re), ee = N && N.length;
      let be = !!le;
      if (F === "child") {
        if (ee)
          return;
      } else if (F === "parent" && !ee)
        return;
      if (le && (be = !le({ node: z })), be)
        return;
      const we = !0;
      c.currentNode = z, fe("current-change", { node: z, checked: we }, q);
    }, dt = (q, z) => {
      q.preventDefault(), q.stopPropagation();
      const R = O.value, { checkMethod: le } = R;
      let F = !!le;
      if (le && (F = !le({ node: z })), F)
        return;
      const re = !0, N = Z(z);
      c.selectRadioKey = N, M(N), fe("radio-change", { node: z, value: N, checked: re }, q);
    };
    Object.assign(Q, ne, {});
    const Et = (q, z, R) => {
      const { showRadio: le } = e, F = O.value, { showIcon: re, checkMethod: N, visibleMethod: ee } = F, be = !ee || ee({ node: q });
      let we = !!N;
      return le && re && be ? (N && (we = !N({ node: q })), o("div", {
        class: ["vxe-tree--radio-option", {
          "is--checked": R,
          "is--disabled": we
        }],
        onClick: (Te) => {
          we || dt(Te, q);
        }
      }, [
        o("span", {
          class: ["vxe-radio--icon", R ? ht().RADIO_CHECKED : ht().RADIO_UNCHECKED]
        })
      ])) : Ve();
    }, Qe = (q, z, R) => {
      const { showCheckbox: le } = e, F = g.value, { showIcon: re, checkMethod: N, visibleMethod: ee } = F, be = ye(z), we = !ee || ee({ node: q });
      let Te = !!N;
      return le && re && we ? (N && (Te = !N({ node: q })), o("div", {
        class: ["vxe-tree--checkbox-option", {
          "is--checked": R,
          "is--indeterminate": be,
          "is--disabled": Te
        }],
        onClick: (ze) => {
          Te || it(ze, q);
        }
      }, [
        o("span", {
          class: ["vxe-checkbox--icon", be ? ht().CHECKBOX_INDETERMINATE : R ? ht().CHECKBOX_CHECKED : ht().CHECKBOX_UNCHECKED]
        })
      ])) : Ve();
    }, De = (q) => {
      const { lazy: z, showRadio: R, showCheckbox: le, showLine: F, indent: re, iconOpen: N, iconClose: ee, iconLoaded: be, showIcon: we } = e, { nodeMaps: Te, treeExpandedMaps: ze, currentNode: st, selectRadioKey: ct, treeExpandLazyLoadedMaps: Ke } = c, wt = D.value, St = d.value, Dt = S.value, Wt = r.get(q, wt), nn = Wt && Wt.length, zt = s.title, At = s.extra, Ee = Z(q), Ye = ze[Ee], rt = Te[Ee], Ot = r.get(q, St), Jt = [];
      nn && ze[Ee] && (F && Jt.push(o("div", {
        key: "line",
        class: "vxe-tree--node-child-line",
        style: {
          height: `calc(${rt.lineCount} * var(--vxe-ui-tree-node-height) - var(--vxe-ui-tree-node-height) / 2)`,
          left: `${(rt.level + 1) * (re || 1)}px`
        }
      })), Wt.forEach((on) => {
        Jt.push(De(on));
      }));
      let Bt = !1;
      R && (Bt = Ee == ct);
      let Gt = !1;
      le && (Gt = K(Ee));
      let Qt = !1, U = !1, Lt = !1;
      return z && (U = !!Ke[Ee], Qt = q[Dt], Lt = !!rt.treeLoaded), o("div", {
        class: ["vxe-tree--node-wrapper", `node--level-${rt.level}`],
        nodeid: Ee
      }, [
        o("div", {
          class: ["vxe-tree--node-item", {
            "is--current": st && Ee === Z(st),
            "is-radio--checked": Bt,
            "is-checkbox--checked": Gt
          }],
          style: {
            paddingLeft: `${(rt.level - 1) * (re || 1)}px`
          },
          onClick(on) {
            Se(on, q);
          },
          onDblclick(on) {
            de(on, q);
          }
        }, [
          we || F ? o("div", {
            class: "vxe-tree--node-item-switcher"
          }, we && (z ? Lt ? nn : Qt : nn) ? [
            o("div", {
              class: "vxe-tree--node-item-icon",
              onClick(on) {
                Ue(on, q);
              }
            }, [
              o("i", {
                class: U ? be || ht().TREE_NODE_LOADED : Ye ? N || ht().TREE_NODE_OPEN : ee || ht().TREE_NODE_CLOSE
              })
            ])
          ] : []) : Ve(),
          Et(q, Ee, Bt),
          Qe(q, Ee, Gt),
          o("div", {
            class: "vxe-tree--node-item-inner"
          }, [
            o("div", {
              class: "vxe-tree--node-item-title"
            }, zt ? Nt(zt({ node: q })) : `${Ot}`),
            At ? o("div", {
              class: "vxe-tree--node-item-extra"
            }, Nt(At({ node: q }))) : Ve()
          ])
        ]),
        nn && ze[Ee] ? o("div", {
          class: "vxe-tree--node-child-wrapper"
        }, Jt) : Ve()
      ]);
    }, Re = () => {
      const { treeList: q } = c;
      return o("div", {
        class: "vxe-tree--node-list-wrapper"
      }, q.map((z) => De(z)));
    }, Be = () => {
      const { loading: q, trigger: z, showLine: R } = e, le = l.value, F = O.value, re = g.value, N = C.value, ee = E.value, be = h.value, we = s.loading;
      return o("div", {
        ref: a,
        class: ["vxe-tree", {
          [`size--${le}`]: le,
          "show--line": R,
          "checkbox--highlight": re.highlight,
          "radio--highlight": F.highlight,
          "node--hover": be,
          "node--trigger": z === "node",
          "is--loading": q
        }],
        style: N
      }, [
        Re(),
        /**
         * 加载中
         */
        o(us, {
          class: "vxe-tree--loading",
          modelValue: q,
          icon: ee.icon,
          text: ee.text
        }, we ? {
          default: () => we({ $tree: Q })
        } : {})
      ]);
    }, ve = ke(0);
    lt(() => e.data ? e.data.length : 0, () => {
      ve.value++;
    }), lt(() => e.data, () => {
      ve.value++;
    }), lt(ve, () => {
      J(e.data || []);
    }), lt(() => e.checkNodeKey, (q) => {
      c.selectRadioKey = q;
    });
    const Ne = ke(0);
    return lt(() => e.checkNodeKeys ? e.checkNodeKeys.length : 0, () => {
      Ne.value++;
    }), lt(() => e.checkNodeKeys, () => {
      Ne.value++;
    }), lt(Ne, () => {
      A(e.checkNodeKeys || []);
    }), $n(() => {
      c.treeList = [], c.treeExpandedMaps = {}, c.nodeMaps = {};
    }), J(e.data || []), A(e.checkNodeKeys || []), Q.renderVN = Be, Q;
  },
  render() {
    return this.renderVN();
  }
});
function Z0() {
  return r.uniqueId("node_");
}
const ki = pt({
  name: "VxeTreeSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => r.eqNull(oe().treeSelect.placeholder) ? Pe("vxe.base.pleaseSelect") : oe().treeSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    popupClassName: [String, Function],
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => oe().select.size || oe().size
    },
    remote: Boolean,
    remoteMethod: Function,
    popupConfig: Object,
    treeConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "node-click"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = mt("$xeModal", null), l = mt("$xeDrawer", null), a = mt("$xeTable", null), c = mt("$xeForm", null), m = mt("xeFormItemInfo", null), u = r.uniqueId(), { computeSize: d } = dn(e), p = ke(), w = ke(), v = ke(), D = ke(), S = Rt({
      initialized: !1,
      fullOptionList: [],
      fullNodeMaps: {},
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: !1,
      visiblePanel: !1,
      isAniVisible: !1,
      isActivated: !1
    }), x = {
      hpTimeout: void 0
    }, h = {
      refElem: p
    }, O = _(() => {
      const { readonly: Re } = e;
      return Re === null ? c ? c.props.readonly : !1 : Re;
    }), g = _(() => {
      const { disabled: Re } = e;
      return Re === null ? c ? c.props.disabled : !1 : Re;
    }), b = _(() => {
      const { transfer: Re } = e;
      if (Re === null) {
        const Be = oe().select.transfer;
        if (r.isBoolean(Be))
          return Be;
        if (a || i || l || c)
          return !0;
      }
      return Re;
    }), E = _(() => Object.assign({}, oe().treeSelect.popupConfig, e.popupConfig)), C = _(() => Object.assign({}, oe().treeSelect.treeConfig, e.treeConfig, { data: void 0 })), V = _(() => {
      const Re = C.value;
      return Object.assign({ isHover: !0 }, Re.nodeConfig);
    }), Q = _(() => {
      const Re = C.value;
      return Object.assign({
        showIcon: !!Re.showCheckbox
      }, Re.checkboxConfig, {
        trigger: "node"
      });
    }), Z = _(() => {
      const Re = C.value;
      return Object.assign({
        showIcon: !!Re.showRadio
      }, Re.radioConfig, {
        trigger: "node"
      });
    }), G = _(() => e.optionProps || {}), ue = _(() => C.value.keyField || "id"), Y = _(() => G.value.label || "label"), K = _(() => G.value.value || "value"), L = _(() => G.value.children || "children"), ye = _(() => G.value.parent || "parentField"), se = _(() => G.value.hasChild || "hasChild"), P = _(() => {
      const { modelValue: Re } = e, { fullNodeMaps: Be } = S, ve = Y.value;
      return (r.isArray(Re) ? Re : [Re]).map((Ne) => {
        const q = Be[Ne];
        return q ? q.item[ve] : Ne;
      }).join(", ");
    }), M = _(() => {
      const Re = E.value, { height: Be, width: ve } = Re, Ne = {};
      return ve && (Ne.width = cn(ve)), Be && (Ne.height = cn(Be), Ne.maxHeight = cn(Be)), Ne;
    }), I = {}, B = {
      xID: u,
      props: e,
      context: t,
      reactData: S,
      internalData: x,
      getRefMaps: () => h,
      getComputeMaps: () => I
    }, H = (Re, Be, ve) => {
      n(Re, Zt(ve, { $treeSelect: B }, Be));
    }, ce = (Re) => {
      n("update:modelValue", Re);
    }, A = {
      dispatchEvent: H
    }, j = (Re) => {
      const Be = ue.value, ve = Re[Be];
      return ve ? encodeURIComponent(ve) : "";
    }, fe = () => {
      const { options: Re } = e, Be = ue.value, ve = L.value, Ne = K.value, q = {}, z = {};
      r.eachTree(Re, (R, le, F, re, N, ee) => {
        let be = j(R);
        be || (be = Z0()), z[be] && Ao("vxe.error.repeatKey", [Be, be]), z[be] = !0;
        const we = R[Ne];
        q[we] && Ao("vxe.error.repeatKey", [Ne, we]), q[we] = { item: R, index: le, items: F, parent: N, nodes: ee };
      }, { children: ve }), S.fullOptionList = Re || [], S.fullNodeMaps = q;
    }, pe = () => {
      S.panelIndex < ws() && (S.panelIndex = ds());
    }, ne = () => me().then(() => {
      const { placement: Re } = e, { panelIndex: Be } = S, ve = p.value, Ne = D.value, q = b.value;
      if (Ne && ve) {
        const z = ve.offsetHeight, R = ve.offsetWidth, le = Ne.offsetHeight, F = Ne.offsetWidth, re = 5, N = {
          zIndex: Be
        }, { boundingTop: ee, boundingLeft: be, visibleHeight: we, visibleWidth: Te } = br(ve);
        let ze = "bottom";
        if (q) {
          let st = be, ct = ee + z;
          Re === "top" ? (ze = "top", ct = ee - le) : Re || (ct + le + re > we && (ze = "top", ct = ee - le), ct < re && (ze = "bottom", ct = ee + z)), st + F + re > Te && (st -= st + F + re - Te), st < re && (st = re), Object.assign(N, {
            left: `${st}px`,
            top: `${ct}px`,
            minWidth: `${R}px`
          });
        } else
          Re === "top" ? (ze = "top", N.bottom = `${z}px`) : Re || ee + z + le > we && ee - z - le > re && (ze = "top", N.bottom = `${z}px`);
        return S.panelStyle = N, S.panelPlacement = ze, me();
      }
    }), $ = () => {
      const { loading: Re } = e, Be = g.value;
      !Re && !Be && (clearTimeout(x.hpTimeout), S.initialized || (S.initialized = !0), S.isActivated = !0, S.isAniVisible = !0, setTimeout(() => {
        S.visiblePanel = !0;
      }, 10), pe(), ne());
    }, J = () => {
      S.visiblePanel = !1, x.hpTimeout = window.setTimeout(() => {
        S.isAniVisible = !1;
      }, 350);
    }, ge = (Re, Be) => {
      const { fullNodeMaps: ve } = S;
      if (ce(Be), Be !== e.modelValue) {
        const Ne = ve[Be];
        H("change", { value: Be, option: Ne ? Ne.item : null }, Re), c && m && c.triggerItemEvent(Re, m.itemConfig.field, Be);
      }
    }, Oe = (Re, Be) => {
      ge(Re, Be), H("clear", { value: Be }, Re);
    }, Se = (Re, Be) => {
      Oe(Be, null), J();
    }, de = (Re) => {
      const { visiblePanel: Be } = S;
      if (!g.value && Be) {
        const Ne = D.value;
        jn(Re, Ne).flag ? ne() : J();
      }
    }, Ie = (Re) => {
      const { visiblePanel: Be } = S;
      if (!g.value) {
        const Ne = p.value, q = D.value;
        S.isActivated = jn(Re, Ne).flag || jn(Re, q).flag, Be && !S.isActivated && J();
      }
    }, je = () => {
      J();
    }, Ue = (Re) => {
      g.value || S.visiblePanel || (S.triggerFocusPanel = !0, $(), setTimeout(() => {
        S.triggerFocusPanel = !1;
      }, 150)), H("focus", {}, Re);
    }, Ae = (Re) => {
      it(Re), H("click", {}, Re);
    }, _e = (Re) => {
      S.isActivated = !1, H("blur", {}, Re);
    }, it = (Re) => {
      const { $event: Be } = Re;
      Be.preventDefault(), S.triggerFocusPanel ? S.triggerFocusPanel = !1 : S.visiblePanel ? J() : $();
    }, vt = (Re) => {
      const { $event: Be } = Re;
      H("node-click", Re, Be);
    }, dt = (Re) => {
      const { value: Be, $event: ve } = Re;
      ge(ve, Be), J();
    }, at = (Re) => {
      const { value: Be, $event: ve } = Re;
      ge(ve, Be);
    }, Et = () => {
      fe();
    };
    Object.assign(B, A, {});
    const De = () => {
      const { className: Re, modelValue: Be, multiple: ve, options: Ne, loading: q } = e, { initialized: z, isActivated: R, isAniVisible: le, visiblePanel: F } = S, re = d.value, N = g.value, ee = P.value, be = b.value, we = O.value, Te = M.value, ze = s.header, st = s.footer, ct = s.prefix, wt = E.value.className || e.popupClassName, St = C.value, Dt = V.value, Wt = Q.value, nn = Z.value, zt = ue.value, At = Y.value, Ee = K.value, Ye = L.value, rt = ye.value, Ot = se.value;
      return we ? o("div", {
        ref: p,
        class: ["vxe-tree-select--readonly", Re]
      }, [
        o("span", {
          class: "vxe-tree-select-label"
        }, ee)
      ]) : o("div", {
        ref: p,
        class: ["vxe-tree-select", Re ? r.isFunction(Re) ? Re({ $treeSelect: B }) : Re : "", {
          [`size--${re}`]: re,
          "is--visible": F,
          "is--disabled": N,
          "is--loading": q,
          "is--active": R
        }]
      }, [
        o(Wn, {
          ref: w,
          clearable: e.clearable,
          placeholder: q ? Pe("vxe.select.loadingText") : e.placeholder,
          readonly: !0,
          disabled: N,
          type: "text",
          prefixIcon: e.prefixIcon,
          suffixIcon: q ? ht().TREE_SELECT_LOADED : F ? ht().TREE_SELECT_OPEN : ht().TREE_SELECT_CLOSE,
          modelValue: q ? "" : ee,
          onClear: Se,
          onClick: Ae,
          onFocus: Ue,
          onBlur: _e,
          onSuffixClick: it
        }, ct ? {
          prefix: () => ct({})
        } : {}),
        o(ks, {
          to: "body",
          disabled: be ? !z : !0
        }, [
          o("div", {
            ref: D,
            class: ["vxe-table--ignore-clear vxe-tree-select--panel", wt ? r.isFunction(wt) ? wt({ $treeSelect: B }) : wt : "", {
              [`size--${re}`]: re,
              "is--transfer": be,
              "ani--leave": !q && le,
              "ani--enter": !q && F
            }],
            placement: S.panelPlacement,
            style: S.panelStyle
          }, z ? [
            o("div", {
              class: "vxe-tree-select--panel-wrapper"
            }, [
              ze ? o("div", {
                class: "vxe-tree-select--panel-header"
              }, ze({})) : Yn(),
              o("div", {
                class: "vxe-tree-select--panel-body"
              }, [
                o("div", {
                  ref: v,
                  class: "vxe-tree-select-tree--wrapper",
                  style: Te
                }, [
                  o(Pi, {
                    class: "vxe-tree-select--tree",
                    data: Ne,
                    indent: St.indent,
                    showRadio: !ve,
                    radioConfig: nn,
                    checkNodeKey: ve ? null : Be,
                    showCheckbox: !!ve,
                    checkNodeKeys: ve ? Be : null,
                    checkboxConfig: Wt,
                    titleField: At,
                    valueField: Ee,
                    keyField: zt,
                    childrenField: St.childrenField || Ye,
                    parentField: St.parentField || rt,
                    hasChildField: St.hasChildField || Ot,
                    accordion: St.accordion,
                    nodeConfig: Dt,
                    lazy: St.lazy,
                    loadMethod: St.loadMethod,
                    toggleMethod: St.toggleMethod,
                    transform: St.transform,
                    trigger: St.trigger,
                    showIcon: St.showIcon,
                    showLine: St.showLine,
                    iconOpen: St.iconOpen,
                    iconLoaded: St.iconLoaded,
                    iconClose: St.iconClose,
                    onNodeClick: vt,
                    onRadioChange: dt,
                    onCheckboxChange: at,
                    onLoadSuccess: Et
                  })
                ])
              ]),
              st ? o("div", {
                class: "vxe-tree-select--panel-footer"
              }, st({})) : Yn()
            ])
          ] : [])
        ])
      ]);
    };
    return lt(() => e.options, () => {
      fe();
    }), fe(), wn(() => {
      ut.on(B, "mousewheel", de), ut.on(B, "mousedown", Ie), ut.on(B, "blur", je);
    }), $n(() => {
      ut.off(B, "mousewheel"), ut.off(B, "mousedown"), ut.off(B, "blur");
    }), bn("$xeTreeSelect", B), B.renderVN = De, B;
  },
  render() {
    return this.renderVN();
  }
}), J0 = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o(ki, {
            modelValue: t ? t.getItemValue(l) : null,
            placeholder: a.placeholder || Pe("vxe.base.pleaseSelect"),
            options: a.options,
            optionProps: { label: "value", value: "value" },
            onChange: s,
            "onUpdate:modelValue"(m) {
              t && t.setItemValue(l, m);
            }
          });
        }
      });
    };
  }
}), Q0 = () => ({
  title: yo,
  icon: "vxe-icon-radio-checked",
  options: {
    options: r.range(0, 3).map((e, t) => ({
      value: Pe("vxe.formDesign.widgetProp.dataSource.defValue", [t + 1])
    }))
  }
}), eA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { renderDataSourceFormItem: t } = na(e, {
      isSubOption: !1
    }), { computeKebabCaseName: n } = Dn(e);
    return () => {
      const { renderParams: s } = e, { widget: i } = s, l = n.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${l}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: i.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: i.title,
                  "onUpdate:modelValue"(a) {
                    i.title = a;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: i.required,
                  "onUpdate:modelValue"(a) {
                    i.required = a;
                  }
                });
              }
            }),
            t()
          ];
        }
      });
    };
  }
}), tA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o(Jo, {
            modelValue: t ? t.getItemValue(l) : null,
            options: a.options,
            optionProps: { label: "value", value: "value" },
            onChange: s,
            "onUpdate:modelValue"(m) {
              t && t.setItemValue(l, m);
            }
          });
        }
      });
    };
  }
}), nA = () => ({
  title: yo,
  icon: "vxe-icon-checkbox-checked",
  options: {
    options: r.range(0, 3).map((e, t) => ({
      value: Pe("vxe.formDesign.widgetProp.dataSource.defValue", [t + 1])
    }))
  }
}), oA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { renderDataSourceFormItem: t } = na(e, {
      isSubOption: !1
    }), { computeKebabCaseName: n } = Dn(e);
    return () => {
      const { renderParams: s } = e, { widget: i } = s, l = n.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${l}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: i.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: i.title,
                  "onUpdate:modelValue"(a) {
                    i.title = a;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: i.required,
                  "onUpdate:modelValue"(a) {
                    i.required = a;
                  }
                });
              }
            }),
            t()
          ];
        }
      });
    };
  }
}), sA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o(Di, {
            modelValue: t ? t.getItemValue(l) : null,
            options: a.options,
            optionProps: { label: "value", value: "value" },
            onChange: s,
            "onUpdate:modelValue"(m) {
              t && t.setItemValue(l, m);
            }
          });
        }
      });
    };
  }
});
function Wv() {
  const e = [
    { label: "无限制", value: "" }
  ];
  return [1, 2, 5, 10, 20, 50, 100, 200, 500].forEach((n) => {
    e.push({ label: `${n}M`, value: n });
  }), e;
}
const rA = () => ({
  title: yo,
  icon: "vxe-icon-file",
  options: {
    limitCount: "",
    limitSize: 100,
    multiple: !1
  }
}), lA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e), n = ke(Wv());
    return () => {
      const { renderParams: s } = e, { widget: i } = s, { options: l } = i, a = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${a}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: l
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: i.title,
                  "onUpdate:modelValue"(c) {
                    i.title = c;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.uploadProp.multiFile"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            l.multiple ? o(kt, {
              title: Pe("vxe.formDesign.widgetProp.uploadProp.limitFileCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: !0 } }
            }) : Ve(),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.uploadProp.limitFileSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: n.value }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: i.required,
                  "onUpdate:modelValue"(c) {
                    i.required = c;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});
let Sl = null, lr = null;
function iA(e) {
  const t = e.name, n = r.lastIndexOf(t, "."), s = t.substring(n + 1, t.length).toLowerCase();
  return { filename: t.substring(0, n), type: s };
}
const zv = (e) => {
  const t = Object.assign({}, e);
  return new Promise((n, s) => {
    lr || (lr = document.createElement("input"), lr.name = "file", lr.type = "file"), Sl || (Sl = document.createElement("form"), Sl.style.display = "none", Sl.appendChild(lr), document.body.appendChild(Sl));
    const i = t.types || [], l = !i.length || i.some((a) => a === "*");
    lr.multiple = !!t.multiple, lr.accept = l ? "" : `.${i.join(", .")}`, lr.onchange = (a) => {
      const c = a.target, m = Array.from(c.files || []), u = m[0];
      let d = "";
      if (!l)
        for (let p = 0; p < m.length; p++) {
          const { type: w } = iA(m[p]);
          if (!r.includes(i, w)) {
            d = w;
            break;
          }
        }
      d ? (t.message !== !1 && Ce.modal && Ce.modal.message({
        content: Pe("vxe.error.notType", [d]),
        status: "error"
      }), s({ status: !1, files: m, file: u })) : n({ status: !0, files: m, file: u });
    }, Sl.reset(), lr.click();
  });
};
function aA(e, t) {
  return new Blob([e], { type: `text/${t.type};charset=utf-8;` });
}
const cA = (e) => {
  const t = Object.assign({ type: "" }, e), { filename: n, type: s, content: i } = t, l = s ? `${n}.${s}` : `${n}`;
  if (window.Blob) {
    const a = i instanceof Blob ? i : aA(r.toValueString(i), t), c = window.navigator;
    if (c.msSaveBlob)
      c.msSaveBlob(a, l);
    else {
      const m = URL.createObjectURL(a), u = document.createElement("a");
      u.target = "_blank", u.download = l, u.href = m, document.body.appendChild(u), u.click(), requestAnimationFrame(() => {
        u.parentNode && u.parentNode.removeChild(u), URL.revokeObjectURL(m);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(Pe("vxe.error.notExp")));
}, Hl = pt({
  name: "VxeUpload",
  props: {
    modelValue: [Array, String, Object],
    showList: {
      type: Boolean,
      default: () => oe().upload.showList
    },
    moreConfig: Object,
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    mode: {
      type: String,
      default: () => oe().upload.mode
    },
    imageTypes: {
      type: Array,
      default: () => r.clone(oe().upload.imageTypes, !0)
    },
    imageStyle: {
      type: Object,
      default: () => r.clone(oe().upload.imageStyle, !0)
    },
    fileTypes: {
      type: Array,
      default: () => r.clone(oe().upload.fileTypes, !0)
    },
    dragToUpload: {
      type: Boolean,
      default: () => r.clone(oe().upload.dragToUpload, !0)
    },
    pasteToUpload: {
      type: Boolean,
      default: () => r.clone(oe().upload.pasteToUpload, !0)
    },
    keyField: String,
    singleMode: Boolean,
    urlMode: Boolean,
    multiple: Boolean,
    limitSize: {
      type: [String, Number],
      default: () => oe().upload.limitSize
    },
    limitCount: {
      type: [String, Number],
      default: () => oe().upload.limitCount
    },
    nameField: {
      type: String,
      default: () => oe().upload.nameField
    },
    typeField: {
      type: String,
      default: () => oe().upload.typeField
    },
    urlField: {
      type: String,
      default: () => oe().upload.urlField
    },
    sizeField: {
      type: String,
      default: () => oe().upload.sizeField
    },
    showErrorStatus: {
      type: Boolean,
      default: () => oe().upload.showErrorStatus
    },
    showProgress: {
      type: Boolean,
      default: () => oe().upload.showProgress
    },
    progressText: {
      type: String,
      default: () => oe().upload.progressText
    },
    autoHiddenButton: {
      type: Boolean,
      default: () => oe().upload.autoHiddenButton
    },
    showUploadButton: {
      type: Boolean,
      default: () => oe().upload.showUploadButton
    },
    buttonText: {
      type: String,
      default: () => oe().upload.buttonText
    },
    buttonIcon: {
      type: String,
      default: () => oe().upload.buttonIcon
    },
    showButtonText: {
      type: Boolean,
      default: () => oe().upload.showButtonText
    },
    showButtonIcon: {
      type: Boolean,
      default: () => oe().upload.showButtonIcon
    },
    showRemoveButton: {
      type: Boolean,
      default: () => oe().upload.showRemoveButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => oe().upload.showDownloadButton
    },
    showPreview: {
      type: Boolean,
      default: () => oe().upload.showPreview
    },
    tipText: String,
    hintText: String,
    previewMethod: Function,
    uploadMethod: Function,
    beforeRemoveMethod: Function,
    removeMethod: Function,
    beforeDownloadMethod: Function,
    downloadMethod: Function,
    getUrlMethod: Function,
    getThumbnailUrlMethod: Function,
    size: {
      type: String,
      default: () => oe().upload.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "add",
    "remove",
    "remove-fail",
    "download",
    "download-fail",
    "upload-success",
    "upload-error"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = mt("$xeForm", null), l = mt("xeFormItemInfo", null), a = r.uniqueId(), { computeSize: c } = dn(e), m = ke(), u = Rt({
      isDrag: !1,
      showMorePopup: !1,
      isActivated: !1,
      fileList: [],
      fileCacheMaps: {}
    }), d = {
      imagePreviewTypes: ["jpg", "jpeg", "png", "gif"]
    }, p = {
      refElem: m
    }, w = _(() => {
      const { readonly: F } = e;
      return F === null ? i ? i.props.readonly : !1 : F;
    }), v = _(() => {
      const { disabled: F } = e;
      return F === null ? i ? i.props.disabled : !1 : F;
    }), D = _(() => e.keyField || "_X_KEY"), S = _(() => e.mode === "image"), x = _(() => e.nameField || "name"), h = _(() => e.typeField || "type"), O = _(() => e.urlField || "url"), g = _(() => e.sizeField || "size"), b = _(() => r.toNumber(e.limitSize) * 1024 * 1024), E = _(() => e.multiple ? r.toNumber(e.limitCount) : 1), C = _(() => {
      const { multiple: F } = e, { fileList: re } = u, N = E.value;
      return F ? N ? re.length >= N : !0 : re.length >= 1;
    }), V = _(() => {
      const F = r.toNumber(e.limitSize);
      return F ? F > 1048576 ? `${F / 1048576}T` : F > 1024 ? `${F / 1024}G` : `${F}M` : "";
    }), Q = _(() => {
      const { limitSize: F, fileTypes: re, multiple: N, limitCount: ee } = e, be = e.tipText || e.hintText, we = S.value, Te = V.value;
      if (r.isString(be))
        return be;
      const ze = [];
      return we ? (N && ee && ze.push(Pe("vxe.upload.imgCountHint", [ee])), F && Te && ze.push(Pe("vxe.upload.imgSizeHint", [Te]))) : (re && re.length && ze.push(Pe("vxe.upload.fileTypeHint", [re.join("/")])), F && Te && ze.push(Pe("vxe.upload.fileSizeHint", [Te])), N && ee && ze.push(Pe("vxe.upload.fileCountHint", [ee]))), ze.join(Pe("vxe.base.comma"));
    }), Z = _(() => Object.assign({}, e.imageStyle)), G = _(() => {
      const { width: F, height: re } = Z.value, N = {};
      return F && (N.width = cn(F)), re && (N.height = cn(re)), N;
    }), ue = _(() => Object.assign({ showMoreButton: !0 }, e.moreConfig)), Y = {}, K = {
      xID: a,
      props: e,
      context: t,
      reactData: u,
      internalData: d,
      getRefMaps: () => p,
      getComputeMaps: () => Y
    }, L = () => r.uniqueId(), ye = (F) => {
      const re = D.value;
      return F[re];
    }, se = () => {
      const { modelValue: F, multiple: re } = e, N = w.value, ee = D.value, be = x.value, we = h.value, Te = O.value, ze = g.value, st = F ? (F ? r.isArray(F) ? F : [F] : []).map((ct) => {
        if (!ct || r.isString(ct)) {
          const wt = `${ct || ""}`, St = P(wt);
          return {
            [be]: St,
            [we]: M(St),
            [Te]: wt,
            [ze]: 0,
            [ee]: L()
          };
        }
        const Ke = ct[be] || "";
        return ct[be] = Ke, ct[we] = ct[we] || M(Ke), ct[Te] = ct[Te] || "", ct[ze] = ct[ze] || 0, ct[ee] = ct[ee] || L(), ct;
      }) : [];
      u.fileList = N || re ? st : st.slice(0, 1);
    }, P = (F) => decodeURIComponent(`${F || ""}`).split("/").pop() || "", M = (F) => {
      const re = F ? F.indexOf(".") : -1;
      return re > -1 ? F.substring(re + 1, F.length).toLowerCase() : "";
    }, I = (F, re, N) => {
      n(F, Zt(N, { $upload: K }, re));
    }, B = (F) => {
      const { singleMode: re, urlMode: N } = e, ee = O.value;
      let be = F ? F.slice(0) : [];
      N && (be = be.map((we) => we[ee])), n("update:modelValue", re ? be[0] || null : be);
    }, H = (F) => {
      const re = e.getThumbnailUrlMethod || oe().upload.getThumbnailUrlMethod;
      return re ? re({
        $upload: K,
        option: F
      }) : ce(F);
    }, ce = (F) => {
      const re = e.getUrlMethod || oe().upload.getUrlMethod, N = O.value;
      return re ? re({
        $upload: K,
        option: F
      }) : F[N];
    }, A = (F) => {
      const { imageTypes: re, showDownloadButton: N } = e, ee = h.value, be = e.beforeDownloadMethod || oe().upload.beforeDownloadMethod, { imagePreviewTypes: we } = d;
      we.concat(re || []).some((Te) => `${Te}`.toLowerCase() === `${F[ee]}`.toLowerCase()) && Ce.previewImage && Ce.previewImage({
        urlList: [ce(F)],
        showDownloadButton: N,
        beforeDownloadMethod: be ? () => be({
          $upload: K,
          option: F
        }) : void 0
      });
    }, j = (F, re) => {
      const N = e.previewMethod || oe().upload.previewMethod;
      e.showPreview && (N ? N({
        $upload: K,
        option: re
      }) : A(re));
    }, fe = (F, re, N) => {
      const { showDownloadButton: ee } = e, { fileList: be } = u, we = e.beforeDownloadMethod || oe().upload.beforeDownloadMethod;
      e.showPreview && Ce.previewImage && Ce.previewImage({
        urlList: be.map((Te) => ce(Te)),
        activeIndex: N,
        showDownloadButton: ee,
        beforeDownloadMethod: we ? ({ index: Te }) => we({
          $upload: K,
          option: be[Te]
        }) : void 0
      });
    }, pe = (F, re) => {
      const { showErrorStatus: N } = e, ee = ye(F), be = e.uploadMethod || oe().upload.uploadMethod;
      if (be)
        return Promise.resolve(be({
          $upload: K,
          file: re,
          option: F,
          updateProgress(we) {
            const { fileCacheMaps: Te } = u, ze = Te[ye(F)];
            ze && (ze.percent = Math.max(0, Math.min(99, r.toNumber(we))));
          }
        })).then((we) => {
          const { fileCacheMaps: Te } = u, ze = Te[ee];
          ze && (ze.percent = 100), Object.assign(F, we), I("upload-success", { option: F, data: we }, null);
        }).catch((we) => {
          const { fileCacheMaps: Te } = u, ze = Te[ee];
          ze && (ze.status = "error"), N ? Object.assign(F, we) : u.fileList = u.fileList.filter((st) => ye(st) !== ee), I("upload-error", { option: F, data: we }, null);
        }).finally(() => {
          const { fileCacheMaps: we } = u, Te = we[ee];
          Te && (Te.loading = !1);
        });
      {
        const { fileCacheMaps: we } = u, Te = we[ee];
        Te && (Te.loading = !1);
      }
      return Promise.resolve();
    }, ne = (F) => {
      const { uploadMethod: re, urlMode: N } = e, { fileCacheMaps: ee } = u, be = ye(F), we = ee[be];
      if ((re || oe().upload.uploadMethod) && we) {
        const ze = we.file;
        we.loading = !0, we.status = "", we.percent = 0, pe(F, ze).then(() => {
          N && B(u.fileList);
        });
      }
    }, $ = (F, re) => {
      const { multiple: N, urlMode: ee } = e, { fileList: be } = u, we = e.uploadMethod || oe().upload.uploadMethod, Te = D.value, ze = x.value, st = h.value, ct = O.value, Ke = g.value, wt = b.value, St = E.value, Dt = V.value;
      let Wt = F;
      if (N && St) {
        if (be.length >= St) {
          Ce.modal && Ce.modal.notification({
            title: Pe("vxe.modal.errTitle"),
            status: "error",
            content: Pe("vxe.upload.overCountErr", [St])
          });
          return;
        }
        const Ee = Wt.length - (St - be.length);
        if (Ee > 0) {
          const Ye = Wt.slice(St - be.length);
          Ce.modal && Ce.modal.notification({
            title: Pe("vxe.modal.errTitle"),
            status: "error",
            slots: {
              default() {
                return o("div", {
                  class: "vxe-upload--file-message-over-error"
                }, [
                  o("div", {}, Pe("vxe.upload.overCountExtraErr", [St, Ee])),
                  o("div", {
                    class: "vxe-upload--file-message-over-extra"
                  }, Ye.map((rt, Ot) => o("div", {
                    key: Ot,
                    class: "vxe-upload--file-message-over-extra-item"
                  }, rt.name)))
                ]);
              }
            }
          });
        }
        Wt = Wt.slice(0, St - be.length);
      }
      if (wt) {
        for (let Ee = 0; Ee < F.length; Ee++)
          if (F[0].size > wt) {
            Ce.modal && Ce.modal.notification({
              title: Pe("vxe.modal.errTitle"),
              status: "error",
              content: Pe("vxe.upload.overSizeErr", [Dt])
            });
            return;
          }
      }
      const nn = Object.assign({}, u.fileCacheMaps), zt = N ? be : [], At = [];
      Wt.forEach((Ee) => {
        const { name: Ye } = Ee, rt = L(), Ot = {
          [ze]: Ye,
          [st]: M(Ye),
          [Ke]: Ee.size,
          [ct]: "",
          [Te]: rt
        };
        we && (nn[rt] = {
          file: Ee,
          loading: !0,
          status: "",
          percent: 0
        });
        const Jt = Rt(Ot);
        we && At.push(pe(Jt, Ee)), zt.push(Jt), I("add", { option: Jt }, re);
      }), u.fileList = zt, u.fileCacheMaps = nn, Promise.all(ee ? At : []).then(() => {
        B(zt), i && l && i.triggerItemEvent(re, l.itemConfig.field, zt);
      });
    }, J = (F) => {
      const { multiple: re, imageTypes: N, fileTypes: ee } = e, be = v.value, we = S.value;
      return be ? Promise.resolve({
        status: !1,
        files: [],
        file: null
      }) : zv({
        multiple: re,
        types: we ? N : ee
      }).then((Te) => ($(Te.files, F), Te));
    }, ge = (F) => {
      J(F).catch(() => {
      });
    }, Oe = (F, re, N) => {
      const { fileList: ee } = u;
      ee.splice(N, 1), B(ee), i && l && i.triggerItemEvent(F, l.itemConfig.field, ee), I("remove", { option: re }, F);
    }, Se = (F, re, N) => {
      const ee = e.beforeRemoveMethod || oe().upload.beforeRemoveMethod, be = e.removeMethod || oe().upload.removeMethod;
      Promise.resolve(ee ? ee({
        $upload: K,
        option: re
      }) : !0).then((we) => {
        we ? be ? Promise.resolve(be({
          $upload: K,
          option: re
        })).then(() => {
          Oe(F, re, N);
        }).catch((Te) => Te) : Oe(F, re, N) : I("remove-fail", { option: re }, F);
      });
    }, de = (F, re) => {
      I("download", { option: re }, F);
    }, Ie = (F, re) => {
      const N = e.beforeDownloadMethod || oe().upload.beforeDownloadMethod, ee = e.downloadMethod || oe().upload.downloadMethod;
      Promise.resolve(N ? N({
        $upload: K,
        option: re
      }) : !0).then((be) => {
        be ? ee ? Promise.resolve(ee({
          $upload: K,
          option: re
        })).then(() => {
          de(F, re);
        }).catch((we) => we) : de(F, re) : I("download-fail", { option: re }, F);
      });
    }, je = (F) => {
      const re = F.currentTarget, { clientX: N, clientY: ee } = F;
      if (re) {
        const { x: be, y: we, height: Te, width: ze } = re.getBoundingClientRect();
        (N < be || N > be + ze || ee < we || ee > we + Te) && (u.isDrag = !1);
      }
    }, Ue = (F) => {
      const re = F.dataTransfer;
      if (re) {
        const { items: N } = re;
        N && N.length && (F.preventDefault(), u.isDrag = !0);
      }
    }, Ae = (F, re) => {
      const { imageTypes: N } = e, { imagePreviewTypes: ee } = d;
      if (S.value) {
        const we = ee.concat(N && N.length ? N : []);
        re = re.filter((Te) => {
          const ze = `${Te.type.split("/")[1] || ""}`.toLowerCase();
          return !!we.some((st) => `${st}`.toLowerCase() === ze);
        });
      }
      if (!re.length) {
        Ce.modal && Ce.modal.notification({
          title: Pe("vxe.modal.errTitle"),
          status: "error",
          content: Pe("vxe.upload.uploadTypeErr")
        });
        return;
      }
      $(re, F);
    }, _e = (F) => {
      const re = F.dataTransfer;
      if (re) {
        const { items: N } = re;
        if (N && N.length) {
          F.preventDefault();
          const ee = it(N);
          ee.length && Ae(F, ee);
        }
      }
      u.isDrag = !1;
    }, it = (F) => {
      const re = [];
      return r.arrayEach(F, (N) => {
        const ee = N.getAsFile();
        ee && re.push(ee);
      }), re;
    }, vt = () => {
      const F = w.value, re = S.value;
      Ce.modal && Ce.modal.open({
        title: Pe(F ? "vxe.upload.morePopup.readTitle" : `vxe.upload.morePopup.${re ? "imageTitle" : "fileTitle"}`),
        width: 660,
        height: 500,
        escClosable: !0,
        showMaximize: !0,
        resize: !0,
        maskClosable: !0,
        slots: {
          default() {
            const { showErrorStatus: N, dragToUpload: ee } = e, { isDrag: be } = u, we = v.value, { fileList: Te } = u, ze = {};
            return ee && (ze.onDragover = Ue, ze.onDragleave = je, ze.onDrop = _e), o("div", Object.assign({ class: ["vxe-upload--more-popup", {
              "is--readonly": F,
              "is--disabled": we,
              "show--error": N,
              "is--drag": be
            }] }, ze), [
              re ? o("div", {
                class: "vxe-upload--image-more-list"
              }, Ne(Te, !0).concat(q(!0))) : o("div", {
                class: "vxe-upload--file-more-list"
              }, [
                Be(!0),
                o("div", {
                  class: "vxe-upload--file-list"
                }, Re(Te, !0))
              ]),
              be ? o("div", {
                class: "vxe-upload--drag-placeholder"
              }, Pe("vxe.upload.dragPlaceholder")) : Ve()
            ]);
          }
        },
        onShow() {
          u.showMorePopup = !0;
        },
        onHide() {
          u.showMorePopup = !1;
        }
      });
    }, dt = (F) => {
      const { pasteToUpload: re } = e, { isActivated: N } = u;
      if (!N || !re)
        return;
      const ee = F.clipboardData || F.originalEvent.clipboardData;
      if (!ee)
        return;
      const { items: be } = ee;
      if (!be)
        return;
      const we = it(be);
      we.length && (F.preventDefault(), Ae(F, we));
    }, at = (F) => {
      const re = m.value, N = jn(F, re).flag;
      u.isActivated = N;
    }, Et = () => {
      u.isActivated = !1;
    };
    Object.assign(K, {
      dispatchEvent: I,
      choose() {
        return J(null);
      }
    }, {});
    const Re = (F, re) => {
      const { showRemoveButton: N, showDownloadButton: ee, showProgress: be, progressText: we, showPreview: Te, showErrorStatus: ze } = e, { fileCacheMaps: st } = u, ct = v.value, Ke = w.value, wt = x.value, St = h.value, Dt = s.corner;
      return F.map((Wt, nn) => {
        const zt = ye(Wt), At = st[zt], Ee = At && At.loading, Ye = At && At.status === "error";
        return o("div", {
          key: nn,
          class: ["vxe-upload--file-item", {
            "is--preview": Te,
            "is--loading": Ee,
            "is--error": Ye
          }]
        }, [
          o("div", {
            class: "vxe-upload--file-item-icon"
          }, [
            o("i", {
              class: ht()[`UPLOAD_FILE_TYPE_${`${Wt[St]}`.toLocaleUpperCase()}`] || ht().UPLOAD_FILE_TYPE_DEFAULT
            })
          ]),
          o("div", {
            class: "vxe-upload--file-item-name",
            onClick(rt) {
              !Ee && !Ye && j(rt, Wt);
            }
          }, `${Wt[wt] || ""}`),
          Ee ? o("div", {
            class: "vxe-upload--file-item-loading-icon"
          }, [
            o("i", {
              class: ht().UPLOAD_LOADING
            })
          ]) : Ve(),
          be && Ee && At ? o("div", {
            class: "vxe-upload--file-item-loading-text"
          }, we ? r.toFormatString(we, { percent: At.percent }) : Pe("vxe.upload.uploadProgress", [At.percent])) : Ve(),
          ze && Ye ? o("div", {
            class: "vxe-upload--image-item-error"
          }, [
            o(Vn, {
              icon: ht().UPLOAD_IMAGE_RE_UPLOAD,
              mode: "text",
              status: "primary",
              content: Pe("vxe.upload.reUpload"),
              onClick() {
                ne(Wt);
              }
            })
          ]) : Ve(),
          o("div", {
            class: "vxe-upload--file-item-btn-wrapper"
          }, [
            Dt ? o("div", {
              class: "vxe-upload--file-item-corner"
            }, Nt(Dt({ option: Wt, isMoreView: re, readonly: Ke }))) : Ve(),
            ee && !Ee ? o("div", {
              class: "vxe-upload--file-item-download-btn",
              onClick(rt) {
                Ie(rt, Wt);
              }
            }, [
              o("i", {
                class: ht().UPLOAD_FILE_DOWNLOAD
              })
            ]) : Ve(),
            N && !Ke && !ct && !Ee ? o("div", {
              class: "vxe-upload--file-item-remove-btn",
              onClick(rt) {
                Se(rt, Wt, nn);
              }
            }, [
              o("i", {
                class: ht().UPLOAD_FILE_REMOVE
              })
            ]) : Ve()
          ])
        ]);
      });
    }, Be = (F) => {
      const { showUploadButton: re, buttonText: N, buttonIcon: ee, showButtonText: be, showButtonIcon: we, autoHiddenButton: Te } = e, ze = v.value, st = w.value, ct = Q.value, Ke = C.value, wt = s.default, St = s.tip || s.hint;
      return st || !re ? Ve() : o("div", {
        class: "vxe-upload--file-action"
      }, [
        Te && Ke ? Ve() : o("div", {
          class: "vxe-upload--file-action-btn",
          onClick: ge
        }, wt ? Nt(wt({ $upload: K })) : [
          o(Vn, {
            class: "vxe-upload--file-action-button",
            content: F || be ? N ? `${N}` : Pe("vxe.upload.fileBtnText") : "",
            icon: we ? ee || ht().UPLOAD_FILE_ADD : "",
            disabled: ze
          })
        ]),
        F && (ct || St) ? o("div", {
          class: "vxe-upload--file-action-tip"
        }, St ? Nt(St({ $upload: K })) : ct) : Ve()
      ]);
    }, ve = () => {
      const { moreConfig: F } = e, { fileList: re } = u, N = ue.value, { maxCount: ee, showMoreButton: be, layout: we } = N, Te = we === "horizontal";
      let ze = re, st = 0;
      return ee && re.length > ee && (st = re.length - ee, ze = re.slice(0, ee)), o("div", {
        key: "all",
        class: "vxe-upload--file-wrapper"
      }, [
        be && F && Te ? Ve() : Be(!0),
        ze.length || be && Te ? o("div", {
          class: ["vxe-upload--file-list-wrapper", {
            "is--horizontal": Te
          }]
        }, [
          ze.length ? o("div", {
            class: "vxe-upload--file-list"
          }, Re(ze, !1)) : Ve(),
          be && st ? o("div", {
            class: "vxe-upload--file-over-more"
          }, [
            o(Vn, {
              mode: "text",
              content: Pe("vxe.upload.moreBtnText", [re.length]),
              status: "primary",
              onClick: vt
            })
          ]) : Ve(),
          be && F && Te ? Be(!1) : Ve()
        ]) : Ve()
      ]);
    }, Ne = (F, re) => {
      const { showRemoveButton: N, showProgress: ee, progressText: be, showPreview: we, showErrorStatus: Te } = e, { fileCacheMaps: ze } = u, st = v.value, ct = w.value, Ke = G.value, wt = s.corner;
      return F.map((St, Dt) => {
        const Wt = ye(St), nn = ze[Wt], zt = nn && nn.loading, At = nn && nn.status === "error";
        return o("div", {
          key: Dt,
          class: ["vxe-upload--image-item", {
            "is--preview": we,
            "is--loading": zt,
            "is--error": At
          }]
        }, [
          o("div", {
            class: "vxe-upload--image-item-box",
            style: re ? null : Ke,
            title: Pe("vxe.upload.viewItemTitle"),
            onClick(Ee) {
              !zt && !At && fe(Ee, St, Dt);
            }
          }, [
            zt && nn ? o("div", {
              class: "vxe-upload--image-item-loading"
            }, [
              o("div", {
                class: "vxe-upload--image-item-loading-icon"
              }, [
                o("i", {
                  class: ht().UPLOAD_LOADING
                })
              ]),
              ee ? o("div", {
                class: "vxe-upload--image-item-loading-text"
              }, be ? r.toFormatString(be, { percent: nn.percent }) : Pe("vxe.upload.uploadProgress", [nn.percent])) : Ve()
            ]) : Ve(),
            zt ? Ve() : At && Te ? o("div", {
              class: "vxe-upload--image-item-error"
            }, [
              o(Vn, {
                icon: ht().UPLOAD_IMAGE_RE_UPLOAD,
                mode: "text",
                status: "primary",
                content: Pe("vxe.upload.reUpload"),
                onClick() {
                  ne(St);
                }
              })
            ]) : o("img", {
              class: "vxe-upload--image-item-img",
              src: H(St)
            }),
            o("div", {
              class: "vxe-upload--image-item-btn-wrapper",
              onClick(Ee) {
                Ee.stopPropagation();
              }
            }, [
              wt ? o("div", {
                class: "vxe-upload--file-item-corner"
              }, Nt(wt({ option: St, isMoreView: re, readonly: ct }))) : Ve(),
              N && !ct && !st && !zt ? o("div", {
                class: "vxe-upload--image-item-remove-btn",
                onClick(Ee) {
                  Ee.stopPropagation(), Se(Ee, St, Dt);
                }
              }, [
                o("i", {
                  class: ht().UPLOAD_IMAGE_REMOVE
                })
              ]) : Ve()
            ])
          ])
        ]);
      });
    }, q = (F) => {
      const { showUploadButton: re, buttonText: N, buttonIcon: ee, showButtonText: be, showButtonIcon: we, autoHiddenButton: Te } = e, ze = w.value, st = Q.value, ct = C.value, Ke = G.value, wt = s.default, St = s.hint;
      return ze || !re || Te && ct ? Ve() : o("div", {
        key: "action",
        class: "vxe-upload--image-action"
      }, [
        o("div", {
          class: "vxe-upload--image-action-btn",
          onClick: ge
        }, wt ? wt({ $upload: K }) : [
          o("div", {
            class: "vxe-upload--image-action-box",
            style: F ? null : Ke
          }, [
            we ? o("div", {
              class: "vxe-upload--image-action-icon"
            }, [
              o("i", {
                class: ee || ht().UPLOAD_IMAGE_ADD
              })
            ]) : Ve(),
            F || be ? o("div", {
              class: "vxe-upload--image-action-content"
            }, N ? `${N}` : Pe("vxe.upload.imgBtnText")) : Ve(),
            F && (st || St) ? o("div", {
              class: "vxe-upload--image-action-hint"
            }, St ? Nt(St({ $upload: K })) : st) : Ve()
          ])
        ])
      ]);
    }, z = () => {
      const { fileList: F } = u, re = ue.value, { maxCount: N, showMoreButton: ee } = re;
      let be = F, we = 0;
      return N && F.length > N && (we = F.length - N, be = F.slice(0, N)), o("div", {
        key: "image",
        class: "vxe-upload--image-wrapper"
      }, [
        o("div", {
          class: "vxe-upload--image-list"
        }, Ne(be, !1).concat([
          ee && we ? o("div", {
            class: "vxe-upload--image-over-more"
          }, [
            o(Vn, {
              mode: "text",
              content: Pe("vxe.upload.moreBtnText", [F.length]),
              status: "primary",
              onClick: vt
            })
          ]) : Ve(),
          q(!1)
        ]))
      ]);
    }, R = () => {
      const { showErrorStatus: F, dragToUpload: re, pasteToUpload: N } = e, { isDrag: ee, showMorePopup: be, isActivated: we } = u, Te = c.value, ze = v.value, st = w.value, ct = S.value, Ke = {};
      return re && (Ke.onDragover = Ue, Ke.onDragleave = je, Ke.onDrop = _e), o("div", Object.assign({ ref: m, class: ["vxe-upload", {
        [`size--${Te}`]: Te,
        "is--active": we,
        "is--readonly": st,
        "is--disabled": ze,
        "is--paste": N,
        "show--error": F,
        "is--drag": ee
      }] }, Ke), [
        ct ? z() : ve(),
        ee && !be ? o("div", {
          class: "vxe-upload--drag-placeholder"
        }, Pe("vxe.upload.dragPlaceholder")) : Ve()
      ]);
    }, le = ke(0);
    return lt(() => e.modelValue ? e.modelValue.length : 0, () => {
      le.value++;
    }), lt(() => e.modelValue, () => {
      le.value++;
    }), lt(le, () => {
      se();
    }), wn(() => {
      process.env.NODE_ENV === "development" && e.multiple && e.singleMode && Ao("vxe.error.errConflicts", ["multiple", "single-mode"]), ut.on(K, "paste", dt), ut.on(K, "mousedown", at), ut.on(K, "blur", Et);
    }), $n(() => {
      u.isDrag = !1, ut.off(K, "paste"), ut.off(K, "mousedown"), ut.off(K, "blur");
    }), se(), K.renderVN = R, K;
  },
  render() {
    return this.renderVN();
  }
}), uA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o(Hl, {
            modelValue: t ? t.getItemValue(l) : null,
            mode: "all",
            multiple: a.multiple,
            limitCount: a.limitCount,
            limitSize: a.limitSize,
            onChange: s,
            "onUpdate:modelValue"(m) {
              t && t.setItemValue(l, m);
            }
          });
        }
      });
    };
  }
}), dA = () => ({
  title: yo,
  icon: "vxe-icon-file-image",
  options: {
    limitCount: 9,
    limitSize: 10,
    multiple: !1
  }
}), fA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e), n = ke(Wv());
    return () => {
      const { renderParams: s } = e, { widget: i } = s, { options: l } = i, a = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${a}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: l
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: i.title,
                  "onUpdate:modelValue"(c) {
                    i.title = c;
                  }
                });
              }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.uploadProp.multiImg"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            l.multiple ? o(kt, {
              title: Pe("vxe.formDesign.widgetProp.uploadProp.limitImgCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: !0 } }
            }) : Ve(),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.uploadProp.limitImgSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: n.value }
            }),
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return o(ao, {
                  modelValue: i.required,
                  "onUpdate:modelValue"(c) {
                    i.required = c;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), pA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, { options: a } = l, c = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${c}`],
        title: l.title,
        field: l.field,
        itemRender: {}
      }, {
        default() {
          return o(Hl, {
            modelValue: t ? t.getItemValue(l) : null,
            mode: "image",
            multiple: a.multiple,
            limitCount: a.limitCount,
            limitSize: a.limitSize,
            onChange: s,
            "onUpdate:modelValue"(m) {
              t && t.setItemValue(l, m);
            }
          });
        }
      });
    };
  }
}), mA = () => ({
  title: yo,
  icon: "vxe-icon-star",
  query: !0,
  options: {}
}), gA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), $i = pt({
  name: "VxeRate",
  props: {
    modelValue: [Number, String],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => oe().rate.size || oe().size
    },
    status: String
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { emit: n } = t, s = mt("$xeForm", null), i = mt("xeFormItemInfo", null), l = r.uniqueId(), { computeSize: a } = dn(e), c = ke(), m = Rt({
      activeValue: null
    }), u = {
      refElem: c
    }, d = _(() => {
      const { disabled: V } = e;
      return V === null ? s ? s.props.readonly || s.props.disabled : !1 : V;
    }), p = _(() => {
      const { modelValue: V } = e, { activeValue: Q } = m;
      return r.toNumber(Q === null ? V : Q);
    }), w = _(() => [1, 2, 3, 4, 5].map((V) => ({
      value: V,
      label: V
    }))), v = {}, D = {
      xID: l,
      props: e,
      context: t,
      reactData: m,
      getRefMaps: () => u,
      getComputeMaps: () => v
    }, S = (V, Q, Z) => {
      n(V, Zt(Z, { $rate: D }, Q));
    }, x = {
      dispatchEvent: S
    }, h = {}, O = (V) => {
      n("update:modelValue", V);
    }, g = (V, Q) => {
      if (!d.value) {
        const G = Q.value;
        m.activeValue = G;
      }
    }, b = () => {
      m.activeValue = null;
    }, E = (V, Q) => {
      if (!d.value) {
        const G = Q.value;
        O(G), S("change", { value: G }, V), s && i && s.triggerItemEvent(V, i.itemConfig.field, G);
      }
    };
    Object.assign(D, x, h);
    const C = () => {
      const { status: V } = e, Q = d.value, Z = w.value, G = a.value, ue = p.value;
      return o("div", {
        ref: c,
        class: ["vxe-rate", {
          [`size--${G}`]: G,
          [`theme--${V}`]: V,
          "is--disabled": Q
        }]
      }, Z.map((Y) => {
        const K = ue >= Y.value;
        return o("div", {
          class: ["vxe-rte--item", {
            "is--checked": K
          }],
          onMouseenter(L) {
            Q || g(L, Y);
          },
          onMouseleave: b,
          onClick(L) {
            Q || E(L, Y);
          }
        }, [
          o("i", {
            class: K ? ht().RATE_CHECKED : ht().RATE_UNCHECKED
          })
        ]);
      }));
    };
    return D.renderVN = C, D;
  },
  render() {
    return this.renderVN();
  }
}), hA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, a = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${a}`],
        field: l.field,
        title: l.title,
        itemRender: {}
      }, {
        default() {
          return o($i, {
            modelValue: t ? t.getItemValue(l) : null,
            onChange: s,
            "onUpdate:modelValue"(c) {
              t && t.setItemValue(l, c);
            }
          });
        }
      });
    };
  }
}), vA = () => ({
  title: yo,
  icon: "vxe-icon-slider",
  query: !0,
  options: {}
}), bA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const { computeKebabCaseName: t } = Dn(e);
    return () => {
      const { renderParams: n } = e, { widget: s } = n, i = t.value;
      return o(Nn, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${i}`],
        vertical: !0,
        span: 24,
        titleBold: !0,
        titleOverflow: !0,
        data: s.options
      }, {
        default() {
          return [
            o(kt, {
              title: Pe("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return o(Wn, {
                  modelValue: s.title,
                  "onUpdate:modelValue"(l) {
                    s.title = l;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
}), Ri = pt({
  name: "VxeSlider",
  props: {
    modelValue: [String, Number, Array],
    vertical: Boolean,
    max: {
      type: [String, Number],
      default: () => oe().slider.max
    },
    min: {
      type: [String, Number],
      default: () => oe().slider.min
    },
    step: {
      type: [String, Number],
      default: () => oe().slider.step
    },
    size: {
      type: String,
      default: () => oe().slider.size || oe().size
    },
    range: {
      type: Boolean,
      default: () => oe().slider.range
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { emit: n } = t, s = mt("$xeForm", null), i = mt("xeFormItemInfo", null), l = r.uniqueId(), { computeSize: a } = dn(e), c = ke(), m = ke(), u = ke(), d = ke(), p = ke(), w = Rt({
      startValue: 0,
      endValue: 0
    }), v = {
      refElem: c
    }, D = _(() => {
      const { readonly: P } = e;
      return P === null ? s ? s.props.readonly : !1 : P;
    }), S = _(() => {
      const { disabled: P } = e;
      return P === null ? s ? s.props.disabled : !1 : P;
    }), x = _(() => r.toNumber(e.max || 0)), h = _(() => r.toNumber(e.min || 0)), O = {}, g = {
      xID: l,
      props: e,
      context: t,
      reactData: w,
      getRefMaps: () => v,
      getComputeMaps: () => O
    }, b = (P) => {
      n("update:modelValue", P);
    }, E = (P, M, I) => {
      n(P, Zt(I, { $slider: g }, M));
    }, C = {
      dispatchEvent: E
    }, V = (P) => {
      const { range: M } = e, I = x.value, B = h.value;
      return M ? r.floor((P - B) / r.toNumber(I - B) * 100) : 0;
    }, Q = (P, M) => {
      const { range: I } = e, B = x.value, H = h.value;
      return r.floor((M - (I ? P : 0) - H) / r.toNumber(B - H) * 100);
    }, Z = () => {
      const { modelValue: P } = e;
      if (r.isArray(P)) {
        const [M, I] = r.clone(P, !0).sort();
        w.startValue = r.floor(r.toNumber(M || 0)), w.endValue = r.floor(r.toNumber(I || 0));
      } else
        w.startValue = 0, w.endValue = r.floor(r.toNumber(P || 0));
    }, G = () => {
      const { startValue: P, endValue: M } = w, I = u.value, B = d.value, H = p.value;
      let ce = 0, A = 0;
      P > M ? (ce = V(M), A = Q(M, P)) : (ce = V(P), A = Q(P, M)), I && (I.style.left = `${ce}%`, I.style.width = `${A}%`), B && (B.style.left = `${ce}%`), H && (H.style.left = `${r.floor(ce + A)}%`);
    }, ue = (P) => {
      const { range: M } = e, { startValue: I, endValue: B } = w, H = M ? [I, B].sort() : B;
      b(H), E("change", { value: H }, P), s && i && s.triggerItemEvent(P, i.itemConfig.field, H);
    }, Y = (P, M) => {
      const I = D.value, B = S.value, H = x.value, ce = h.value;
      if (!(I || B)) {
        P.preventDefault();
        const A = document.onmousemove, j = document.onmouseup;
        document.onmousemove = (fe) => {
          fe.preventDefault();
          const pe = c.value, ne = m.value;
          if (pe && ne) {
            const $ = ne.getBoundingClientRect(), J = (fe.clientX - $.left) / $.width;
            M ? w.endValue = r.floor(Math.max(ce, Math.min(H, J * (H - ce) + ce))) : w.startValue = r.floor(Math.max(ce, Math.min(H, J * (H - ce))));
          }
          G();
        }, document.onmouseup = (fe) => {
          document.onmousemove = A, document.onmouseup = j, ue(fe), G();
        };
      }
    }, K = (P) => {
      const M = p.value, I = P.currentTarget;
      Y(P, M ? M.offsetLeft < I.offsetLeft : !1);
    }, L = (P) => {
      const M = d.value, I = P.currentTarget;
      Y(P, M ? I.offsetLeft > M.offsetLeft : !0);
    };
    Object.assign(g, C, {});
    const se = () => {
      const { vertical: P, range: M } = e, I = a.value, B = D.value, H = S.value;
      return o("div", {
        ref: c,
        class: ["vxe-slider", {
          [`size--${I}`]: I,
          "is--vertical": P,
          "is--readonly": B,
          "is--disabled": H
        }]
      }, [
        o("div", {
          class: "vxe-slider--inner"
        }, [
          o("div", {
            ref: m,
            class: "vxe-slider--bar-wrapper"
          }),
          o("div", {
            ref: u,
            class: "vxe-slider--bar-track"
          }),
          B || !M ? Yn() : o("div", {
            ref: d,
            class: "vxe-slider--bar-btn vxe-slider--start-btn",
            onMousedown: K
          }),
          B ? Yn() : o("div", {
            ref: p,
            class: "vxe-slider--bar-btn vxe-slider--end-btn",
            onMousedown: L
          })
        ])
      ]);
    };
    return lt(() => e.modelValue, () => {
      Z();
    }), wn(() => {
      G();
    }), Z(), g.renderVN = se, g;
  },
  render() {
    return this.renderVN();
  }
}), xA = pt({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(e) {
    const t = mt("$xeFormView", null), { computeKebabCaseName: n } = Dn(e), s = () => {
      const { renderParams: i } = e, { widget: l } = i;
      if (t) {
        const a = t ? t.getItemValue(l) : null;
        t.updateWidgetStatus(l, a);
      }
    };
    return () => {
      const { renderParams: i } = e, { widget: l } = i, a = n.value;
      return o(kt, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${a}`],
        field: l.field,
        title: l.title,
        itemRender: {}
      }, {
        default() {
          return o(Ri, {
            modelValue: t ? t.getItemValue(l) : null,
            onChange: s,
            "onUpdate:modelValue"(c) {
              t && t.setItemValue(l, c);
            }
          });
        }
      });
    };
  }
});
Cn.mixin({
  text: {
    createFormDesignWidgetConfig: pm,
    renderFormDesignWidgetView(e, t) {
      return o(gm, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(mm, { renderOpts: e, renderParams: t });
    }
  },
  /**
   * 已废弃
   */
  title: {
    createFormDesignWidgetConfig: pm,
    renderFormDesignWidgetView(e, t) {
      return o(gm, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(mm, { renderOpts: e, renderParams: t });
    }
  },
  row: {
    createFormDesignWidgetConfig: f0,
    renderFormDesignWidgetEdit(e, t) {
      return o(g0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetView(e, t) {
      return o(h0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(p0, { renderOpts: e, renderParams: t });
    }
  },
  subtable: {
    createFormDesignWidgetConfig: v0,
    renderFormDesignWidgetEdit(e, t) {
      return o(y0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetView(e, t) {
      return o(C0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(b0, { renderOpts: e, renderParams: t });
    }
  },
  input: {
    createFormDesignWidgetConfig: w0,
    renderFormDesignWidgetView(e, t) {
      return o(S0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(E0, { renderOpts: e, renderParams: t });
    }
  },
  textarea: {
    createFormDesignWidgetConfig: D0,
    renderFormDesignWidgetView(e, t) {
      return o(T0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(O0, { renderOpts: e, renderParams: t });
    }
  },
  select: {
    createFormDesignWidgetConfig: M0,
    renderFormDesignWidgetView(e, t) {
      return o(V0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(I0, { renderOpts: e, renderParams: t });
    }
  },
  VxeInput: {
    createFormDesignWidgetConfig: P0,
    renderFormDesignWidgetView(e, t) {
      return o($0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(k0, { renderOpts: e, renderParams: t });
    }
  },
  VxeNumberInput: {
    createFormDesignWidgetConfig: R0,
    renderFormDesignWidgetView(e, t) {
      return o(F0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(N0, { renderOpts: e, renderParams: t });
    }
  },
  VxeDatePicker: {
    createFormDesignWidgetConfig: L0,
    renderFormDesignWidgetView(e, t) {
      return o(B0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(A0, { renderOpts: e, renderParams: t });
    }
  },
  VxeTextarea: {
    createFormDesignWidgetConfig: _0,
    renderFormDesignWidgetView(e, t) {
      return o(z0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(W0, { renderOpts: e, renderParams: t });
    }
  },
  VxeSwitch: {
    createFormDesignWidgetConfig: H0,
    renderFormDesignWidgetView(e, t) {
      return o(q0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(j0, { renderOpts: e, renderParams: t });
    }
  },
  VxeSelect: {
    createFormDesignWidgetConfig: U0,
    renderFormDesignWidgetView(e, t) {
      return o(K0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(G0, { renderOpts: e, renderParams: t });
    }
  },
  VxeTreeSelect: {
    createFormDesignWidgetConfig: Y0,
    renderFormDesignWidgetView(e, t) {
      return o(J0, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(X0, { renderOpts: e, renderParams: t });
    }
  },
  VxeRadioGroup: {
    createFormDesignWidgetConfig: Q0,
    renderFormDesignWidgetView(e, t) {
      return o(tA, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(eA, { renderOpts: e, renderParams: t });
    }
  },
  VxeCheckboxGroup: {
    createFormDesignWidgetConfig: nA,
    renderFormDesignWidgetView(e, t) {
      return o(sA, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(oA, { renderOpts: e, renderParams: t });
    }
  },
  VxeUploadFile: {
    createFormDesignWidgetConfig: rA,
    renderFormDesignWidgetView(e, t) {
      return o(uA, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(lA, { renderOpts: e, renderParams: t });
    }
  },
  VxeUploadImage: {
    createFormDesignWidgetConfig: dA,
    renderFormDesignWidgetView(e, t) {
      return o(pA, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(fA, { renderOpts: e, renderParams: t });
    }
  },
  VxeRate: {
    createFormDesignWidgetConfig: mA,
    renderFormDesignWidgetView(e, t) {
      return o(hA, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(gA, { renderOpts: e, renderParams: t });
    }
  },
  VxeSlider: {
    createFormDesignWidgetConfig: vA,
    renderFormDesignWidgetView(e, t) {
      return o(xA, { renderOpts: e, renderParams: t });
    },
    renderFormDesignWidgetFormView(e, t) {
      return o(bA, { renderOpts: e, renderParams: t });
    }
  }
});
const yA = Object.assign({}, Za, {
  install(e) {
    e.component(Za.name, Za);
  }
}), Hv = {
  useWidgetName: Dn,
  useWidgetView: l0,
  useSubtableView: i0,
  useWidgetPropDataSource: na
};
Ht.use(yA);
Ce.component(Za);
Ce.formDesignHandle = Hv;
Ce.formDesign = Hv;
const Ja = Object.assign({}, Nr, { name: "VxeFormGather" }), CA = Object.assign(Ja, {
  install(e) {
    e.component(Ja.name, Ja);
  }
});
Ht.use(CA);
Ce.component(Ja);
const jv = Object.assign(Nr, {
  install(e) {
    e.component(Nr.name, Nr);
  }
});
Ht.use(jv);
Ce.component(Nr);
const qv = Object.assign(kt, {
  install(e) {
    e.component(kt.name, kt);
  }
});
Ht.use(qv);
Ce.component(kt);
const wA = Object.assign(Ti, {
  install: function(e) {
    e.component(Ti.name, Ti);
  }
});
Ht.use(wA);
Ce.component(Ti);
const Uv = Object.assign({}, _l, {
  install(e) {
    e.component(_l.name, _l);
  }
});
Ht.use(Uv);
Ce.component(_l);
const Qa = pt({
  name: "VxeIconPicker",
  props: {
    modelValue: String,
    placeholder: String,
    clearable: Boolean,
    size: {
      type: String,
      default: () => oe().iconPicker.size || oe().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    showIconTitle: {
      type: Boolean,
      default: () => oe().iconPicker.showIconTitle
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    icons: Array,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "click"
  ],
  setup(e, t) {
    const { emit: n } = t, s = mt("$xeModal", null), i = mt("$xeDrawer", null), l = mt("$xeTable", null), a = mt("$xeForm", null), c = mt("xeFormItemInfo", null), m = r.uniqueId(), { computeSize: u } = dn(e), d = Rt({
      initialized: !1,
      selectIcon: `${e.modelValue || ""}`,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: !1,
      isAniVisible: !1,
      isActivated: !1
    }), p = {
      hpTimeout: void 0
    }, w = ke(), v = ke(), D = ke(), S = {
      refElem: w
    }, x = {
      xID: m,
      props: e,
      context: t,
      reactData: d,
      getRefMaps: () => S
    };
    let h = {};
    const O = _(() => {
      const { readonly: ne } = e;
      return ne === null ? a ? a.props.readonly : !1 : ne;
    }), g = _(() => {
      const { disabled: ne } = e;
      return ne === null ? a ? a.props.disabled : !1 : ne;
    }), b = _(() => {
      const { transfer: ne } = e;
      if (ne === null) {
        const $ = oe().iconPicker.transfer;
        if (r.isBoolean($))
          return $;
        if (l || s || i || a)
          return !0;
      }
      return ne;
    }), E = _(() => {
      const { placeholder: ne } = e;
      if (ne)
        return Bn(ne);
      const $ = oe().select.placeholder;
      return $ ? Bn($) : Pe("vxe.base.pleaseSelect");
    }), C = _(() => {
      let { icons: ne } = e;
      return (!ne || !ne.length) && (ne = oe().iconPicker.icons || []), ne.map(($) => ({
        title: $,
        icon: `vxe-icon-${$}`
      }));
    }), V = _(() => {
      const ne = C.value;
      return r.chunk(ne, 4);
    }), Q = () => {
      d.panelIndex < ws() && (d.panelIndex = ds());
    }, Z = () => me().then(() => {
      const { placement: ne } = e, { panelIndex: $ } = d, J = w.value, ge = D.value, Oe = b.value;
      if (ge && J) {
        const Se = J.offsetHeight, de = J.offsetWidth, Ie = ge.offsetHeight, je = ge.offsetWidth, Ue = 5, Ae = {
          zIndex: $
        }, { boundingTop: _e, boundingLeft: it, visibleHeight: vt, visibleWidth: dt } = br(J);
        let at = "bottom";
        if (Oe) {
          let Et = it, Qe = _e + Se;
          ne === "top" ? (at = "top", Qe = _e - Ie) : ne || (Qe + Ie + Ue > vt && (at = "top", Qe = _e - Ie), Qe < Ue && (at = "bottom", Qe = _e + Se)), Et + je + Ue > dt && (Et -= Et + je + Ue - dt), Et < Ue && (Et = Ue), Object.assign(Ae, {
            left: `${Et}px`,
            top: `${Qe}px`,
            minWidth: `${de}px`
          });
        } else
          ne === "top" ? (at = "top", Ae.bottom = `${Se}px`) : ne || _e + Se + Ie > vt && _e - Se - Ie > Ue && (at = "top", Ae.bottom = `${Se}px`);
        return d.panelStyle = Ae, d.panelPlacement = at, me();
      }
    }), G = () => {
      const { hpTimeout: ne } = p;
      g.value || (ne && (clearTimeout(ne), p.hpTimeout = void 0), d.initialized || (d.initialized = !0), d.isActivated = !0, d.isAniVisible = !0, setTimeout(() => {
        d.visiblePanel = !0;
      }, 10), Q(), Z());
    }, ue = () => {
      d.visiblePanel = !1, p.hpTimeout = window.setTimeout(() => {
        d.isAniVisible = !1;
      }, 350);
    }, Y = (ne, $) => {
      d.selectIcon = $, $ !== e.modelValue && (n("update:modelValue", $), h.dispatchEvent("change", { value: $ }, ne), a && c && a.triggerItemEvent(ne, c.itemConfig.field, $));
    }, K = () => {
      g.value || d.visiblePanel || G();
    }, L = () => {
      d.isActivated = !1;
    }, ye = (ne, $) => {
      Y(ne, $), h.dispatchEvent("clear", { value: $ }, ne);
    }, se = (ne, $) => {
      ye($, null), ue();
    }, P = (ne) => {
      ne.preventDefault(), d.visiblePanel ? ue() : G();
    }, M = (ne) => {
      P(ne), h.dispatchEvent("click", {}, ne);
    }, I = (ne) => {
      const { visiblePanel: $ } = d;
      if (!g.value && $) {
        const ge = D.value;
        jn(ne, ge).flag ? Z() : ue();
      }
    }, B = (ne) => {
      const { visiblePanel: $ } = d;
      if (!g.value) {
        const ge = w.value, Oe = D.value;
        d.isActivated = jn(ne, ge).flag || jn(ne, Oe).flag, $ && !d.isActivated && ue();
      }
    }, H = (ne) => {
      const { clearable: $ } = e, { visiblePanel: J } = d;
      if (!g.value) {
        const Oe = ut.hasKey(ne, Yt.TAB), Se = ut.hasKey(ne, Yt.ENTER), de = ut.hasKey(ne, Yt.ESCAPE), Ie = ut.hasKey(ne, Yt.ARROW_UP), je = ut.hasKey(ne, Yt.ARROW_DOWN), Ue = ut.hasKey(ne, Yt.DELETE), Ae = ut.hasKey(ne, Yt.SPACEBAR);
        Oe && (d.isActivated = !1), J ? de || Oe ? ue() : Se ? (ne.preventDefault(), ne.stopPropagation()) : (Ie || je || Ae) && ne.preventDefault() : (Ie || je || Se || Ae) && d.isActivated && (ne.preventDefault(), G()), d.isActivated && Ue && $ && ye(ne, null);
      }
    }, ce = () => {
      ue();
    };
    h = {
      dispatchEvent: (ne, $, J) => {
        n(ne, Zt(J, { $iconPicker: x }, $));
      },
      isPanelVisible() {
        return d.visiblePanel;
      },
      togglePanel() {
        return d.visiblePanel ? ue() : G(), me();
      },
      hidePanel() {
        return d.visiblePanel && ue(), me();
      },
      showPanel() {
        return d.visiblePanel || G(), me();
      },
      focus() {
        const ne = v.value;
        return d.isActivated = !0, ne.blur(), me();
      },
      blur() {
        return v.value.blur(), d.isActivated = !1, me();
      }
    };
    const j = (ne, $) => {
      const J = $.icon;
      Y(ne, J), ue();
    };
    Object.assign(x, h);
    const fe = () => {
      const { showIconTitle: ne } = e, $ = V.value, J = g.value;
      return o("div", {
        class: "vxe-ico-picker--list-wrapper"
      }, $.map((ge) => o("div", {
        class: "vxe-ico-picker--list"
      }, ge.map((Oe) => o("div", {
        class: "vxe-ico-picker--item",
        onClick(Se) {
          J || j(Se, Oe);
        }
      }, [
        o("div", {
          class: "vxe-ico-picker--item-icon"
        }, [
          o("i", {
            class: Oe.icon || ""
          })
        ]),
        ne ? o("div", {
          class: "vxe-ico-picker--item-title"
        }, `${Oe.title || ""}`) : Ve()
      ])))));
    }, pe = () => {
      const { className: ne, popupClassName: $, clearable: J } = e, { initialized: ge, isActivated: Oe, isAniVisible: Se, visiblePanel: de, selectIcon: Ie } = d, je = u.value, Ue = g.value, Ae = b.value, _e = O.value, it = E.value;
      return _e ? o("div", {
        ref: w,
        class: ["vxe-ico-picker--readonly", ne]
      }, [
        o("i", {
          class: Ie
        })
      ]) : o("div", {
        ref: w,
        class: ["vxe-ico-picker", ne ? r.isFunction(ne) ? ne({ $iconPicker: x }) : ne : "", {
          [`size--${je}`]: je,
          "show--clear": J && !Ue && !!Ie,
          "is--visible": de,
          "is--disabled": Ue,
          "is--active": Oe
        }]
      }, [
        o("div", {
          class: "vxe-ico-picker--inner",
          onClick: M
        }, [
          o("input", {
            ref: v,
            class: "vxe-ico-picker--input",
            onFocus: K,
            onBlur: L
          }),
          Ie ? o("div", {
            class: "vxe-ico-picker--icon"
          }, [
            o("i", {
              class: Ie
            })
          ]) : o("div", {
            class: "vxe-ico-picker--placeholder"
          }, it),
          o("div", {
            class: "vxe-ico-picker--suffix"
          }, [
            o("div", {
              class: "vxe-ico-picker--clear-icon",
              onClick: se
            }, [
              o("i", {
                class: ht().INPUT_CLEAR
              })
            ]),
            o("div", {
              class: "vxe-ico-picker--suffix-icon"
            }, [
              o("i", {
                class: de ? ht().ICON_PICKER_OPEN : ht().ICON_PICKER_CLOSE
              })
            ])
          ])
        ]),
        o(ks, {
          to: "body",
          disabled: Ae ? !ge : !0
        }, [
          o("div", {
            ref: D,
            class: ["vxe-table--ignore-clear vxe-ico-picker--panel", $ ? r.isFunction($) ? $({ $iconPicker: x }) : $ : "", {
              [`size--${je}`]: je,
              "is--transfer": Ae,
              "ani--leave": Se,
              "ani--enter": de
            }],
            placement: d.panelPlacement,
            style: d.panelStyle
          }, [
            ge && (de || Se) ? o("div", {
              class: "vxe-ico-picker--panel-wrapper"
            }, [
              fe()
            ]) : Ve()
          ])
        ])
      ]);
    };
    return lt(() => e.modelValue, (ne) => {
      d.selectIcon = `${ne || ""}`;
    }), wn(() => {
      ut.on(x, "mousewheel", I), ut.on(x, "mousedown", B), ut.on(x, "keydown", H), ut.on(x, "blur", ce);
    }), $n(() => {
      ut.off(x, "mousewheel"), ut.off(x, "mousedown"), ut.off(x, "keydown"), ut.off(x, "blur");
    }), bn("$xeIconPicker", x), x.renderVN = pe, x;
  },
  render() {
    return this.renderVN();
  }
}), EA = Object.assign(Qa, {
  install: function(e) {
    e.component(Qa.name, Qa);
  }
});
Ht.use(EA);
Ce.component(Qa);
const Ni = pt({
  name: "VxeImagePreview",
  props: {
    modelValue: Number,
    urlList: Array,
    urlField: {
      type: String,
      default: () => oe().imagePreview.urlField
    },
    maskClosable: {
      type: Boolean,
      default: () => oe().imagePreview.maskClosable
    },
    marginSize: {
      type: String,
      default: () => oe().imagePreview.marginSize
    },
    showPrintButton: {
      type: Boolean,
      default: () => oe().imagePreview.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => oe().imagePreview.showDownloadButton
    },
    beforeDownloadMethod: Function,
    downloadMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "download",
    "download-fail",
    "close"
  ],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), i = ke(), l = {
      refElem: i
    }, a = Rt({
      activeIndex: e.modelValue || 0,
      offsetPct11: !1,
      offsetScale: 0,
      offsetRotate: 0,
      offsetLeft: 0,
      offsetTop: 0
    }), c = _(() => e.urlField || "url"), m = _(() => r.toNumber(e.marginSize || 0) || 16), u = _(() => {
      const { offsetRotate: A } = a;
      return A ? `${A}°` : "0°";
    }), d = _(() => {
      const { offsetScale: A } = a;
      return A ? `${r.ceil((1 + A) * 100)}%` : "100%";
    }), p = _(() => {
      const { urlList: A } = e, j = c.value;
      return A && A.length ? A.map((fe) => r.isString(fe) ? fe : fe[j] ? fe[j] : "") : [];
    }), w = _(() => {
      let { offsetScale: A, offsetRotate: j, offsetLeft: fe, offsetTop: pe } = a;
      const ne = [];
      let $ = 1;
      if (A && ($ = 1 + A, ne.push(`scale(${$})`)), j && ne.push(`rotate(${j}deg)`), fe || pe) {
        fe /= $, pe /= $;
        let J = fe, ge = pe;
        if (j)
          switch (j % 360) {
            case 90:
            case -270:
              J = pe, ge = -fe;
              break;
            case 180:
            case -180:
              J = -fe, ge = -pe;
              break;
            case 270:
            case -90:
              J = -pe, ge = fe;
              break;
          }
        ne.push(`translate(${J}px, ${ge}px)`);
      }
      return ne.length ? ne.join(" ") : "";
    }), v = {
      computeImgList: p
    }, D = {
      xID: s,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => l,
      getComputeMaps: () => v
    }, S = (A, j, fe) => {
      n(A, Zt(fe, { $imagePreview: D }, j));
    }, x = {
      dispatchEvent: S
    }, h = (A) => {
      a.activeIndex = A, n("update:modelValue", A);
    }, O = (A) => {
      S("close", {}, A);
    }, g = {}, b = () => {
      const A = i.value;
      Na(A, "is--move"), Object.assign(a, {
        offsetPct11: !1,
        offsetScale: 0,
        offsetRotate: 0,
        offsetLeft: 0,
        offsetTop: 0
      });
    }, E = () => {
      const { offsetScale: A } = a;
      let j = 0.02;
      return A >= -0.6 && (j = 0.04, A >= -0.4 && (j = 0.07, A >= 0 && (j = 0.1, A >= 3 && (j = 0.25, A >= 8 && (j = 0.4, A >= 16 && (j = 0.6, A >= 24 && (j = 0.9, A >= 32 && (j = 1.3, A >= 39 && (j = 1.9, A >= 45 && (j = 2.5)))))))))), j;
    }, C = (A) => {
      const { offsetScale: j } = a, fe = E();
      A ? a.offsetScale = Number(Math.min(49, j + fe).toFixed(2)) : a.offsetScale = Number(Math.max(-0.9, j - fe).toFixed(2));
    }, V = (A) => {
      let j = a.activeIndex || 0;
      const fe = p.value;
      A ? j >= fe.length - 1 ? j = 0 : j++ : j <= 0 ? j = fe.length - 1 : j--, b(), a.activeIndex = j, h(j);
    }, Q = (A) => {
      let j = a.offsetRotate;
      A ? j += 90 : j -= 90, a.offsetRotate = j;
    }, Z = () => {
      b(), a.offsetPct11 = !0;
    }, G = () => {
      const { activeIndex: A } = a, fe = p.value[A || 0];
      Ce.print && Ce.print({
        align: "center",
        pageBreaks: [
          {
            bodyHtml: `<img src="${fe}" style="max-width:100%;max-height:100%;">`
          }
        ]
      });
    }, ue = (A, j) => {
      S("download", { url: j }, A);
    }, Y = (A, j) => {
      Ce.saveFile && fetch(j).then((fe) => fe.blob().then((pe) => {
        Ce.saveFile({
          filename: j,
          content: pe
        }), ue(A, j);
      })).catch(() => {
        Ce.modal && Ce.modal.message({
          content: Pe("vxe.error.downErr"),
          status: "error"
        });
      });
    }, K = (A) => {
      const { activeIndex: j } = a, pe = p.value[j || 0], ne = e.beforeDownloadMethod || oe().imagePreview.beforeDownloadMethod, $ = e.downloadMethod || oe().imagePreview.downloadMethod;
      Promise.resolve(ne ? ne({
        $imagePreview: D,
        url: pe,
        index: j || 0
      }) : !0).then((J) => {
        J && ($ ? Promise.resolve($({
          $imagePreview: D,
          url: pe,
          index: j || 0
        })).then(() => {
          ue(A, pe);
        }).catch((ge) => ge) : Y(A, pe));
      });
    }, L = (A, j) => {
      const { activeIndex: fe } = a;
      if (p.value[fe || 0])
        switch (j) {
          case "zoomOut":
            C(!1);
            break;
          case "zoomIn":
            C(!0);
            break;
          case "pctFull":
            b();
            break;
          case "pct11":
            Z();
            break;
          case "rotateLeft":
            Q(!1);
            break;
          case "rotateRight":
            Q(!0);
            break;
          case "print":
            G();
            break;
          case "download":
            K(A);
            break;
        }
    }, ye = (A) => {
      const j = A.deltaY;
      j > 0 ? C(!1) : j < 0 && C(!0);
    }, se = (A) => {
      const { offsetTop: j, offsetLeft: fe } = a, pe = i.value;
      A.preventDefault();
      const ne = document.onmousemove, $ = document.onmouseup, J = A.pageX, ge = A.pageY, Oe = m.value;
      document.onmousemove = (Se) => {
        const { pageX: de, pageY: Ie } = Se, { visibleHeight: je, visibleWidth: Ue } = tl();
        Se.preventDefault(), oL(pe, "is--move"), de > Oe && Ie > Oe && de < Ue - Oe && Ie < je - Oe && (a.offsetLeft = fe + de - J, a.offsetTop = j + Ie - ge);
      }, document.onmouseup = () => {
        document.onmousemove = ne, document.onmouseup = $, Na(pe, "is--move");
      };
    }, P = (A) => {
      const j = A.ctrlKey, fe = A.shiftKey, pe = ut.hasKey(A, Yt.ARROW_UP), ne = ut.hasKey(A, Yt.ARROW_DOWN), $ = ut.hasKey(A, Yt.ARROW_LEFT), J = ut.hasKey(A, Yt.ARROW_RIGHT), ge = ut.hasKey(A, Yt.R), Oe = ut.hasKey(A, Yt.P);
      pe ? (A.preventDefault(), fe ? a.offsetTop -= 1 : C(!0)) : ne ? (A.preventDefault(), fe ? a.offsetTop += 1 : C(!1)) : $ ? (A.preventDefault(), fe ? a.offsetLeft -= 1 : V(!1)) : J ? (A.preventDefault(), fe ? a.offsetLeft += 1 : V(!0)) : ge && j ? (A.preventDefault(), Q(!fe)) : Oe && j && (A.preventDefault(), G());
    }, M = (A) => {
      e.maskClosable && A.target === A.currentTarget && S("close", {}, A);
    };
    Object.assign(D, x, g);
    const I = () => {
      const { activeIndex: A } = a, j = p.value, fe = w.value;
      return o("div", {
        class: "vxe-image-preview--img-list",
        onClick: M
      }, j.map((pe, ne) => {
        const $ = A === ne;
        return o("img", {
          class: ["vxe-image-preview--img-item", {
            "is--active": $
          }],
          src: pe,
          style: $ ? {
            transform: fe
          } : null,
          onMousedown(J) {
            se(J);
          }
        });
      }));
    }, B = (A, j) => o("div", {
      class: "vxe-image-preview--operation-btn",
      title: Pe(`vxe.imagePreview.operBtn.${A}`),
      onClick(fe) {
        L(fe, A);
      }
    }, [
      o("i", {
        class: ht()[j]
      })
    ]), H = () => {
      const { showPrintButton: A, showDownloadButton: j } = e, { activeIndex: fe } = a, pe = p.value, ne = u.value, $ = d.value;
      return o("div", {
        class: "vxe-image-preview--btn-wrapper"
      }, [
        o("div", {
          class: "vxe-image-preview--close-wrapper"
        }, [
          o("div", {
            class: "vxe-image-preview--close-btn",
            onClick: O
          }, [
            o("i", {
              class: ht().IMAGE_PREVIEW_CLOSE
            })
          ]),
          o("div", {
            class: "vxe-image-preview--close-bg"
          })
        ]),
        pe.length > 1 ? o("div", {
          class: "vxe-image-preview--previous-btn",
          onClick() {
            V(!1);
          }
        }, [
          o("i", {
            class: ht().IMAGE_PREVIEW_PREVIOUS
          })
        ]) : Ve(),
        pe.length > 1 ? o("div", {
          class: "vxe-image-preview--next-btn",
          onClick() {
            V(!0);
          }
        }, [
          o("i", {
            class: ht().IMAGE_PREVIEW_NEXT
          })
        ]) : Ve(),
        o("div", {
          class: "vxe-image-preview--operation-info"
        }, [
          o("div", {
            class: "vxe-image-preview--operation-deg"
          }, ne),
          o("div", {
            class: "vxe-image-preview--operation-pct"
          }, $)
        ]),
        o("div", {
          class: "vxe-image-preview--operation-wrapper"
        }, [
          o("div", {
            class: "vxe-image-preview--operation-active-count"
          }, [
            o("span", {
              class: "vxe-image-preview--operation-active-current"
            }, `${(fe || 0) + 1}`),
            o("span", {
              class: "vxe-image-preview--operation-active-total"
            }, `/${pe.length}`)
          ]),
          B("zoomOut", "IMAGE_PREVIEW_ZOOM_OUT"),
          B("zoomIn", "IMAGE_PREVIEW_ZOOM_IN"),
          B("pctFull", "IMAGE_PREVIEW_PCT_FULL"),
          B("pct11", "IMAGE_PREVIEW_PCT_1_1"),
          B("rotateLeft", "IMAGE_PREVIEW_ROTATE_LEFT"),
          B("rotateRight", "IMAGE_PREVIEW_ROTATE_RIGHT"),
          A ? B("print", "IMAGE_PREVIEW_PRINT") : Ve(),
          j ? B("download", "IMAGE_PREVIEW_DOWNLOAD") : Ve()
        ])
      ]);
    }, ce = () => {
      const { offsetPct11: A } = a;
      return o("div", {
        ref: i,
        class: ["vxe-image-preview", {
          "is--pct11": A
        }],
        onWheel: ye
      }, [
        I(),
        H()
      ]);
    };
    return lt(() => e.modelValue, (A) => {
      a.activeIndex = A, b();
    }), wn(() => {
      ut.on(D, "keydown", P);
    }), Us(() => {
      const A = i.value;
      A && Na(A, "is--move");
    }), $n(() => {
      ut.off(D, "keydown");
    }), bn("$xeImagePreview", D), D.renderVN = ce, ce;
  }
}), Pd = (e) => {
  if (Ce.modal) {
    const t = Object.assign({
      escClosable: !0
    }, e), { urlList: n, activeIndex: s } = t, i = r.uniqueId("image-preview");
    Ce.modal.open({
      id: i,
      title: "预览",
      width: "100%",
      height: "100%",
      showHeader: !1,
      showFooter: !1,
      padding: !1,
      escClosable: t.escClosable,
      className: "vxe-image-preview-popup-wrapper",
      slots: {
        default() {
          return o(Ni, {
            modelValue: s,
            urlList: n,
            urlField: t.urlField,
            marginSize: t.marginSize,
            maskClosable: t.maskClosable,
            showPrintButton: t.showPrintButton,
            showDownloadButton: t.showDownloadButton,
            beforeDownloadMethod: t.beforeDownloadMethod,
            downloadMethod: t.downloadMethod,
            onClose() {
              Ce.modal.close(i);
            }
          });
        }
      }
    });
  }
  return Promise.resolve();
}, Fi = pt({
  name: "VxeImage",
  props: {
    src: [String, Array],
    alt: [String, Number],
    loading: String,
    title: [String, Number],
    width: [String, Number],
    height: [String, Number],
    maskClosable: {
      type: Boolean,
      default: () => oe().image.maskClosable
    },
    showPreview: {
      type: Boolean,
      default: () => oe().image.showPreview
    },
    showPrintButton: {
      type: Boolean,
      default: () => oe().image.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => oe().image.showDownloadButton
    },
    size: { type: String, default: () => oe().image.size || oe().size }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), i = mt("$xeImageGroup", null), l = ke(), { computeSize: a } = dn(e), c = Rt({}), m = {
      refElem: l
    }, u = _(() => {
      const { width: g, height: b } = e, E = {};
      return g && b ? (E.maxWidth = cn(g), E.maxHeight = cn(b)) : (g && (E.width = cn(g)), b && (E.height = cn(b))), E;
    }), d = _(() => {
      const { src: g } = e;
      return g ? (r.isArray(g) ? g : [g]).map((b) => r.isString(b) ? {
        url: b,
        alt: ""
      } : {
        url: b.url,
        alt: b.alt
      }) : [];
    }), p = _(() => d.value[0]), w = _(() => {
      const g = p.value;
      return g ? `${g.url || ""}` : "";
    }), v = {
      computeSize: a
    }, D = {
      xID: s,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => v
    }, S = {
      dispatchEvent(g, b, E) {
        n(g, Zt(E, { $image: D }, b));
      }
    }, x = (g) => {
      const { showPreview: b, showPrintButton: E, showDownloadButton: C, maskClosable: V } = e, Q = d.value, Z = w.value;
      i ? i.handleClickImgEvent(g, { url: Z }) : (b && Z && Pd({
        urlList: Q,
        showPrintButton: E,
        showDownloadButton: C,
        maskClosable: V
      }), S.dispatchEvent("click", { url: Z }, g));
    };
    Object.assign(D, S, {});
    const O = () => {
      const { alt: g, loading: b } = e, E = u.value, C = w.value, V = a.value;
      return o("img", {
        ref: l,
        class: ["vxe-image", {
          [`size--${V}`]: V
        }],
        src: C,
        alt: g,
        loading: b,
        style: E,
        onClick: x
      });
    };
    return D.renderVN = O, D;
  },
  render() {
    return this.renderVN();
  }
}), SA = Object.assign({}, Fi, {
  install(e) {
    e.component(Fi.name, Fi);
  }
});
Ht.use(SA);
Ce.component(Fi);
const ec = pt({
  name: "VxeImageGroup",
  props: {
    urlList: [Array, String],
    showPreview: {
      type: Boolean,
      default: () => oe().imageGroup.showPreview
    },
    imageStyle: Object,
    size: { type: String, default: () => oe().imageGroup.size || oe().size },
    showPrintButton: {
      type: Boolean,
      default: () => oe().imageGroup.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => oe().imageGroup.showDownloadButton
    }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), { computeSize: i } = dn(e), l = _(() => {
      const { urlList: w } = e;
      return w ? (r.isArray(w) ? w : [w]).map((v) => r.isString(v) ? {
        url: v,
        alt: ""
      } : {
        url: v.url,
        alt: v.alt
      }) : [];
    }), a = _(() => Object.assign({}, oe().imageGroup.imageStyle, e.imageStyle)), c = {
      computeSize: i
    }, m = {
      xID: s,
      props: e,
      context: t,
      getComputeMaps: () => c
    }, u = {
      dispatchEvent(w, v, D) {
        n(w, Zt(D, { $imageGroup: m }, v));
      }
    };
    Object.assign(m, u, {
      handleClickImgEvent(w, v) {
        const { showPreview: D, showPrintButton: S, showDownloadButton: x } = e, { url: h } = v, O = l.value;
        D && h && Pd({
          activeIndex: Math.max(0, r.findIndexOf(O, (g) => g.url === h)),
          urlList: O,
          showPrintButton: S,
          showDownloadButton: x
        }), u.dispatchEvent("click", { url: h, urlList: O }, w);
      }
    });
    const p = () => {
      const w = l.value, v = i.value, D = a.value;
      return o("div", {
        class: ["vxe-image-group", {
          [`size--${v}`]: v
        }]
      }, w ? w.map((S, x) => o(Fi, {
        key: x,
        src: S.url,
        alt: S.alt,
        width: D.width,
        height: D.height
      })) : []);
    };
    return m.renderVN = p, bn("$xeImageGroup", m), m;
  },
  render() {
    return this.renderVN();
  }
}), DA = Object.assign({}, ec, {
  install(e) {
    e.component(ec.name, ec);
  }
});
Ht.use(DA);
Ce.component(ec);
const OA = Object.assign(Ni, {
  install(e) {
    e.component(Ni.name, Ni), Ce.previewImage = Pd;
  }
});
Ht.use(OA);
Ce.component(Ni);
const TA = Object.assign(Wn, {
  install(e) {
    e.component(Wn.name, Wn);
  }
});
Ht.use(TA);
Ce.component(Wn);
const tc = pt({
  name: "VxeLayoutAside",
  props: {
    width: [String, Number],
    collapsed: Boolean,
    collapseWidth: [String, Number],
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => oe().layoutAside.size || oe().size
    }
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), { computeSize: a } = dn(e), c = Rt({}), m = {
      refElem: l
    }, u = _(() => {
      const { width: x, collapsed: h, collapseWidth: O } = e;
      if (h) {
        if (O)
          return cn(O);
      } else if (x)
        return cn(x);
      return "";
    }), d = {
      computeSize: a
    }, p = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => d
    };
    Object.assign(p, {
      dispatchEvent: (x, h, O) => {
        s(x, Zt(O, { $layoutAside: p }, h));
      }
    }, {});
    const S = () => {
      const { width: x, collapsed: h, loading: O, padding: g } = e, b = u.value, E = a.value, C = n.default;
      return o("aside", {
        ref: l,
        class: ["vxe-layout-aside", {
          [`size--${E}`]: E,
          "is--padding": g,
          "is--default-width": !x,
          "is--collapse": h,
          "is--loading": O
        }],
        style: b ? {
          width: b
        } : null
      }, [
        o("div", {
          class: "vxe-layout-aside--inner"
        }, C ? C({}) : []),
        /**
         * 加载中
         */
        o(us, {
          class: "vxe-list-view--loading",
          modelValue: O
        })
      ]);
    };
    return bn("$xeLayoutAside", p), p.renderVN = S, p;
  },
  render() {
    return this.renderVN();
  }
}), MA = Object.assign({}, tc, {
  install(e) {
    e.component(tc.name, tc);
  }
});
Ht.use(MA);
Ce.component(tc);
const nc = pt({
  name: "VxeLayoutBody",
  props: {
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => oe().layoutBody.size || oe().size
    }
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), { computeSize: a } = dn(e), c = Rt({}), m = {
      refElem: l
    }, u = {
      computeSize: a
    }, d = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => u
    };
    Object.assign(d, {
      dispatchEvent: (S, x, h) => {
        s(S, Zt(h, { $layoutBody: d }, x));
      }
    }, {});
    const D = () => {
      const { loading: S, padding: x } = e, h = a.value, O = n.default;
      return o("div", {
        ref: l,
        class: ["vxe-layout-body", {
          [`size--${h}`]: h,
          "is--loading": S,
          "is--padding": x
        }]
      }, [
        o("div", {
          class: "vxe-layout-body--inner"
        }, O ? O({}) : []),
        /**
         * 加载中
         */
        o(us, {
          class: "vxe-list-view--loading",
          modelValue: S
        })
      ]);
    };
    return d.renderVN = D, d;
  },
  render() {
    return this.renderVN();
  }
}), IA = Object.assign({}, nc, {
  install(e) {
    e.component(nc.name, nc);
  }
});
Ht.use(IA);
Ce.component(nc);
const oc = pt({
  name: "VxeLayoutContainer",
  props: {
    vertical: Boolean,
    size: {
      type: String,
      default: () => oe().layoutContainer.size || oe().size
    }
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), { computeSize: a } = dn(e), c = Rt({}), m = {
      refElem: l
    }, u = {
      computeSize: a
    }, d = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => u
    };
    Object.assign(d, {
      dispatchEvent: (S, x, h) => {
        s(S, Zt(h, { $layoutContainer: d }, x));
      }
    }, {});
    const D = () => {
      const { vertical: S } = e, x = a.value, h = n.default;
      return o("div", {
        ref: l,
        class: ["vxe-layout-container", {
          [`size--${x}`]: x,
          "is--vertical": S
        }]
      }, h ? h({}) : []);
    };
    return d.renderVN = D, d;
  },
  render() {
    return this.renderVN();
  }
}), VA = Object.assign({}, oc, {
  install(e) {
    e.component(oc.name, oc);
  }
});
Ht.use(VA);
Ce.component(oc);
const sc = pt({
  name: "VxeLayoutFooter",
  props: {
    fixed: Boolean,
    align: String
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), a = Rt({}), c = {
      refElem: l
    }, m = {}, u = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => m
    };
    Object.assign(u, {
      dispatchEvent: (D, S, x) => {
        s(D, Zt(x, { $layoutFooter: u }, S));
      }
    }, {});
    const v = () => {
      const { fixed: D, align: S } = e, x = n.default;
      return o("footer", {
        ref: l,
        class: ["vxe-layout-footer", S ? `align--${S}` : "", {
          "is--fixed": D
        }]
      }, x ? x({}) : []);
    };
    return u.renderVN = v, u;
  },
  render() {
    return this.renderVN();
  }
}), PA = Object.assign({}, sc, {
  install(e) {
    e.component(sc.name, sc);
  }
});
Ht.use(PA);
Ce.component(sc);
const rc = pt({
  name: "VxeLayoutHeader",
  props: {
    fixed: Boolean
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), a = Rt({}), c = {
      refElem: l
    }, m = {}, u = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => m
    };
    Object.assign(u, {
      dispatchEvent: (D, S, x) => {
        s(D, Zt(x, { $layoutHeader: u }, S));
      }
    }, {});
    const v = () => {
      const { fixed: D } = e, S = n.default;
      return o("header", {
        ref: l,
        class: ["vxe-layout-header", {
          "is--fixed": D
        }]
      }, S ? S({}) : []);
    };
    return u.renderVN = v, u;
  },
  render() {
    return this.renderVN();
  }
}), kA = Object.assign({}, rc, {
  install(e) {
    e.component(rc.name, rc);
  }
});
Ht.use(kA);
Ce.component(rc);
const lc = pt({
  name: "VxeLink",
  props: {
    href: String,
    target: String,
    status: String,
    title: [String, Number],
    icon: String,
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => oe().link.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    content: [String, Number],
    size: {
      type: String,
      default: () => oe().link.size || oe().size
    }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), { computePermissionInfo: a } = Qi(e), c = ke(), m = Rt({}), u = {
      refElem: c
    }, d = {}, p = {
      xID: i,
      props: e,
      context: t,
      reactData: m,
      getRefMaps: () => u,
      getComputeMaps: () => d
    }, w = (O, g, b) => {
      s(O, Zt(b, { $link: p }, g));
    }, v = {
      dispatchEvent: w
    }, D = {}, S = (O) => {
      w("click", {}, O);
    };
    Object.assign(p, v, D);
    const x = () => {
      const { icon: O, content: g } = e, b = n.default, E = n.icon, C = r.toValueString(g);
      return [
        E || O ? o("span", {
          class: "vxe-link--icon"
        }, E ? Nt(E({})) : [
          o("i", {
            class: O
          })
        ]) : Ve(),
        b || C ? o("span", {
          class: "vxe-link--content"
        }, b ? b({}) : C) : Ve()
      ];
    }, h = () => {
      const { status: O, target: g, href: b, title: E, underline: C, routerLink: V } = e, Q = a.value, Z = l.value;
      return Q.visible ? V ? o(qo("router-link"), {
        class: ["vxe-link", {
          [`size--${Z}`]: Z,
          [`theme--${O}`]: O,
          "is--underline": C
        }],
        title: E,
        target: g,
        to: V,
        onClick: S
      }, {
        default() {
          return x();
        }
      }) : o("a", {
        ref: c,
        class: ["vxe-link", {
          [`size--${Z}`]: Z,
          [`theme--${O}`]: O,
          "is--underline": C
        }],
        href: b,
        target: g,
        title: E,
        onClick: S
      }, x()) : Ve();
    };
    return p.renderVN = h, p;
  },
  render() {
    return this.renderVN();
  }
}), $A = Object.assign({}, lc, {
  install(e) {
    e.component(lc.name, lc);
  }
});
Ht.use($A);
Ce.component(lc);
const Bi = (e) => Object.assign({
  name: "",
  icon: "",
  type: "",
  classify: "",
  code: "",
  status: "",
  permissionCode: ""
}, e), RA = () => ({
  listView: {
    enabled: !0
  },
  ganttView: {
    enabled: !1
  },
  chartView: {
    enabled: !1
  },
  autoFoldFilter: !0,
  showCheckbox: "auto",
  showSeq: !0,
  showStatistics: !0,
  mobileDefaultView: "list",
  pcDefaultView: "list",
  actionButtonList: []
}), NA = pt({
  name: "ListDesignLayoutView",
  props: {},
  emits: [],
  setup() {
    const e = Ce.getComponent("VxeGrid"), t = mt("$xeListDesign", null);
    if (!t)
      return () => [];
    const { reactData: n } = t, s = ke(), i = ke([]), l = _(() => {
      const { searchFormItems: d } = n;
      return d.length ? d.concat([
        {
          field: "active",
          title: "",
          folding: !1,
          collapseNode: d.some((p) => p.folding),
          itemRender: {
            name: "VxeButtonGroup",
            options: [
              { content: "查询", icon: "vxe-icon-search", status: "primary", type: "submit" },
              { content: "重置", icon: "vxe-icon-repeat", type: "reset" }
            ]
          }
        }
      ]) : d;
    }), a = _(() => {
      const { formData: d, listTableColumns: p } = n, { showSeq: w, actionButtonList: v } = d, D = [];
      return w && D.push({
        type: "seq",
        field: "_seq",
        width: 70
      }), p.forEach((S) => {
        D.push({
          field: S.field,
          title: S.title,
          visible: S.visible,
          width: S.width
        });
      }), v && v.length && D.push({
        field: "_active",
        title: Pe("vxe.table.actionTitle"),
        fixed: "right",
        width: "auto",
        cellRender: {
          name: "VxeButtonGroup",
          options: []
        }
      }), D;
    }), c = ({ column: d, resizeWidth: p }) => {
      const { listTableColumns: w } = n, v = r.findTree(w, (D) => D.field === d.field, { children: "children" });
      if (v) {
        const { item: D } = v;
        D.width = p;
      }
    }, m = () => {
      const { listTableColumns: d } = n, p = [{}, {}];
      p.forEach((w) => {
        d.forEach((v) => {
          w[v.field] = "-";
        });
      }), i.value = p;
    }, u = ke(0);
    return lt(() => n.listTableColumns ? n.listTableColumns.length : -1, () => {
      u.value++;
    }), lt(() => n.listTableColumns, () => {
      u.value++;
    }), lt(u, () => {
      m();
    }), wn(() => {
      m();
    }), process.env.NODE_ENV === "development" && me(() => {
      e || Ao("vxe.error.reqComp", ["vxe-grid"]);
    }), () => {
      const { searchFormData: d, searchFormItems: p } = n, w = l.value, v = a.value;
      return o("div", {
        class: "vxe-list-design--preview"
      }, [
        o("div", {
          class: "vxe-list-design--preview-wrapper"
        }, [
          o("div", {
            class: "vxe-list-design--preview-search"
          }, [
            o("div", {
              class: "vxe-list-design--preview-title"
            }, Pe("vxe.listDesign.searchTitle")),
            p.length ? o(Nn, {
              data: d,
              items: w
            }) : o("div", {
              class: "vxe-list-design--field-configs-empty-data"
            }, [
              o("span", {}, Pe("vxe.listDesign.search.emptyText"))
            ])
          ]),
          o("div", {
            class: "vxe-list-design--preview-table"
          }, [
            o("div", {
              class: "vxe-list-design--preview-title"
            }, Pe("vxe.listDesign.listTitle")),
            e ? o(e, {
              ref: s,
              columns: v,
              data: i.value,
              showOverflow: !0,
              border: !0,
              columnConfig: {
                minWidth: "auto",
                resizable: !0
              },
              rowConfig: {
                isHover: !0
              },
              scrollX: {
                enabled: !1
              },
              scrollY: {
                enabled: !1
              },
              onResizableChange: c
            }) : Ve()
          ])
        ])
      ]);
    };
  }
}), vm = ke({}), FA = pt({
  name: "DefaultFieldSettingForm",
  props: {},
  emits: [],
  setup() {
    const e = mt("$xeListDesign", null);
    if (!e)
      return () => [];
    const { reactData: t } = e, n = ke(!1), s = ke(!1), i = (u) => {
      u.visible = !u.visible, t.listTableColumns = t.listTableColumns.slice(0);
    }, l = (u) => {
      const { searchFormItems: d } = t;
      t.searchFormItems = d.filter((p) => p.field !== u.field);
    }, a = () => {
      const { listTableColumns: u, searchFormItems: d } = t, p = vm.value, w = [];
      u.forEach((g) => {
        const { cellRender: b } = g;
        if (b) {
          const E = d.find((Q) => Q.field === g.field), C = b.name || "";
          let V = p[C];
          if (!V) {
            const Q = Cn.get(C);
            if (Q) {
              const Z = Q.createFormDesignWidgetConfig;
              Z && (V = Z({ name: C, $formDesign: null }) || {}, p[C] = V);
            }
          }
          V.query && w.push(Object.assign(Object.assign({}, g), { checked: !!E, isHalf: !1, folding: E ? !!E.folding : !1 }));
        }
      }), vm.value = Object.assign({}, p);
      const v = ke(w), D = () => {
        const g = v.value;
        n.value = g.every((b) => b.checked), s.value = !n.value && g.some((b) => b.checked || b.isHalf);
      }, S = (g) => {
        const b = v.value, E = r.findTree(b, (C) => C === g);
        if (E && E.parent) {
          const { parent: C } = E;
          C.children && C.children.length && (C.checked = C.children.every((V) => V.checked), C.isHalf = !C.checked && C.children.some((V) => V.checked || V.isHalf), S(C));
        }
      }, x = (g) => {
        const b = !g.checked;
        r.eachTree([g], (E) => {
          E.checked = b, E.isHalf = !1;
        }), S(g), D();
      }, h = () => {
        const g = v.value, b = !n.value;
        r.eachTree(g, (E) => {
          E.checked = b, E.isHalf = !1;
        }), n.value = b, D();
      }, O = () => {
        const g = v.value, b = [];
        g.forEach((E) => {
          E.checked && b.push({
            field: E.field,
            title: E.title,
            folding: E.folding,
            itemRender: Object.assign({}, E.cellRender)
          });
        }), e.setSearchItems(b);
      };
      Ce.modal.open({
        title: Pe("vxe.listDesign.search.editPopupTitle"),
        width: 680,
        height: 500,
        showFooter: !0,
        escClosable: !0,
        showCancelButton: !0,
        showConfirmButton: !0,
        confirmButtonText: Pe("vxe.listDesign.searchPopup.saveBtn"),
        showZoom: !0,
        resize: !0,
        onConfirm: O,
        slots: {
          default() {
            const g = n.value, b = s.value, E = v.value;
            return o("div", {
              class: "vxe-list-design--field-search-popup"
            }, [
              o("table", {}, [
                o("colgroup", {}, [
                  o("col", {
                    style: {
                      width: "80px"
                    }
                  }),
                  o("col")
                  // h('col', {
                  //   style: {
                  //     width: '140px'
                  //   }
                  // })
                ]),
                o("thead", {}, [
                  o("th", {}, [
                    o("div", {
                      class: ["vxe-list-design--field-search-checkbox-option", {
                        "is--checked": g,
                        "is--indeterminate": b
                      }],
                      title: Pe("vxe.table.allTitle"),
                      onClick: h
                    }, [
                      o("span", {
                        class: ["vxe-checkbox--icon", b ? ht().CHECKBOX_INDETERMINATE : g ? ht().CHECKBOX_CHECKED : ht().CHECKBOX_UNCHECKED]
                      }),
                      o("span", {
                        class: "vxe-checkbox--label"
                      }, Pe("vxe.toolbar.customAll"))
                    ])
                  ]),
                  o("th", {}, Pe("vxe.listDesign.searchPopup.colTitle"))
                  // h('th', {}, '展开/折叠')
                ]),
                o("tbody", {}, E.map((C) => {
                  const V = C.checked, Q = C.isHalf;
                  return o("tr", {}, [
                    o("td", {
                      class: "vxe-list-design--field-search-option-item col--visible"
                    }, [
                      o("div", {
                        class: ["vxe-list-design--field-search-checkbox-option", {
                          "is--checked": V,
                          "is--indeterminate": Q
                        }],
                        title: Pe("vxe.custom.setting.colVisible"),
                        onClick: () => {
                          x(C);
                        }
                      }, [
                        o("span", {
                          class: ["vxe-checkbox--icon", Q ? ht().CHECKBOX_INDETERMINATE : V ? ht().CHECKBOX_CHECKED : ht().CHECKBOX_UNCHECKED]
                        })
                      ])
                    ]),
                    o("td", {
                      class: "vxe-list-design--field-search-option-item"
                    }, `${C.title || ""}`)
                    // h('td', {}, [
                    //   h(VxeRadioGroupComponent, {
                    //     modelValue: item.folding,
                    //     type: 'button',
                    //     options: foldOptions.value,
                    //     size: 'mini',
                    //     'onUpdate:modelValue' (val) {
                    //       item.folding = val
                    //     }
                    //   })
                    // ])
                  ]);
                }))
              ])
            ]);
          }
        }
      });
    }, c = (u) => {
      const { children: d } = u;
      return d && d.length ? o("div", {
        class: "vxe-list-design--field-option-inner"
      }, [
        o("div", {
          class: "vxe-list-design--field-sub-option",
          onClick() {
            i(u);
          }
        }, d.map((p) => {
          const { title: w, visible: v } = p;
          return o("div", {
            class: ["vxe-list-design--field-checkbox-option", {
              "is--checked": v
            }],
            onClick() {
              i(p);
            }
          }, [
            o("span", {
              class: ["vxe-checkbox--icon", v ? ht().CHECKBOX_CHECKED : ht().CHECKBOX_UNCHECKED]
            }),
            o("span", {
              class: "vxe-checkbox--label"
            }, `${w}`)
          ]);
        }))
      ]) : Ve();
    }, m = () => {
      const { listTableColumns: u } = t;
      return u.map((d) => {
        const { title: p, visible: w } = d;
        return o("div", {
          class: "vxe-list-design--field-option"
        }, [
          o("div", {
            class: "vxe-list-design--field-option-inner"
          }, [
            o("div", {
              class: ["vxe-list-design--field-checkbox-option", {
                "is--checked": w
              }],
              onClick() {
                i(d);
              }
            }, [
              o("span", {
                class: ["vxe-checkbox--icon", w ? ht().CHECKBOX_CHECKED : ht().CHECKBOX_UNCHECKED]
              }),
              o("span", {
                class: "vxe-checkbox--label"
              }, `${p}`)
            ])
          ]),
          c(d)
        ]);
      });
    };
    return () => o(Nn, {
      span: 24,
      vertical: !0,
      titleBold: !0
    }, {
      default() {
        return [
          o(kt, {
            title: Pe("vxe.listDesign.searchField")
          }, {
            extra() {
              return o(Vn, {
                mode: "text",
                status: "primary",
                icon: ht().FORM_DESIGN_PROPS_EDIT,
                content: Pe("vxe.listDesign.search.addBtn"),
                onClick: a
              });
            },
            default() {
              const { searchFormItems: u } = t;
              return [
                u.length ? o("div", {
                  class: "vxe-list-design--search-item-wrapper"
                }, [
                  o("div", {
                    class: "vxe-list-design--search-item-list"
                  }, u.map((d) => o("div", {
                    key: d.field,
                    class: "vxe-list-design--search-item"
                  }, [
                    o("div", {
                      class: "vxe-list-design--search-item-title"
                    }, `${d.title || ""}`),
                    o("div", {
                      class: "vxe-list-design--search-item-btn"
                    }, [
                      o(Vn, {
                        icon: ht().LIST_DESIGN_LIST_SETTING_SEARCH_DELETE,
                        mode: "text",
                        status: "error",
                        onClick() {
                          l(d);
                        }
                      })
                    ])
                  ])))
                ]) : o("div", {
                  class: "vxe-list-design--field-configs-empty-data"
                }, [
                  o("span", {}, Pe("vxe.listDesign.search.emptyText"))
                ])
              ];
            }
          }),
          o(kt, {
            title: Pe("vxe.listDesign.listField")
          }, {
            default() {
              return m();
            }
          })
        ];
      }
    });
  }
}), LA = pt({
  name: "DefaultListSettingTabComponent",
  props: {},
  emits: [],
  setup() {
    const e = mt("$xeListDesign", null);
    if (!e)
      return () => [];
    const { props: t, reactData: n } = e, s = [], i = [];
    Cn.forEach((p, w) => {
      const { createListDesignSettingActionButtonConfig: v } = p;
      if (v) {
        const D = { name: w }, S = Object.assign(Bi({ code: w }), v(D));
        S.type === "custom" ? i.push(S) : s.push(S);
      }
    });
    const l = ke([
      { label: "列表视图", value: "list", isExpand: !1 }
    ]), a = ke([
      { label: "显示", value: !0 },
      { label: "隐藏", value: !1 }
    ]), c = ke([
      { label: "默认", value: "auto" },
      { label: "允许", value: !0 },
      { label: "不允许", value: !1 }
    ]), m = _(() => {
      const { formData: p } = n;
      return [p.listView.enabled, p.ganttView.enabled, p.chartView.enabled].filter((w) => w).length <= 1;
    }), u = (p) => {
      const { formData: w } = n, { actionCodes: v } = t;
      let D = w.actionButtonList;
      D || (D = []);
      const S = Rt(Bi(p)), x = s.filter((E) => v && v.length && !v.some((C) => r.isString(C) ? E.code === C : C.code === E.code) ? !1 : !D.some((C) => C.code === E.code)), h = i.filter((E) => !D.some((C) => C.code === E.code)), O = [];
      x.length && (S.type || (S.type = ""), O.push({ value: "", label: "系统按钮" })), h.length && (S.type || (S.type = "custom"), O.push({ value: "custom", label: "自定义按钮" }));
      const g = _(() => x.map((E) => {
        const C = E.name;
        return {
          label: r.toValueString(r.isFunction(C) ? C({ name: E.code || "" }) : C),
          value: E.code
        };
      })), b = ke(O);
      Ce.modal.open({
        title: "添加按钮",
        width: 600,
        height: 400,
        showFooter: !0,
        showCancelButton: !0,
        showConfirmButton: !0,
        confirmButtonText: "保存",
        onConfirm() {
          S.type, D.push(S), w.actionButtonList = [...D];
        },
        slots: {
          default() {
            return o(Nn, {
              vertical: !0,
              titleBold: !0
            }, {
              default() {
                return [
                  o(kt, {
                    title: "按钮类型",
                    span: 24
                  }, {
                    default() {
                      return o(vs, {
                        modelValue: S.type,
                        options: b.value,
                        "onUpdate:modelValue"(E) {
                          S.type = E;
                        }
                      });
                    }
                  }),
                  o(kt, {
                    title: "选择系统按钮",
                    span: 24
                  }, {
                    default() {
                      return o(vs, {
                        modelValue: S.code,
                        options: g.value,
                        "onUpdate:modelValue"(E) {
                          S.code = E;
                        }
                      });
                    }
                  })
                  // h(VxeFormItemComponent, {
                  //   title: '按钮位置',
                  //   span: 24
                  // }, {
                  //   default () {
                  //     return h(VxeSelectComponent, {
                  //       modelValue: activeBtnItem.classify,
                  //       options: refBtnClassifyOptions.value,
                  //       'onUpdate:modelValue' (val) {
                  //         activeBtnItem.classify = val
                  //       }
                  //     })
                  //   }
                  // })
                ];
              }
            });
          }
        }
      });
    }, d = () => o(kt, {
      title: "功能按钮"
    }, {
      extra() {
        return o(Vn, {
          mode: "text",
          status: "primary",
          icon: ht().FORM_DESIGN_PROPS_ADD,
          content: "新增",
          onClick() {
            u();
          }
        });
      },
      default() {
        const { formData: p } = n, w = p.actionButtonList;
        return w && w.length ? o("div", {
          class: "vxe-list-design--field-configs-wrapper"
        }, w.map((v) => {
          let D = "", S = "";
          if (v.type === "custom")
            D = v.icon, S = v.name;
          else {
            const x = s.find((h) => h.code === v.code);
            if (x) {
              const h = x.name;
              D = x.icon || "", S = r.toValueString(r.isFunction(h) ? h({ name: x.code || "" }) : h);
            }
          }
          return o("div", {
            class: "vxe-list-design--field-configs-item"
          }, [
            D ? o("div", {
              class: "vxe-list-design--field-configs-item-icon"
            }, [
              o("i", {
                class: D
              })
            ]) : Ve(),
            o("div", {
              class: "vxe-list-design--field-configs-item-title"
            }, `${S || ""}`),
            o("div", {
              class: "vxe-list-design--field-configs-item-btn"
            }, [
              o(Vn, {
                icon: ht().LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE,
                mode: "text",
                status: "error",
                onClick() {
                  p.actionButtonList = w.filter((x) => x !== v);
                }
              })
            ])
          ]);
        })) : o("div", {
          class: "vxe-list-design--field-configs-empty-data"
        }, [
          o("span", {}, "无操作按钮")
        ]);
      }
    });
    return () => {
      const { showPc: p, showMobile: w } = t, { formData: v } = n;
      return o(Nn, {
        span: 24,
        vertical: !0,
        titleBold: !0
      }, {
        default() {
          return [
            o(kt, {
              title: "视图配置"
            }, {
              default() {
                return o("div", {
                  class: "vxe-form-design--widget-form-item-render-view"
                }, l.value.map((D) => o("div", {
                  key: D.value,
                  class: "vxe-form-design--widget-form-item-render-view-item"
                }, [
                  o(ao, {
                    modelValue: v.listView.enabled,
                    disabled: m.value,
                    "onUpdate:modelValue"(S) {
                      v.listView.enabled = S;
                    }
                  }),
                  o(Ps, {
                    content: D.label,
                    icon: "vxe-icon-table"
                  })
                ])));
              }
            }),
            o(kt, {
              title: "默认视图"
            }, {
              default() {
                return [
                  o("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    p ? o("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      o("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        o(Ps, {
                          icon: ht().FORM_DESIGN_PROPS_PC,
                          content: Pe("vxe.formDesign.widgetProp.displaySetting.pc")
                        })
                      ]),
                      o(vs, {
                        modelValue: v.pcDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: l.value,
                        "onUpdate:modelValue"(D) {
                          v.pcDefaultView = D;
                        }
                      })
                    ]) : Ve(),
                    w ? o("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      o("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        o(Ps, {
                          icon: ht().FORM_DESIGN_PROPS_MOBILE,
                          content: Pe("vxe.formDesign.widgetProp.displaySetting.mobile")
                        })
                      ]),
                      o(vs, {
                        modelValue: v.mobileDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: l.value,
                        "onUpdate:modelValue"(D) {
                          v.mobileDefaultView = D;
                        }
                      })
                    ]) : Ve()
                  ])
                ];
              }
            }),
            // h(VxeFormItemComponent, {
            //   title: '查询配置'
            // }, {
            //   default () {
            //     const { formData } = listDesignReactData
            //     return [
            //       h('div', {
            //         class: 'vxe-list-design--widget-form-item-prop-list'
            //       }, [
            //         h('span', {}, '折叠字段'),
            //         h(VxeRadioGroupComponent, {
            //           modelValue: formData.autoFoldFilter,
            //           options: refFoldOpts.value,
            //           'onUpdate:modelValue' (val) {
            //             formData.autoFoldFilter = val
            //           }
            //         })
            //       ])
            //     ]
            //   }
            // }),
            o(kt, {
              title: "列配置"
            }, {
              default() {
                const { formData: D } = n;
                return [
                  o("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, "显示序号"),
                    o(Jo, {
                      modelValue: D.showSeq,
                      options: a.value,
                      "onUpdate:modelValue"(S) {
                        D.showSeq = S;
                      }
                    })
                  ]),
                  o("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    o("span", {}, "表尾统计"),
                    o(Jo, {
                      modelValue: D.showStatistics,
                      options: a.value,
                      "onUpdate:modelValue"(S) {
                        D.showStatistics = S;
                      }
                    })
                  ])
                ];
              }
            }),
            o(kt, {
              title: "批量操作"
            }, {
              default() {
                const { formData: D } = n;
                return o(Jo, {
                  modelValue: D.showCheckbox,
                  options: c.value,
                  "onUpdate:modelValue"(S) {
                    D.showCheckbox = S;
                  }
                });
              }
            }),
            s.length || i.length ? d() : Ve()
          ];
        }
      });
    };
  }
}), AA = pt({
  name: "ListDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const e = ke(1);
    return () => o("div", {
      class: "vxe-list-design--setting"
    }, [
      o("div", {
        class: "vxe-list-design--setting-form"
      }, [
        o(ol, {
          modelValue: e.value,
          titleWidth: "50%",
          titleAlign: "center",
          padding: !0,
          class: "vxe-list-design--setting-form-tabs",
          "onUpdate:modelValue"(t) {
            e.value = t;
          }
        }, {
          default() {
            return [
              o(qs, {
                title: Pe("vxe.listDesign.fieldSettingTab"),
                icon: ht().LIST_DESIGN_FIELD_SETTING,
                name: 1
              }, {
                default() {
                  return o(FA);
                }
              }),
              o(qs, {
                title: Pe("vxe.listDesign.listSettingTab"),
                icon: ht().LIST_DESIGN_LIST_SETTING,
                name: 2
              }, {
                default() {
                  return o(LA);
                }
              })
            ];
          }
        })
      ])
    ]);
  }
}), ic = pt({
  name: "VxeListDesign",
  props: {
    size: {
      type: String,
      default: () => oe().listDesign.size || oe().size
    },
    height: {
      type: [String, Number],
      default: () => oe().listDesign.height
    },
    config: Object,
    showPc: {
      type: Boolean,
      default: () => oe().listDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => oe().listDesign.showMobile
    },
    actionCodes: Array,
    formRender: Object
  },
  emits: [],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), l = ke(), { computeSize: a } = dn(e), c = Rt({
      formData: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: []
    }), m = {
      refElem: l
    }, u = {
      computeSize: a
    }, d = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => u
    }, p = [];
    Cn.forEach((K, L) => {
      const { createListDesignSettingActionButtonConfig: ye } = K;
      if (ye) {
        const se = { name: L }, P = Object.assign(Bi({ code: L }), ye(se));
        P.type === "custom" || p.push(P);
      }
    });
    const w = (K) => ({
      title: K.title,
      field: K.field,
      visible: !K.hidden,
      width: "",
      cellRender: {
        name: K.name,
        props: K.options
      }
    }), v = (K) => {
      const L = [];
      if (K) {
        const { widgetData: ye } = K;
        ye && ye.forEach((se) => {
          const { name: P } = se;
          P && (P === "row" ? se.children.forEach((M) => {
            M.name && L.push(w(M));
          }) : P === "subtable" || L.push(w(se)));
        });
      }
      return L;
    }, D = (K) => {
      if (K) {
        const L = {};
        return {
          items: K.map((se) => (L[se.field] = null, {
            field: se.field,
            title: se.title,
            folding: se.folding,
            itemRender: se.itemRender
          })),
          data: L
        };
      }
      return { items: [], data: {} };
    }, S = (K) => K ? K.map((L) => ({
      field: L.field,
      title: L.title,
      visible: !!L.visible,
      width: L.width,
      cellRender: r.clone(L.cellRender)
    })) : [], x = (K) => {
      const { formConfig: L, searchItems: ye, listColumns: se } = K;
      return L && O(L), ye && b(ye), se && (c.listTableColumns = h(se)), me();
    }, h = (K) => S(K), O = (K) => (c.formData = Object.assign({}, V(), K), me()), g = () => c.searchFormItems, b = (K) => {
      const { data: L, items: ye } = D(K);
      return c.searchFormData = L, c.searchFormItems = ye, me();
    }, E = () => c.listTableColumns, C = (K) => (c.listTableColumns = h(K), me()), V = () => {
      const { actionCodes: K, formRender: L } = e;
      let ye = RA();
      if (K && K.length && (!ye.actionButtonList || !ye.actionButtonList.length)) {
        const se = [];
        K.forEach((P) => {
          if (r.isObject(P) && P.default) {
            const M = p.find((I) => I.code === P.code);
            M && se.push(Bi({
              type: M.type,
              code: M.code
            }));
          }
        }), ye.actionButtonList = se;
      }
      if (L && L.name) {
        const se = Cn.get(L.name), P = se ? se.createListDesignSettingFormConfig : null, M = { name: L.name };
        ye = (P ? P(M) : {}) || {};
      }
      return ye;
    }, Q = () => {
      c.formData = V();
    }, Z = () => (x({
      searchItems: [],
      listColumns: []
    }), Q(), me());
    Object.assign(d, {
      dispatchEvent(K, L, ye) {
        n(K, Zt(ye, { $listDesign: d }, L));
      },
      loadFormDesignConfig(K) {
        const { listTableColumns: L } = c, ye = {};
        r.eachTree(L, (P) => {
          ye[P.field] = P;
        }, { children: "children" });
        const se = v(K);
        return r.eachTree(se, (P) => {
          const M = ye[P.field];
          M && (M.width && (P.width = M.width), P.visible = M.visible);
        }, { children: "children" }), c.listTableColumns = se, me();
      },
      reloadFormDesignConfig(K) {
        return c.listTableColumns = v(K), me();
      },
      getSearchItems: g,
      setSearchItems: b,
      getListColumns: E,
      setListColumns: C,
      getConfig() {
        return {
          formConfig: c.formData,
          searchItems: g(),
          listColumns: E()
        };
      },
      loadConfig: x,
      reloadConfig(K) {
        return Z(), x(K);
      },
      clearConfig: Z
    }, {});
    const Y = () => {
      const { height: K } = e, L = a.value, ye = s.header;
      return o("div", {
        ref: l,
        class: ["vxe-list-design", {
          [`size--${L}`]: L
        }],
        style: K ? {
          height: cn(K)
        } : null
      }, [
        o("div", {
          class: "vxe-list-design--header"
        }, ye ? ye({}) : []),
        o("div", {
          class: "vxe-list-design--body"
        }, [
          o(NA),
          o(AA)
        ])
      ]);
    };
    return bn("$xeListDesign", d), lt(() => e.config, (K) => {
      x(K || {});
    }), Q(), e.config && x(e.config), d.renderVN = Y, d;
  },
  render() {
    return this.renderVN();
  }
});
Cn.mixin({
  // ActionButtonUpdate: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-edit',
  //       status: 'primary'
  //     }
  //   }
  // },
  // ActionButtonDelete: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-delete',
  //       status: 'error'
  //     }
  //   }
  // }
});
const BA = Object.assign({}, ic, {
  install(e) {
    e.component(ic.name, ic);
  }
}), _A = {};
Ht.use(BA);
Ce.component(ic);
Ce.listDesignHandle = _A;
const ac = pt({
  name: "VxeListView",
  props: {
    size: {
      type: String,
      default: () => oe().listView.size || oe().size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => oe().listView.height
    },
    loading: Boolean,
    formData: Object,
    actionButtons: Array,
    gridOptions: Object,
    gridEvents: Object,
    viewRender: Object
  },
  emits: [
    "cell-action",
    "update:formData",
    "update:actionButtons"
  ],
  setup(e, t) {
    const n = Ce.getComponent("VxeGrid"), { emit: s, slots: i } = t, l = r.uniqueId(), a = ke(), c = ke(), { computeSize: m } = dn(e), u = Rt({
      formConfig: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: [],
      tableColumns: [],
      footerData: [
        {}
        // 默认一行合计
      ]
    }), d = _(() => {
      const { gridOptions: se } = e, { formConfig: P, tableColumns: M, searchFormData: I, searchFormItems: B, footerData: H } = u, { showStatistics: ce } = P, A = se || {}, j = Object.assign({
        minWidth: 120
      }, A.columnConfig);
      let fe;
      return A.proxyConfig && (fe = Object.assign({ autoLoad: !1 }, A.proxyConfig)), Object.assign({}, A, {
        columns: M,
        columnConfig: j,
        showFooter: ce,
        footerData: ce ? H : null,
        formConfig: {
          data: I,
          items: B
        },
        proxyConfig: fe
      });
    }), p = _(() => {
      const { gridEvents: se } = e, P = {};
      return r.each(se, (M, I) => {
        P[r.camelCase(`on-${I}`)] = M;
      }), P;
    }), w = {
      refElem: a,
      refGrid: c
    }, v = {
      computeSize: m
    }, D = {
      xID: l,
      props: e,
      context: t,
      reactData: u,
      getRefMaps: () => w,
      getComputeMaps: () => v
    }, S = [];
    Cn.forEach((se, P) => {
      const { createListDesignSettingActionButtonConfig: M } = se;
      if (M) {
        const I = { name: P }, B = Object.assign(Bi({ code: P }), M(I));
        B.type === "custom" || S.push(B);
      }
    });
    const x = (se) => {
      if (se && se.length) {
        const P = {}, M = se.map((I) => (P[I.field] = null, {
          field: I.field,
          title: I.title,
          folding: I.folding,
          itemRender: I.itemRender
        }));
        return M.push({
          field: "active",
          title: "",
          folding: !1,
          collapseNode: se.some((I) => I.folding),
          itemRender: {
            name: "VxeButtonGroup",
            options: [
              { content: "查询", icon: "vxe-icon-search", status: "primary", type: "submit" },
              { content: "重置", icon: "vxe-icon-repeat", type: "reset" }
            ]
          }
        }), {
          items: M,
          data: P
        };
      }
      return { items: [], data: {} };
    }, h = (se) => se ? se.map((P) => ({
      field: P.field,
      title: P.title,
      visible: !!P.visible,
      width: P.width,
      cellRender: r.clone(P.cellRender)
    })) : [], O = () => (s("update:formData", {}), Object.assign(u, {
      formConfig: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: [],
      tableColumns: [],
      footerData: [
        {}
        // 默认一行合计
      ]
    }), me()), g = (se) => {
      if (se) {
        const { formConfig: P, searchItems: M, listColumns: I } = se;
        u.formConfig = P || {}, ue(M || []), G(I || []);
      }
      return me();
    }, b = (se) => x(se || []), E = (se, P) => {
      const M = Object.assign({}, P), { showSeq: I, actionButtonList: B } = M, H = [], ce = {}, A = i.cellAction, j = i.footerCell;
      if (I && H.push({
        type: "seq",
        field: "_seq",
        fixed: "left",
        width: 70
      }), h(se || []).forEach((fe) => {
        const pe = Object.assign({}, fe);
        M.showStatistics && j && (pe.slots = {
          footer: (ne) => j(Object.assign({}, ne))
        }), pe.field && (ce[pe.field] = null), H.push(pe);
      }), B && B.length) {
        const fe = {
          field: "_active",
          title: Pe("vxe.table.actionTitle"),
          fixed: "right",
          width: "auto"
        }, pe = [];
        B.forEach((ne) => {
          if (ne.type === "custom")
            return {
              content: ne.name,
              name: ne.code,
              icon: ne.icon
            };
          const $ = S.find((Ie) => Ie.code === ne.code);
          let J = ne.name, ge = ne.icon, Oe = ne.status, Se = ne.permissionCode, de = ne.classify;
          if ($) {
            const Ie = $.name;
            ge = $.icon || "", Oe = $.status || "", Se = $.permissionCode || "", de = $.classify || "", J = r.toValueString(r.isFunction(Ie) ? Ie({ name: $.code || "" }) : Ie);
          }
          (!de || de === "cellButton") && pe.push({
            content: J,
            name: ne.code,
            icon: ge,
            status: Oe,
            permissionCode: Se
          });
        }), A ? fe.slots = {
          default(ne) {
            return A(Object.assign(Object.assign({}, ne), { buttons: pe }));
          }
        } : fe.cellRender = {
          name: "VxeButtonGroup",
          props: {
            mode: "text"
          },
          options: pe,
          events: {
            click(ne, $) {
              const { option: J } = $;
              Y("cell-action", Object.assign(Object.assign({}, ne), { button: J }), $.$event);
            }
          }
        }, H.push(fe);
      }
      return { rowRecord: ce, columns: H, actionButtons: B };
    }, C = (se) => {
      const { formConfig: P, searchItems: M, listColumns: I } = se || {}, { columns: B, rowRecord: H, actionButtons: ce } = E(I || [], P || u.formConfig), { data: A, items: j } = b(M || []);
      return {
        formData: A,
        formItems: j,
        tableColumns: B,
        tableRecord: H,
        actionButtons: ce
      };
    }, V = (se) => {
      if (r.isArray(se)) {
        const { rowRecord: P } = E(se, u.formConfig);
        return P;
      }
      if (se) {
        const { formConfig: P, listColumns: M } = se, { rowRecord: I } = E(M || [], P || u.formConfig);
        return I;
      }
      return {};
    }, Q = () => {
      const { searchFormData: se, searchFormItems: P } = u, M = [], I = {
        items: M,
        type: "and"
      };
      return c.value && P.forEach((H) => {
        const { field: ce } = H, A = se[ce];
        if (A) {
          const j = [];
          j.push({
            field: ce,
            value: A,
            match: "exact",
            type: r.isArray(A) ? "array" : ""
          }), M.push({
            condition: j,
            type: "and"
          });
        }
      }), I;
    }, Z = (se, ...P) => {
      const M = c.value;
      return M ? M.commitProxy(se, ...P) : Promise.resolve();
    }, G = (se) => {
      const { formConfig: P } = u, M = se || [], { columns: I, actionButtons: B } = E(M, P);
      u.listTableColumns = M, u.tableColumns = I, s("update:actionButtons", B), me(() => {
        d.value.proxyConfig && Z("reload");
      });
    }, ue = (se) => {
      const { data: P, items: M } = x(se);
      return u.searchFormData = P, u.searchFormItems = M, s("update:formData", P), me();
    }, Y = (se, P, M) => {
      s(se, Zt(M, { $listView: D }, P));
    };
    Object.assign(D, {
      dispatchEvent: Y,
      clearConfig: O,
      loadConfig: g,
      parseConfig: C,
      getTableRecord: V,
      getQueryFilter: Q,
      commitProxy: Z
    }, {});
    const ye = () => {
      const { height: se, loading: P } = e, M = m.value, I = i.grid, B = d.value, H = p.value;
      return o("div", {
        ref: a,
        class: ["vxe-list-view", {
          [`size--${M}`]: M,
          "is--loading": P
        }],
        style: se ? {
          height: cn(se)
        } : null
      }, [
        o("div", {
          class: "vxe-list-view--body"
        }, [
          I ? o("div", {
            class: "vxe-list-view--grid-wrapper"
          }, Nt(I({ $listView: D }))) : n ? o(n, Object.assign({}, B, H, {
            ref: c
          }), Object.assign({}, i, {
            default: void 0
          })) : Ve()
        ]),
        /**
         * 加载中
         */
        o(us, {
          class: "vxe-list-view--loading",
          modelValue: P
        })
      ]);
    };
    return lt(() => e.config, (se) => {
      g(se || {});
    }), e.config && g(e.config), bn("$xeListView", D), process.env.NODE_ENV === "development" && me(() => {
      n || Ao("vxe.error.reqComp", ["vxe-grid"]);
    }), D.renderVN = ye, D;
  },
  render() {
    return this.renderVN();
  }
}), WA = Object.assign(ac, {
  install: function(e) {
    e.component(ac.name, ac);
  }
});
Ht.use(WA);
Ce.component(ac);
const cc = pt({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: { type: String, default: () => oe().list.size || oe().size },
    autoResize: { type: Boolean, default: () => oe().list.autoResize },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = Rt({
      scrollYLoad: !1,
      bodyHeight: 0,
      topSpaceHeight: 0,
      items: []
    }), c = {
      resizeObserver: void 0,
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    }, m = ke(), u = ke(), d = ke(), p = {
      refElem: m
    }, w = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      internalData: c,
      getRefMaps: () => p
    }, v = _(() => Object.assign({}, oe().list.scrollY, e.scrollY)), D = _(() => {
      const { height: L, maxHeight: ye } = e, se = {};
      return L ? se.height = `${isNaN(L) ? L : `${L}px`}` : ye && (se.height = "auto", se.maxHeight = `${isNaN(ye) ? ye : `${ye}px`}`), se;
    }), S = (L, ye, se) => {
      s(L, Zt(se, { $list: w }, ye));
    }, x = () => {
      const { scrollYLoad: L } = a, { scrollYStore: ye, fullData: se } = c;
      a.bodyHeight = L ? se.length * ye.rowHeight : 0, a.topSpaceHeight = L ? Math.max(ye.startIndex * ye.rowHeight, 0) : 0;
    }, h = () => {
      const { scrollYLoad: L } = a, { fullData: ye, scrollYStore: se } = c;
      return a.items = L ? ye.slice(se.startIndex, se.endIndex) : ye.slice(0), me();
    }, O = () => {
      h(), x();
    }, g = () => me().then(() => {
      const { scrollYLoad: L } = a, { scrollYStore: ye } = c, se = d.value, P = v.value;
      let M = 0, I;
      if (se && (P.sItem && (I = se.querySelector(P.sItem)), I || (I = se.children[0])), I && (M = I.offsetHeight), M = Math.max(20, M), ye.rowHeight = M, L) {
        const B = u.value, H = Math.max(8, Math.ceil(B.clientHeight / M)), ce = P.oSize ? r.toNumber(P.oSize) : nL.edge ? 10 : 0;
        ye.offsetSize = ce, ye.visibleSize = H, ye.endIndex = Math.max(ye.startIndex, H + ce, ye.endIndex), O();
      } else
        x();
    }), b = () => {
      const L = u.value;
      return L && (L.scrollTop = 0), me();
    }, E = (L, ye) => {
      const se = u.value;
      return r.isNumber(L) && (se.scrollLeft = L), r.isNumber(ye) && (se.scrollTop = ye), a.scrollYLoad ? new Promise((P) => {
        setTimeout(() => {
          me(() => {
            P();
          });
        }, 50);
      }) : me();
    }, C = () => {
      const { lastScrollLeft: L, lastScrollTop: ye } = c;
      return b().then(() => {
        if (L || ye)
          return c.lastScrollLeft = 0, c.lastScrollTop = 0, E(L, ye);
      });
    }, V = () => {
      const L = m.value;
      return L.clientWidth && L.clientHeight ? g() : Promise.resolve();
    }, Q = (L) => {
      const { scrollYStore: ye } = c, { startIndex: se, endIndex: P, visibleSize: M, offsetSize: I, rowHeight: B } = ye, ce = L.target.scrollTop, A = Math.floor(ce / B), j = Math.max(0, A - 1 - I), fe = A + M + I;
      (A <= se || A >= P - M - 1) && (se !== j || P !== fe) && (ye.startIndex = j, ye.endIndex = fe, O());
    }, Z = (L) => {
      const ye = L.target, se = ye.scrollTop, P = ye.scrollLeft, M = P !== c.lastScrollLeft, I = se !== c.lastScrollTop;
      c.lastScrollTop = se, c.lastScrollLeft = P, a.scrollYLoad && Q(L), S("scroll", { scrollLeft: P, scrollTop: se, isX: M, isY: I }, L);
    }, G = (L) => {
      const { scrollYStore: ye } = c, se = v.value, P = L || [];
      return Object.assign(ye, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      }), c.fullData = P, a.scrollYLoad = !!se.enabled && se.gt > -1 && (se.gt === 0 || se.gt <= P.length), h(), g().then(() => {
        C();
      });
    };
    Object.assign(w, {
      dispatchEvent: S,
      loadData: G,
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(L) {
        return b(), G(L);
      },
      recalculate: V,
      scrollTo: E,
      refreshScroll: C,
      clearScroll: b
    });
    const Y = ke(0);
    lt(() => e.data ? e.data.length : -1, () => {
      Y.value++;
    }), lt(() => e.data, () => {
      Y.value++;
    }), lt(Y, () => {
      G(e.data || []);
    }), lt(() => e.syncResize, (L) => {
      L && (V(), me(() => setTimeout(() => V())));
    }), Cm(() => {
      V().then(() => C());
    }), me(() => {
      if (ut.on(w, "resize", () => {
        V();
      }), e.autoResize) {
        const L = m.value, ye = Sh.create(() => V());
        ye.observe(L), c.resizeObserver = ye;
      }
      G(e.data || []);
    }), $n(() => {
      const { resizeObserver: L } = c;
      L && L.disconnect(), ut.off(w, "resize");
    });
    const K = () => {
      const { className: L, loading: ye } = e, { bodyHeight: se, topSpaceHeight: P, items: M } = a, I = n.default, B = l.value, H = D.value;
      return o("div", {
        ref: m,
        class: ["vxe-list", L ? r.isFunction(L) ? L({ $list: w }) : L : "", {
          [`size--${B}`]: B,
          "is--loading": ye
        }]
      }, [
        o("div", {
          ref: u,
          class: "vxe-list--virtual-wrapper",
          style: H,
          onScroll: Z
        }, [
          o("div", {
            class: "vxe-list--y-space",
            style: {
              height: se ? `${se}px` : ""
            }
          }),
          o("div", {
            ref: d,
            class: "vxe-list--body",
            style: {
              marginTop: P ? `${P}px` : ""
            }
          }, I ? I({ items: M, $list: w }) : [])
        ]),
        /**
         * 加载中
         */
        o(us, {
          class: "vxe-list--loading",
          modelValue: ye
        })
      ]);
    };
    return w.renderVN = K, w;
  },
  render() {
    return this.renderVN();
  }
}), zA = Object.assign(cc, {
  install(e) {
    e.component(cc.name, cc);
  }
});
Ht.use(zA);
Ce.component(cc);
const uc = pt({
  name: "VxeMenu",
  props: {
    modelValue: [String, Number],
    expandAll: Boolean,
    collapsed: {
      type: Boolean,
      default: null
    },
    collapseFixed: Boolean,
    loading: Boolean,
    options: {
      type: Array,
      default: () => []
    },
    size: {
      type: String,
      default: () => oe().image.size || oe().size
    }
  },
  emits: [
    "update:modelValue",
    "click"
  ],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), i = mt("$xeLayoutAside", null), l = ke(), a = ke(), { computeSize: c } = dn(e), m = Rt({
      initialized: !!e.collapsed,
      isEnterCollapse: !1,
      collapseStyle: {},
      collapseZindex: 0,
      activeName: e.modelValue,
      menuList: [],
      itemHeight: 1
    }), u = {
      refElem: l
    }, d = _(() => {
      const { collapsed: M } = e;
      return r.isBoolean(M) ? M : i ? i.props.collapsed : !1;
    }), p = _(() => {
      let M = "";
      return i && (M = i.props.collapseWidth || ""), M;
    }), w = _(() => {
      let M = "";
      return i && (M = i.props.width || ""), M;
    }), v = {
      computeSize: c
    }, D = {
      xID: s,
      props: e,
      context: t,
      reactData: m,
      getRefMaps: () => u,
      getComputeMaps: () => v
    }, S = (M) => `${M.title || M.name}`, x = () => {
      m.collapseZindex < ws() && (m.collapseZindex = ds());
    }, h = (M) => {
      const { activeName: I } = m;
      r.eachTree(m.menuList, (B, H, ce, A, j, fe) => {
        B.itemKey === I ? (fe.forEach((pe) => {
          pe.isActive = !0, pe.isExpand = !0;
        }), B.isExactActive = !0) : (B.isExactActive = !1, B.isActive = !1);
      }, { children: "childList" });
    }, O = () => {
      const { options: M, expandAll: I } = e;
      m.menuList = r.mapTree(M, (B, H, ce, A, j) => Object.assign(Object.assign({}, B), { parentKey: j ? j.name || A.slice(0, A.length - 1).join(",") : "", level: A.length, itemKey: B.name || A.join(","), isExactActive: !1, isActive: !1, isExpand: r.isBoolean(B.expanded) ? B.expanded : !!I, hasChild: B.children && B.children.length > 0 }), { children: "children", mapChildren: "childList" });
    }, g = () => {
      const { collapseFixed: M } = e;
      M && me(() => {
        const { isEnterCollapse: I } = m, B = d.value, H = w.value, ce = p.value, A = l.value;
        if (A) {
          const j = A.getBoundingClientRect(), fe = A.parentNode;
          m.collapseStyle = B ? {
            top: cn(j.top),
            left: cn(j.left),
            height: cn(fe.clientHeight),
            width: I ? H ? cn(H) : "" : ce ? cn(ce) : "",
            zIndex: m.collapseZindex
          } : {};
        }
      });
    }, b = () => {
      const { collapseFixed: M } = e;
      if (M) {
        const { initialized: I } = m;
        d.value && (I || (m.initialized = !0, me(() => {
          const H = a.value;
          H && document.body.appendChild(H);
        }))), m.isEnterCollapse = !1, x(), g();
      }
    }, E = (M, I) => {
      const { hasChild: B, isExpand: H } = I;
      B && (M.stopPropagation(), M.preventDefault(), I.isExpand = !H);
    }, C = (M) => {
      m.activeName = M, n("update:modelValue", M);
    }, V = (M, I) => {
      const { itemKey: B, routerLink: H, hasChild: ce } = I;
      H ? (C(B), Z()) : ce ? E(M, I) : (C(B), Z()), G("click", { menu: I }, M);
    }, Q = () => {
      const { collapseStyle: M } = m, I = w.value;
      m.collapseStyle = Object.assign({}, M, {
        width: I ? cn(I) : ""
      }), m.isEnterCollapse = !0;
    }, Z = () => {
      const { collapseStyle: M } = m, I = l.value;
      m.collapseStyle = Object.assign({}, M, {
        width: I ? cn(I.offsetWidth) : ""
      }), m.isEnterCollapse = !1;
    }, G = (M, I, B) => {
      n(M, Zt(B, { $menu: D }, I));
    };
    Object.assign(D, {
      dispatchEvent: G
    }, {});
    const K = (M) => {
      const { icon: I, isExpand: B, hasChild: H } = M, ce = S(M);
      return [
        o("span", {
          class: "vxe-menu--item-link-icon"
        }, I ? [
          o("i", {
            class: I
          })
        ] : []),
        o("span", {
          class: "vxe-menu--item-link-title",
          title: ce
        }, ce),
        H ? o("span", {
          class: "vxe-menu--item-link-collapse",
          onClick(A) {
            E(A, M);
          }
        }, [
          o("i", {
            class: B ? ht().MENU_ITEM_EXPAND_OPEN : ht().MENU_ITEM_EXPAND_CLOSE
          })
        ]) : Ve()
      ];
    }, L = (M) => {
      const { itemKey: I, level: B, hasChild: H, isActive: ce, isExactActive: A, isExpand: j, routerLink: fe, childList: pe } = M, { isEnterCollapse: ne } = m, $ = d.value;
      return M.permissionCode && !Ai.checkVisible(M.permissionCode) ? Ve() : o("div", {
        key: I,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${B}`, {
          "is--exact-active": A,
          "is--active": ce,
          "is--expand": (!$ || ne) && j
        }]
      }, [
        fe ? o(qo("router-link"), {
          class: "vxe-menu--item-link",
          to: fe,
          onClick(J) {
            V(J, M);
          }
        }, {
          default: () => K(M)
        }) : o("div", {
          class: "vxe-menu--item-link",
          onClick(J) {
            V(J, M);
          }
        }, K(M)),
        H ? o("div", {
          class: "vxe-menu--item-group"
        }, pe.map((J) => L(J))) : Ve()
      ]);
    }, ye = (M) => {
      const { itemKey: I, level: B, hasChild: H, isActive: ce, isExactActive: A, routerLink: j, childList: fe } = M;
      return M.permissionCode && !Ai.checkVisible(M.permissionCode) ? Ve() : o("div", {
        key: I,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${B}`, {
          "is--exact-active": A,
          "is--active": ce
        }]
      }, [
        j ? o(qo("router-link"), {
          class: "vxe-menu--item-link",
          to: j,
          onClick(pe) {
            V(pe, M);
          }
        }, {
          default: () => K(M)
        }) : o("div", {
          class: "vxe-menu--item-link",
          onClick(pe) {
            V(pe, M);
          }
        }, K(M)),
        H ? o("div", {
          class: "vxe-menu--item-group"
        }, fe.map((pe) => L(pe))) : Ve()
      ]);
    }, se = () => {
      const { loading: M } = e, { initialized: I, menuList: B, collapseStyle: H, isEnterCollapse: ce } = m, A = c.value, j = d.value;
      return o("div", {
        ref: l,
        class: ["vxe-menu", {
          [`size--${A}`]: A,
          "is--collapsed": j,
          "is--loading": M
        }]
      }, [
        o("div", {
          class: "vxe-menu--item-list"
        }, B.map((fe) => j ? ye(fe) : L(fe))),
        I ? o("div", {
          ref: a,
          class: ["vxe-menu--collapse-wrapper", {
            [`size--${A}`]: A,
            "is--collapsed": j,
            "is--enter": ce,
            "is--loading": M
          }],
          style: H,
          onMouseenter: Q,
          onMouseleave: Z
        }, [
          j ? o("div", {
            class: "vxe-menu--item-list"
          }, B.map((fe) => L(fe))) : Ve()
        ]) : Ve(),
        /**
         * 加载中
         */
        o(us, {
          class: "vxe-list-view--loading",
          modelValue: M
        })
      ]);
    }, P = ke(0);
    return lt(() => e.options ? e.options.length : -1, () => {
      P.value++;
    }), lt(() => e.options, () => {
      P.value++;
    }), lt(P, () => {
      O(), h();
    }), lt(() => e.modelValue, (M) => {
      m.activeName = M;
    }), lt(() => m.activeName, () => {
      h();
    }), lt(d, () => {
      b();
    }), wn(() => {
      ut.on(D, "resize", g), g();
    }), Us(() => {
      ut.off(D, "resize");
      const M = a.value;
      if (M) {
        const I = M.parentNode;
        I && I.removeChild(M);
      }
    }), O(), h(), D.renderVN = se, D;
  },
  render() {
    return this.renderVN();
  }
}), HA = Object.assign({}, uc, {
  install(e) {
    e.component(uc.name, uc);
  }
});
Ht.use(HA);
Ce.component(uc);
function jA(e) {
  return Yc(), new Promise((t) => {
    const n = Object.assign({}, e);
    if (n.id && Pr.some((s) => s.props.id === n.id))
      t("exist");
    else {
      const s = n.onHide, i = Object.assign(n, {
        key: r.uniqueId(),
        modelValue: !0,
        onHide(l) {
          const a = Vs.modals;
          s && s(l), Vs.modals = a.filter((c) => c.key !== i.key), t(l.type);
        }
      });
      Vs.modals.push(i);
    }
  });
}
function Gv(e) {
  return r.find(Pr, (t) => t.props.id === e);
}
function qA(e) {
  const t = e ? [Gv(e)] : Pr, n = [];
  return t.forEach((s) => {
    s && n.push(s.close());
  }), Promise.all(n);
}
function oa(e, t, n, s) {
  let i;
  return r.isObject(t) ? i = t : i = { content: r.toValueString(t), title: n }, jA(Object.assign(Object.assign(Object.assign({}, e), s), i));
}
function UA(e) {
  return oa({
    type: "modal"
  }, e);
}
function GA(e, t, n) {
  return oa({
    type: "alert",
    lockScroll: !0,
    showHeader: !0,
    showFooter: !0
  }, e, t, n);
}
function KA(e, t, n) {
  return oa({
    type: "confirm",
    status: "question",
    lockScroll: !0,
    showHeader: !0,
    showFooter: !0
  }, e, t, n);
}
function YA(e, t) {
  return oa({
    type: "message",
    mask: !1,
    lockView: !1,
    lockScroll: !1,
    showHeader: !1
  }, e, "", t);
}
function XA(e, t, n) {
  return oa({
    type: "notification",
    mask: !1,
    lockView: !1,
    lockScroll: !1,
    showHeader: !0,
    draggable: !1,
    position: "top-right",
    width: 320
  }, e, t, n);
}
const ZA = {
  get: Gv,
  close: qA,
  open: UA,
  alert: GA,
  confirm: KA,
  message: YA,
  notification: XA
}, Kv = Object.assign(Oi, {
  install: function(e) {
    e.component(Oi.name, Oi);
  }
});
Ce.modal = ZA;
Ht.use(Kv);
Ce.component(Oi);
const dc = pt({
  name: "VxeNoticeBar",
  props: {
    duration: [String, Number],
    direction: {
      type: String,
      default: () => oe().noticeBar.direction
    },
    speed: {
      type: String,
      default: () => oe().noticeBar.speed
    },
    content: String,
    vertical: Boolean,
    loop: {
      type: Boolean
    },
    size: {
      type: String,
      default: () => oe().noticeBar.size || oe().size
    }
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = ke(), c = ke(), m = Rt({
      animationDuration: 0
    }), u = {
      refElem: a
    }, d = _(() => {
      const { content: O } = e;
      return `${O || ""}`;
    }), p = {}, w = {
      xID: i,
      props: e,
      context: t,
      reactData: m,
      getRefMaps: () => u,
      getComputeMaps: () => p
    }, D = {
      dispatchEvent: (O, g, b) => {
        s(O, Zt(b, { $noticeBar: w }, g));
      }
    }, S = {}, x = () => {
      const { speed: O } = e, g = c.value;
      if (g) {
        let b = 46;
        O === "fast" ? b = 118 : O === "slow" && (b = 18), m.animationDuration = Math.ceil(g.scrollWidth / b);
      }
    };
    Object.assign(w, D, S);
    const h = () => {
      const { vertical: O, duration: g, direction: b } = e, { animationDuration: E } = m, C = l.value, V = d.value, Q = n.default, Z = n.prefix, G = n.suffix;
      return o("div", {
        ref: a,
        class: ["vxe-notice-bar", `is--${O ? "vertical" : "horizontal"}`, `dir--${b || "left"}`, {
          [`size--${C}`]: C
        }]
      }, [
        Z ? o("div", {
          class: "vxe-notice-bar--prefix"
        }, Z({})) : Yn(),
        o("div", {
          class: "vxe-notice-bar--content"
        }, [
          o("div", {
            ref: c,
            class: "vxe-notice-bar--inner"
          }, [
            o("div", {
              class: "vxe-notice-bar--wrapper",
              style: {
                animationDuration: `${g ? cn(g, "s") : E}s`
              }
            }, Q ? Q({}) : V)
          ])
        ]),
        G ? o("div", {
          class: "vxe-notice-bar--suffix"
        }, G({})) : Yn()
      ]);
    };
    return w.renderVN = h, wn(() => {
      ut.on(w, "resize", x), x();
    }), Us(() => {
      ut.off(w, "resize");
    }), w;
  },
  render() {
    return this.renderVN();
  }
}), JA = Object.assign({}, dc, {
  install(e) {
    e.component(dc.name, dc);
  }
});
Ht.use(JA);
Ce.component(dc);
const QA = Object.assign({}, Vi, {
  install(e) {
    e.component(Vi.name, Vi);
  }
});
Ht.use(QA);
Ce.component(Vi);
class Yv {
  constructor(t, n) {
    Object.assign(this, {
      id: r.uniqueId("option_"),
      value: n.value,
      label: n.label,
      visible: n.visible,
      className: n.className,
      disabled: n.disabled
    });
  }
  update(t, n) {
    this[t] = n;
  }
}
function e1(e) {
  return e instanceof Yv;
}
function Xv(e, t) {
  return e1(t) ? t : new Yv(e, t);
}
function Zv(e, t) {
  Object.keys(e).forEach((n) => {
    lt(() => e[n], (s) => {
      t.update(n, s);
    });
  });
}
function Jv(e, t, n, s) {
  const { reactData: i } = e, { staticOptions: l } = i, a = t.parentNode, c = s ? s.optionConfig : null, m = c ? c.options : l;
  a && m && (m.splice(r.arrayIndexOf(a.children, t), 0, n), i.staticOptions = l.slice(0));
}
function Qv(e, t) {
  const { reactData: n } = e, { staticOptions: s } = n, i = r.findTree(s, (l) => l.id === t.id, { children: "options" });
  i && i.items.splice(i.index, 1), n.staticOptions = s.slice(0);
}
const fc = pt({
  name: "VxeOptgroup",
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(e, { slots: t }) {
    const n = ke(), s = mt("$xeSelect", {}), i = Xv(s, e), l = { optionConfig: i };
    return i.options = [], bn("$xeOptgroup", l), Zv(e, i), wn(() => {
      const a = n.value;
      Jv(s, a, i);
    }), $n(() => {
      Qv(s, i);
    }), () => {
      const a = t.default;
      return o("div", {
        ref: n
      }, a ? a({}) : []);
    };
  }
}), t1 = Object.assign(fc, {
  install: function(e) {
    e.component(fc.name, fc);
  }
});
Ht.use(t1);
Ce.component(fc);
const pc = pt({
  name: "VxeOption",
  props: {
    value: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(e, { slots: t }) {
    const n = ke(), s = mt("$xeSelect", {}), i = mt("$xeOptgroup", null), l = Xv(s, e);
    return l.slots = t, Zv(e, l), wn(() => {
      const a = n.value;
      Jv(s, a, l, i);
    }), $n(() => {
      Qv(s, l);
    }), () => o("div", {
      ref: n
    });
  }
}), n1 = Object.assign(pc, {
  install: function(e) {
    e.component(pc.name, pc);
  }
});
Ht.use(n1);
Ce.component(pc);
const mc = pt({
  name: "VxePager",
  props: {
    size: {
      type: String,
      default: () => oe().pager.size || oe().size
    },
    // 自定义布局
    layouts: {
      type: Array,
      default: () => oe().pager.layouts || ["PrevJump", "PrevPage", "Jump", "PageCount", "NextPage", "NextJump", "Sizes", "Total"]
    },
    // 当前页
    currentPage: {
      type: Number,
      default: 1
    },
    // 加载中
    loading: Boolean,
    // 每页大小
    pageSize: {
      type: Number,
      default: () => oe().pager.pageSize || 10
    },
    // 总条数
    total: { type: Number, default: 0 },
    // 显示页码按钮的数量
    pagerCount: {
      type: Number,
      default: () => oe().pager.pagerCount || 7
    },
    // 每页大小选项列表
    pageSizes: {
      type: Array,
      default: () => oe().pager.pageSizes || [10, 15, 20, 50, 100]
    },
    // 列对其方式
    align: {
      type: String,
      default: () => oe().pager.align
    },
    // 带边框
    border: {
      type: Boolean,
      default: () => oe().pager.border
    },
    // 带背景颜色
    background: {
      type: Boolean,
      default: () => oe().pager.background
    },
    // 配套的样式
    perfect: {
      type: Boolean,
      default: () => oe().pager.perfect
    },
    // 当只有一页时隐藏
    autoHidden: {
      type: Boolean,
      default: () => oe().pager.autoHidden
    },
    transfer: {
      type: Boolean,
      default: () => oe().pager.transfer
    },
    className: [String, Function],
    pageSizePlacement: {
      type: String,
      default: () => oe().pager.pageSizePlacement
    },
    // 自定义图标
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: [
    "update:pageSize",
    "update:currentPage",
    "page-change"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = mt("$xeGrid", null), c = Rt({
      inpCurrPage: e.currentPage
    }), m = ke(), u = {
      refElem: m
    }, d = _(() => h(e.total, e.pageSize)), p = _(() => {
      const { pagerCount: $ } = e, ge = d.value > $ ? $ - 2 : $, Oe = [];
      for (let Se = 0; Se < ge; Se++)
        Oe.push(Se);
      return Oe;
    }), w = _(() => Math.floor((e.pagerCount - 2) / 2)), v = _(() => e.pageSizes.map(($) => r.isNumber($) ? {
      value: $,
      label: `${Pe("vxe.pager.pagesize", [$])}`
    } : Object.assign({ value: "", label: "" }, $))), D = {
      xID: i,
      props: e,
      context: t,
      getRefMaps: () => u
    };
    let S = {}, x = {};
    const h = ($, J) => Math.max(Math.ceil($ / J), 1), O = ($, J) => {
      s("update:currentPage", J), $ && J !== e.currentPage && S.dispatchEvent("page-change", { type: "current", pageSize: e.pageSize, currentPage: J }, $);
    }, g = ($, J) => {
      s("update:currentPage", $), J && $ !== e.currentPage && S.dispatchEvent("page-change", { type: "current", pageSize: e.pageSize, currentPage: $ }, J);
    }, b = ($) => {
      const { $event: J } = $, ge = J.target, Oe = r.toInteger(ge.value), Se = d.value, de = Oe <= 0 ? 1 : Oe >= Se ? Se : Oe, Ie = r.toValueString(de);
      ge.value = Ie, c.inpCurrPage = Ie, g(de, J);
    }, E = ($) => {
      const { currentPage: J } = e;
      J > 1 && g(1, $);
    }, C = ($) => {
      const { currentPage: J } = e, ge = d.value;
      J < ge && g(ge, $);
    }, V = ($) => {
      const { currentPage: J } = e, ge = d.value;
      J > 1 && g(Math.min(ge, Math.max(J - 1, 1)), $);
    }, Q = ($) => {
      const { currentPage: J } = e, ge = d.value;
      J < ge && g(Math.min(ge, J + 1), $);
    }, Z = ($) => {
      const J = p.value;
      g(Math.max(e.currentPage - J.length, 1), $);
    }, G = ($) => {
      const J = d.value, ge = p.value;
      g(Math.min(e.currentPage + ge.length, J), $);
    }, ue = ($) => {
      const { value: J } = $, ge = r.toNumber(J), Oe = h(e.total, ge);
      let Se = e.currentPage;
      Se > Oe && (Se = Oe, s("update:currentPage", Oe)), s("update:pageSize", ge), S.dispatchEvent("page-change", { type: "size", pageSize: ge, currentPage: Se }, $.$event);
    }, Y = ($) => {
      const { $event: J } = $;
      ut.hasKey(J, Yt.ENTER) ? b($) : ut.hasKey(J, Yt.ARROW_UP) ? (J.preventDefault(), Q(J)) : ut.hasKey(J, Yt.ARROW_DOWN) && (J.preventDefault(), V(J));
    }, K = () => o("button", {
      class: ["vxe-pager--prev-btn", {
        "is--disabled": e.currentPage <= 1
      }],
      type: "button",
      title: Pe("vxe.pager.homePageTitle"),
      onClick: E
    }, [
      o("i", {
        class: ["vxe-pager--btn-icon", e.iconHomePage || ht().PAGER_HOME]
      })
    ]), L = () => o("button", {
      class: ["vxe-pager--prev-btn", {
        "is--disabled": e.currentPage <= 1
      }],
      type: "button",
      title: Pe("vxe.pager.prevPageTitle"),
      onClick: V
    }, [
      o("i", {
        class: ["vxe-pager--btn-icon", e.iconPrevPage || ht().PAGER_PREV_PAGE]
      })
    ]), ye = ($) => o($ || "button", {
      class: ["vxe-pager--jump-prev", {
        "is--fixed": !$,
        "is--disabled": e.currentPage <= 1
      }],
      type: "button",
      title: Pe("vxe.pager.prevJumpTitle"),
      onClick: Z
    }, [
      $ ? o("i", {
        class: ["vxe-pager--jump-more-icon", e.iconJumpMore || ht().PAGER_JUMP_MORE]
      }) : null,
      o("i", {
        class: ["vxe-pager--jump-icon", e.iconJumpPrev || ht().PAGER_JUMP_PREV]
      })
    ]), se = ($) => {
      const J = d.value;
      return o($ || "button", {
        class: ["vxe-pager--jump-next", {
          "is--fixed": !$,
          "is--disabled": e.currentPage >= J
        }],
        type: "button",
        title: Pe("vxe.pager.nextJumpTitle"),
        onClick: G
      }, [
        $ ? o("i", {
          class: ["vxe-pager--jump-more-icon", e.iconJumpMore || ht().PAGER_JUMP_MORE]
        }) : null,
        o("i", {
          class: ["vxe-pager--jump-icon", e.iconJumpNext || ht().PAGER_JUMP_NEXT]
        })
      ]);
    }, P = () => {
      const $ = d.value;
      return o("button", {
        class: ["vxe-pager--next-btn", {
          "is--disabled": e.currentPage >= $
        }],
        type: "button",
        title: Pe("vxe.pager.nextPageTitle"),
        onClick: Q
      }, [
        o("i", {
          class: ["vxe-pager--btn-icon", e.iconNextPage || ht().PAGER_NEXT_PAGE]
        })
      ]);
    }, M = () => {
      const $ = d.value;
      return o("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": e.currentPage >= $
        }],
        type: "button",
        title: Pe("vxe.pager.endPageTitle"),
        onClick: C
      }, [
        o("i", {
          class: ["vxe-pager--btn-icon", e.iconEndPage || ht().PAGER_END]
        })
      ]);
    }, I = ($) => {
      const { currentPage: J, pagerCount: ge } = e, Oe = [], Se = d.value, de = p.value, Ie = w.value, je = Se > ge, Ue = je && J > Ie + 1, Ae = je && J < Se - Ie;
      let _e = 1;
      return je && (J >= Se - Ie ? _e = Math.max(Se - de.length + 1, 1) : _e = Math.max(J - Ie, 1)), $ && Ue && Oe.push(o("button", {
        class: "vxe-pager--num-btn",
        type: "button",
        onClick: (it) => O(it, 1)
      }, "1"), ye("span")), de.forEach((it, vt) => {
        const dt = _e + vt;
        dt <= Se && Oe.push(o("button", {
          key: dt,
          class: ["vxe-pager--num-btn", {
            "is--active": J === dt
          }],
          type: "button",
          onClick: (at) => O(at, dt)
        }, `${dt}`));
      }), $ && Ae && Oe.push(se("button"), o("button", {
        class: "vxe-pager--num-btn",
        type: "button",
        onClick: (it) => O(it, Se)
      }, Se)), o("span", {
        class: "vxe-pager--btn-wrapper"
      }, Oe);
    }, B = () => I(!0), H = () => {
      const $ = v.value;
      return o(vs, {
        class: "vxe-pager--sizes",
        modelValue: e.pageSize,
        placement: e.pageSizePlacement,
        transfer: e.transfer,
        options: $,
        onChange: ue
      });
    }, ce = ($) => {
      const J = d.value;
      return o("span", {
        class: "vxe-pager--jump"
      }, [
        $ ? o("span", {
          class: "vxe-pager--goto-text"
        }, Pe("vxe.pager.goto")) : null,
        o(Wn, {
          class: "vxe-pager--goto",
          modelValue: c.inpCurrPage,
          placeholder: Pe("vxe.pager.gotoTitle"),
          align: "center",
          type: "integer",
          max: J,
          min: 1,
          controls: !1,
          onKeydown: Y,
          onBlur: b,
          "onUpdate:modelValue"(ge) {
            c.inpCurrPage = ge;
          }
        }),
        $ ? o("span", {
          class: "vxe-pager--classifier-text"
        }, Pe("vxe.pager.pageClassifier")) : null
      ]);
    }, A = () => ce(!0), j = () => {
      const $ = d.value;
      return o("span", {
        class: "vxe-pager--count"
      }, [
        o("span", {
          class: "vxe-pager--separator"
        }),
        o("span", $)
      ]);
    }, fe = () => o("span", {
      class: "vxe-pager--total"
    }, Pe("vxe.pager.total", [e.total]));
    S = {
      dispatchEvent: ($, J, ge) => {
        s($, Zt(ge, { $pager: D }, J));
      },
      homePage() {
        return E(), me();
      },
      endPage() {
        return C(), me();
      },
      prevPage() {
        return V(), me();
      },
      nextPage() {
        return Q(), me();
      },
      prevJump() {
        return Z(), me();
      },
      nextJump() {
        return G(), me();
      }
    }, x = {
      handlePrevPage: V,
      handleNextPage: Q,
      handlePrevJump: Z,
      handleNextJump: G
    }, Object.assign(D, S, x), lt(() => e.currentPage, ($) => {
      c.inpCurrPage = $;
    });
    const ne = () => {
      const { align: $, layouts: J, className: ge } = e, Oe = [], Se = l.value, de = d.value;
      return n.left && Oe.push(o("span", {
        class: "vxe-pager--left-wrapper"
      }, n.left({ $grid: a }))), J.forEach((Ie) => {
        let je;
        switch (Ie) {
          case "Home":
            je = K;
            break;
          case "PrevJump":
            je = ye;
            break;
          case "PrevPage":
            je = L;
            break;
          case "Number":
            je = I;
            break;
          case "JumpNumber":
            je = B;
            break;
          case "NextPage":
            je = P;
            break;
          case "NextJump":
            je = se;
            break;
          case "End":
            je = M;
            break;
          case "Sizes":
            je = H;
            break;
          case "FullJump":
            je = A;
            break;
          case "Jump":
            je = ce;
            break;
          case "PageCount":
            je = j;
            break;
          case "Total":
            je = fe;
            break;
        }
        je ? Oe.push(je()) : process.env.NODE_ENV === "development" && Ao("vxe.error.notProp", [`layouts -> ${Ie}`]);
      }), n.right && Oe.push(o("span", {
        class: "vxe-pager--right-wrapper"
      }, n.right({ $grid: a }))), o("div", {
        ref: m,
        class: ["vxe-pager", ge ? r.isFunction(ge) ? ge({ $pager: D }) : ge : "", {
          [`size--${Se}`]: Se,
          [`align--${$}`]: $,
          "is--border": e.border,
          "is--background": e.background,
          "is--perfect": e.perfect,
          "is--hidden": e.autoHidden && de === 1,
          "is--loading": e.loading
        }]
      }, [
        o("div", {
          class: "vxe-pager--wrapper"
        }, Oe)
      ]);
    };
    return D.renderVN = ne, D;
  },
  render() {
    return this.renderVN();
  }
}), eb = Object.assign(mc, {
  install: function(e) {
    e.component(mc.name, mc);
  }
});
Ht.use(eb);
Ce.component(mc);
const gc = pt({
  name: "VxePasswordInput",
  props: {
    modelValue: String,
    immediate: {
      type: Boolean,
      default: !0
    },
    name: String,
    clearable: {
      type: Boolean,
      default: () => oe().passwordInput.clearable
    },
    readonly: Boolean,
    disabled: Boolean,
    maxLength: [String, Number],
    placeholder: String,
    autoComplete: {
      type: String,
      default: "off"
    },
    className: String,
    size: {
      type: String,
      default: () => oe().passwordInput.size || oe().size
    },
    prefixIcon: String,
    suffixIcon: String,
    controls: {
      type: Boolean,
      default: () => oe().passwordInput.controls
    },
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "click",
    "focus",
    "blur",
    "clear",
    "toggle-visible",
    "prefix-click",
    "suffix-click"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = mt("$xeForm", null), l = mt("xeFormItemInfo", null), a = r.uniqueId(), { computeSize: c } = dn(e), m = Rt({
      showPwd: !1,
      isActivated: !1,
      inputValue: e.modelValue
    }), u = ke(), d = ke(), p = {
      refElem: u,
      refInput: d
    }, w = {
      xID: a,
      props: e,
      context: t,
      reactData: m,
      getRefMaps: () => p
    };
    let v = {};
    const D = _(() => e.clearable), S = _(() => {
      const { readonly: I } = e;
      return I;
    }), x = _(() => {
      const { placeholder: I } = e;
      if (I)
        return Bn(I);
      const B = oe().passwordInput.placeholder;
      return B ? Bn(B) : Pe("vxe.base.pleaseInput");
    }), h = _(() => {
      const { showPwd: I } = m;
      return I ? "text" : "password";
    }), O = _(() => {
      const { immediate: I } = e;
      return I;
    }), g = (I) => {
      const { inputValue: B } = m;
      v.dispatchEvent(I.type, { value: B }, I);
    }, b = (I, B) => {
      const H = O.value;
      m.inputValue = I, H ? C(I, B) : v.dispatchEvent("input", { value: I }, B);
    }, E = (I) => {
      const H = I.target.value;
      b(H, I);
    }, C = (I, B) => {
      m.inputValue = I, n("update:modelValue", I), v.dispatchEvent("input", { value: I }, B), r.toValueString(e.modelValue) !== I && (v.dispatchEvent("change", { value: I }, B), i && l && i.triggerItemEvent(B, l.itemConfig.field, I));
    }, V = (I) => {
      g(I);
      const { inputValue: B } = m;
      i && l && i.triggerItemEvent(I, l.itemConfig.field, B);
    }, Q = (I) => {
      m.isActivated = !0, g(I);
    }, Z = (I) => {
      const { inputValue: B } = m, H = B;
      v.dispatchEvent("blur", { value: H }, I), i && l && i.triggerItemEvent(I, l.itemConfig.field, H);
    }, G = (I) => {
      const { readonly: B, disabled: H } = e, { showPwd: ce } = m;
      !H && !B && (m.showPwd = !ce), v.dispatchEvent("toggle-visible", { visible: m.showPwd }, I);
    }, ue = (I) => {
      g(I);
    }, Y = (I, B) => {
      focus(), C("", I), v.dispatchEvent("clear", { value: B }, I);
    }, K = (I) => {
      const { disabled: B } = e;
      if (!B) {
        const { inputValue: H } = m;
        v.dispatchEvent("suffix-click", { value: H }, I);
      }
    }, L = (I) => {
      const { disabled: B } = e;
      if (!B) {
        const { inputValue: H } = m;
        v.dispatchEvent("prefix-click", { value: H }, I);
      }
    }, ye = () => {
      const { showPwd: I } = m;
      return o("div", {
        class: "vxe-password-input--control-icon",
        onClick: G
      }, [
        o("i", {
          class: ["vxe-password-input--password-icon", I ? ht().PASSWORD_INPUT_SHOW_PWD : ht().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    }, se = () => {
      const { prefixIcon: I } = e, B = s.prefix;
      return B || I ? o("div", {
        class: "vxe-password-input--prefix",
        onClick: L
      }, [
        o("div", {
          class: "vxe-password-input--prefix-icon"
        }, B ? Nt(B({})) : [
          o("i", {
            class: I
          })
        ])
      ]) : null;
    }, P = () => {
      const { disabled: I, suffixIcon: B, controls: H } = e, { inputValue: ce } = m, A = s.suffix, j = D.value;
      return j || H || A || B ? o("div", {
        class: ["vxe-password-input--suffix", {
          "is--clear": j && !I && !(ce === "" || r.eqNull(ce))
        }]
      }, [
        j ? o("div", {
          class: "vxe-password-input--clear-icon",
          onClick: Y
        }, [
          o("i", {
            class: ht().INPUT_CLEAR
          })
        ]) : Ve(),
        H ? ye() : Ve(),
        A || B ? o("div", {
          class: "vxe-password-input--suffix-icon",
          onClick: K
        }, A ? Nt(A({})) : [
          o("i", {
            class: B
          })
        ]) : Ve()
      ]) : null;
    };
    v = {
      dispatchEvent(I, B, H) {
        n(I, Zt(H, { $passwordInput: w }, B));
      },
      focus() {
        const I = d.value;
        return m.isActivated = !0, I.focus(), me();
      },
      blur() {
        return d.value.blur(), m.isActivated = !1, me();
      },
      select() {
        return d.value.select(), m.isActivated = !1, me();
      }
    }, Object.assign(w, v), lt(() => e.modelValue, (I) => {
      m.inputValue = I;
    });
    const M = () => {
      const { className: I, name: B, disabled: H, readonly: ce, autocomplete: A, autoComplete: j, maxLength: fe } = e, { inputValue: pe, isActivated: ne } = m, $ = c.value, J = S.value, ge = h.value, Oe = x.value, Se = D.value, de = se(), Ie = P();
      return o("div", {
        ref: u,
        class: ["vxe-password-input", I, {
          [`size--${$}`]: $,
          "is--prefix": !!de,
          "is--suffix": !!Ie,
          "is--readonly": ce,
          "is--disabled": H,
          "is--active": ne,
          "show--clear": Se && !H && !(pe === "" || r.eqNull(pe))
        }],
        spellcheck: !1
      }, [
        de || Ve(),
        o("div", {
          class: "vxe-password-input--wrapper"
        }, [
          o("input", {
            ref: d,
            class: "vxe-password-input--inner",
            value: pe,
            name: B,
            type: ge,
            placeholder: Oe,
            readonly: J,
            disabled: H,
            autocomplete: A || j,
            maxlength: fe,
            onClick: ue,
            onInput: E,
            onChange: V,
            onFocus: Q,
            onBlur: Z
          })
        ]),
        Ie || Ve()
      ]);
    };
    return w.renderVN = M, w;
  },
  render() {
    return this.renderVN();
  }
}), o1 = Object.assign({}, gc, {
  install(e) {
    e.component(gc.name, gc);
  }
});
Ht.use(o1);
Ce.component(gc);
let Lo;
const s1 = 'body{margin:0;padding:0;color:#000000;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function bm() {
  const e = document.createElement("iframe");
  return e.className = "vxe-table--print-frame", e;
}
function xm() {
  Lo.parentNode || document.body.appendChild(Lo);
}
function r1() {
  requestAnimationFrame(tb);
}
function tb() {
  if (Lo) {
    if (Lo.parentNode) {
      try {
        Lo.contentDocument.write("");
      } catch {
      }
      Lo.parentNode.removeChild(Lo);
    }
    Lo = null;
  }
}
function l1(e, t) {
  return new Blob([e], { type: `text/${t};charset=utf-8;` });
}
const Ma = 80;
function i1(e, t) {
  const { customStyle: n } = e;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${e.title}</title>`,
    e._pageBreaks || e.pageBreaks && e.pageBreaks.length ? '<style media="print">@page {size: auto;margin: 0mm;}</style>' : "",
    `<style>.vxe-print-slots{display: none;}.vxe-print-page-break.align--center{text-align:center;}.vxe-print-page-break.align--left{text-align:left;}.vxe-print-page-break.align--right{text-align:right;}.vxe-print-page-break--header-title{font-size:1.8em;text-align:center;line-height:${Ma}px;}.vxe-print-page-break{page-break-before:always;display:flex;flex-direction:column;height:100vh;overflow:hidden;}.vxe-print-page-break--body{display:flex;flex-direction:row;flex-grow:1;overflow: hidden;}.vxe-print-page-break--left,.vxe-print-page-break--right{flex-shrink:0;width:${Ma}px;height:100%;}.vxe-print-page-break--header,.vxe-print-page-break--footer{flex-shrink:0;height:${Ma}px;width:100%;}.vxe-print-page-break--content{flex-grow: 1;overflow: hidden;}.vxe-print-page-break--footer-page-number{line-height:${Ma}px;text-align:center;}</style>`,
    "<style>.vxe-table{white-space:pre;}</style>",
    `<style>${s1}</style>`,
    n ? `<style>${n}</style>` : "",
    "</head>",
    "<body>",
    `${t}`,
    "</body>",
    "</html>"
  ].join("");
}
function ym(e, t = "") {
  const { beforeMethod: n } = e;
  n && (t = n({ content: t, html: t, options: e }) || ""), t = i1(e, t);
  const s = l1(t, "html");
  return new Promise((i) => {
    r.browse().msie ? (tb(), Lo = bm(), xm(), Lo.contentDocument.write(t), Lo.contentDocument.execCommand("print"), setTimeout(() => {
      i({
        status: !0
      });
    }, 300)) : (Lo || (Lo = bm(), Lo.onload = (l) => {
      l.target.src && (l.target.contentWindow.onafterprint = r1, l.target.contentWindow.print()), i({
        status: !0
      });
    }, Lo.onerror = () => {
      i({
        status: !1
      });
    }), xm(), Lo.src = URL.createObjectURL(s));
  });
}
function a1(e) {
  const { title: t, showPageNumber: n, align: s, headerAlign: i, footerAlign: l, showAllPageTitle: a } = e, c = e.pageBreaks || [], m = c.length;
  return c.map((u, d) => {
    const p = u.bodyHtml, w = u.headerHtml || e.headerHtml, v = u.footerHtml || e.footerHtml, D = u.leftHtml || e.leftHtml, S = u.rightHtml || e.rightHtml, x = d + 1, h = {
      currentPage: x,
      pageCount: m
    };
    return [
      `<div class="${["vxe-print-page-break", s ? `align--${s}` : ""].join(" ")}">`,
      `<div class="${["vxe-print-page-break--header", i ? `align--${i}` : ""].join(" ")}">`,
      w ? `${r.isFunction(w) ? w(h) : w || ""}` : t && (a || !d) ? `<div class="vxe-print-page-break--header-title">${t || ""}</div>` : "",
      "</div>",
      '<div class="vxe-print-page-break--body">',
      `<div class="vxe-print-page-break--left">${r.isFunction(D) ? D(h) : D || ""}</div>`,
      `<div class="vxe-print-page-break--content">${r.isFunction(p) ? p(h) : p || ""}</div>`,
      `<div class="vxe-print-page-break--right">${r.isFunction(S) ? S(h) : S || ""}</div>`,
      "</div>",
      `<div class="${["vxe-print-page-break--footer", l ? `align--${l}` : ""].join(" ")}">`,
      v ? `${r.isFunction(v) ? v(h) : v || ""}` : n ? `<div class="vxe-print-page-break--footer-page-number">${x}/${m}</div>` : "",
      "</div>",
      "</div>"
    ].join("");
  }).join("");
}
const nb = (e) => {
  const t = Object.assign({ _pageBreaks: !1, customLayout: !0 }, e);
  if (t.sheetName && (t.title = t.title || t.sheetName), t.style && (t.customStyle = t.customStyle || t.style), t.beforePrintMethod && (t.beforeMethod = t.beforeMethod || t.beforePrintMethod), t.pageBreaks && t.pageBreaks.length)
    return ym(t, a1(t));
  const n = t.html || t.content;
  return ym(t, n);
};
function c1(e, t, n) {
  const s = e.reactData.staticPageBreaks, i = t.parentNode;
  i && s && (s.splice(r.arrayIndexOf(i.children, t), 0, n), e.reactData.staticPageBreaks = s.slice(0));
}
function u1(e, t) {
  e.reactData.staticPageBreaks = e.reactData.staticPageBreaks.filter((n) => n.id !== t.id);
}
const hc = pt({
  name: "VxePrintPageBreak",
  props: {},
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = mt("$xePrint", null), a = ke(), c = Rt({}), m = {
      refElem: a
    }, u = {}, d = Rt({
      id: i,
      slots: n
    }), p = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => u
    };
    if (Object.assign(p, {
      dispatchEvent: (x, h, O) => {
        s(x, Zt(O, { $print: l }, h));
      }
    }, {}), !l)
      return p.renderVN = () => Ve(), p;
    const S = () => o("div", {
      ref: a
    });
    return wn(() => {
      const x = a.value;
      l && x && c1(l, x, d);
    }), $n(() => {
      l && u1(l, d);
    }), p.renderVN = S, p;
  },
  render() {
    return this.renderVN();
  }
}), d1 = Object.assign({}, hc, {
  install(e) {
    e.component(hc.name, hc);
  }
});
Ht.use(d1);
Ce.component(hc);
const vc = pt({
  name: "VxePrint",
  props: {
    align: {
      type: String,
      default: () => oe().print.align
    },
    title: String,
    headerAlign: {
      type: String,
      default: () => oe().print.headerAlign
    },
    footerAlign: {
      type: String,
      default: () => oe().print.footerAlign
    },
    showPageNumber: {
      type: Boolean,
      default: () => oe().print.showPageNumber
    },
    customLayout: Boolean,
    pageBreaks: Array,
    content: String,
    html: String,
    headerHtml: String,
    footerHtml: String,
    leftHtml: String,
    rightHtml: String,
    showAllPageTitle: {
      type: Boolean,
      default: () => oe().print.showAllPageTitle
    },
    customStyle: {
      type: String,
      default: () => oe().print.customStyle
    },
    beforeMethod: Function
  },
  emits: [],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), l = ke(), a = Rt({
      staticPageBreaks: []
    }), c = {
      refElem: l
    }, m = {}, u = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => m
    };
    Object.assign(u, {
      dispatchEvent: (x, h, O) => {
        s(x, Zt(O, { $print: u }, h));
      },
      print() {
        const x = l.value;
        return nb(Object.assign({}, e, {
          _pageBreaks: !!a.staticPageBreaks.length,
          html: (x ? x.outerHTML : "") || e.html || e.content || ""
        }));
      }
    }, {});
    const v = () => {
      const { title: x, showPageNumber: h, showAllPageTitle: O, align: g, headerAlign: b, footerAlign: E } = e, C = e.pageBreaks || [], V = C.length;
      return C.map((Q, Z) => {
        const G = Q.bodyHtml, ue = Q.headerHtml || e.headerHtml, Y = Q.footerHtml || e.footerHtml, K = Q.leftHtml || e.leftHtml, L = Q.rightHtml || e.rightHtml, ye = Z + 1, se = {
          currentPage: ye,
          pageCount: V
        };
        return o("div", {
          class: ["vxe-print-page-break", g ? `align--${g}` : ""]
        }, [
          o("div", {
            class: ["vxe-print-page-break--header", b ? `align--${b}` : ""]
          }, ue ? `${r.isFunction(ue) ? ue(se) : ue || ""}` : [
            x && (O || !Z) ? o("div", {
              class: "vxe-print-page-break--header-title"
            }, `${x || ""}`) : Ve()
          ]),
          o("div", {
            class: "vxe-print-page-break--body"
          }, [
            o("div", {
              class: "vxe-print-page-break--left"
            }, `${r.isFunction(K) ? K(se) : K || ""}`),
            o("div", {
              class: "vxe-print-page-break--content"
            }, `${r.isFunction(G) ? G(se) : G || ""}`),
            o("div", {
              class: "vxe-print-page-break--right"
            }, `${r.isFunction(L) ? L(se) : L || ""}`)
          ]),
          o("div", {
            class: ["vxe-print-page-break--footer", E ? `align--${E}` : ""]
          }, Y ? `${r.isFunction(Y) ? Y(se) : Y || ""}` : [
            h ? o("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${ye}/${V}`) : Ve()
          ])
        ]);
      });
    }, D = () => {
      const { title: x, showPageNumber: h, showAllPageTitle: O, align: g, headerAlign: b, footerAlign: E } = e, { staticPageBreaks: C } = a, V = C.length;
      return C.map((Q, Z) => {
        const G = Q.slots || {}, ue = Z + 1, Y = G.default, K = G.header || n.header, L = G.footer || n.footer, ye = G.left || n.left, se = G.right || n.right, P = {
          currentPage: ue,
          pageCount: V
        };
        return o("div", {
          class: ["vxe-print-page-break", g ? `align--${g}` : ""]
        }, [
          o("div", {
            class: ["vxe-print-page-break--header", b ? `align--${b}` : ""]
          }, K ? Nt(K(P)) : [
            x && (O || !Z) ? o("div", {
              class: "vxe-print-page-break--header-title"
            }, `${x || ""}`) : Ve()
          ]),
          o("div", {
            class: "vxe-print-page-break--body"
          }, [
            o("div", {
              class: "vxe-print-page-break--left"
            }, ye ? Nt(ye(P)) : []),
            o("div", {
              class: "vxe-print-page-break--content"
            }, Y ? Nt(Y(P)) : []),
            o("div", {
              class: "vxe-print-page-break--right"
            }, se ? Nt(se(P)) : [])
          ]),
          o("div", {
            class: ["vxe-print-page-break--footer", E ? `align--${E}` : ""]
          }, L ? Nt(L(P)) : [
            h ? o("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${ue}/${V}`) : Ve()
          ])
        ]);
      });
    }, S = () => {
      const { customLayout: x } = e, { staticPageBreaks: h } = a, O = n.default;
      return o("div", {
        ref: l,
        class: ["vxe-print"]
      }, x ? O ? Nt(O({})) : [] : [
        o("div", {
          key: "slot",
          class: "vxe-print-slots"
        }, O ? Nt(O({})) : [])
      ].concat(h.length ? D() : v()));
    };
    return u.renderVN = S, bn("$xePrint", u), u;
  },
  render() {
    return this.renderVN();
  }
}), ob = Object.assign({}, vc, {
  install(e) {
    e.component(vc.name, vc);
  }
});
Ht.use(ob);
Ce.component(vc);
Ce.print = nb;
const bc = pt({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    trigger: {
      type: String,
      default: oe().pulldown.trigger
    },
    size: { type: String, default: () => oe().size },
    options: Array,
    className: {
      type: [String, Function],
      default: oe().pulldown.className
    },
    popupClassName: [String, Function],
    showPopupShadow: Boolean,
    destroyOnClose: {
      type: Boolean,
      default: oe().pulldown.destroyOnClose
    },
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "click",
    "option-click",
    "show-panel",
    "hide-panel"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = mt("$xeModal", null), l = mt("$xeDrawer", null), a = mt("$xeTable", null), c = mt("$xeForm", null), m = r.uniqueId(), { computeSize: u } = dn(e), d = Rt({
      initialized: !1,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: !1,
      isAniVisible: !1,
      isActivated: !1
    }), p = {
      hpTimeout: void 0
    }, w = ke(), v = ke(), D = ke(), S = _(() => {
      const { transfer: P } = e;
      if (P === null) {
        const M = oe().pulldown.transfer;
        if (r.isBoolean(M))
          return M;
        if (a || i || l || c)
          return !0;
      }
      return P;
    }), x = {
      refElem: w
    }, h = {
      xID: m,
      props: e,
      context: t,
      reactData: d,
      internalData: p,
      getRefMaps: () => x
    };
    let O = {};
    const g = () => {
      d.panelIndex < ws() && (d.panelIndex = ds());
    }, b = () => d.visiblePanel, E = () => me().then(() => {
      const { placement: P } = e, { panelIndex: M, visiblePanel: I } = d, B = S.value;
      if (I) {
        const H = v.value, ce = D.value;
        if (ce && H) {
          const A = H.offsetHeight, j = H.offsetWidth, fe = ce.offsetHeight, pe = ce.offsetWidth, ne = 5, $ = {
            zIndex: M
          }, { boundingTop: J, boundingLeft: ge, visibleHeight: Oe, visibleWidth: Se } = br(H);
          let de = "bottom";
          if (B) {
            let Ie = ge, je = J + A;
            P === "top" ? (de = "top", je = J - fe) : P || (je + fe + ne > Oe && (de = "top", je = J - fe), je < ne && (de = "bottom", je = J + A)), Ie + pe + ne > Se && (Ie -= Ie + pe + ne - Se), Ie < ne && (Ie = ne), Object.assign($, {
              left: `${Ie}px`,
              top: `${je}px`,
              minWidth: `${j}px`
            });
          } else
            P === "top" ? (de = "top", $.bottom = `${A}px`) : P || J + A + fe > Oe && J - A - fe > ne && (de = "top", $.bottom = `${A}px`);
          d.panelStyle = $, d.panelPlacement = de;
        }
      }
      return me();
    }), C = () => (d.initialized || (d.initialized = !0), new Promise((P) => {
      e.disabled ? me(() => {
        P();
      }) : (p.hpTimeout && clearTimeout(p.hpTimeout), d.isActivated = !0, d.isAniVisible = !0, setTimeout(() => {
        d.visiblePanel = !0, s("update:modelValue", !0), E(), setTimeout(() => {
          P(E());
        }, 40);
      }, 10), g());
    })), V = () => (d.visiblePanel = !1, s("update:modelValue", !1), new Promise((P) => {
      d.isAniVisible ? p.hpTimeout = window.setTimeout(() => {
        d.isAniVisible = !1, me(() => {
          P();
        });
      }, 350) : me(() => {
        P();
      });
    })), Q = () => d.visiblePanel ? V() : C(), Z = (P, M) => {
      M.disabled || (d.visiblePanel && (V(), L("hide-panel", {}, P)), L("option-click", { option: M }, P));
    }, G = (P) => {
      const { trigger: M } = e;
      M === "click" && (d.visiblePanel ? (V(), L("hide-panel", {}, P)) : (C(), L("show-panel", {}, P))), L("click", { $pulldown: h }, P);
    }, ue = (P) => {
      const { disabled: M } = e, { visiblePanel: I } = d, B = D.value;
      M || I && (jn(P, B).flag ? E() : (V(), L("hide-panel", {}, P)));
    }, Y = (P) => {
      const { disabled: M } = e, { visiblePanel: I } = d, B = w.value, H = D.value;
      M || (d.isActivated = jn(P, B).flag || jn(P, H).flag, I && !d.isActivated && (V(), L("hide-panel", {}, P)));
    }, K = (P) => {
      d.visiblePanel && (d.isActivated = !1, V(), L("hide-panel", {}, P));
    }, L = (P, M, I) => {
      s(P, Zt(I, { $pulldown: h }, M));
    };
    O = {
      dispatchEvent: L,
      isPanelVisible: b,
      togglePanel: Q,
      showPanel: C,
      hidePanel: V
    }, Object.assign(h, O), lt(() => e.modelValue, (P) => {
      d.isActivated = !!P, P ? C() : V();
    }), me(() => {
      e.modelValue && C(), ut.on(h, "mousewheel", ue), ut.on(h, "mousedown", Y), ut.on(h, "blur", K);
    }), $n(() => {
      ut.off(h, "mousewheel"), ut.off(h, "mousedown"), ut.off(h, "blur");
    });
    const ye = (P) => {
      const M = n.option;
      return o("div", {
        class: "vxe-pulldown--panel-list"
      }, P ? P.map((I) => o("div", {
        class: "vxe-pulldown--panel-item",
        onClick(B) {
          Z(B, I);
        }
      }, M ? M({ $pulldown: h, option: I }) : `${I.label || ""}`)) : []);
    }, se = () => {
      const { className: P, options: M, popupClassName: I, showPopupShadow: B, destroyOnClose: H, disabled: ce } = e, { initialized: A, isActivated: j, isAniVisible: fe, visiblePanel: pe, panelStyle: ne, panelPlacement: $ } = d, J = S.value, ge = u.value, Oe = n.default, Se = n.header, de = n.footer, Ie = n.dropdown;
      return o("div", {
        ref: w,
        class: ["vxe-pulldown", P ? r.isFunction(P) ? P({ $pulldown: h }) : P : "", {
          [`size--${ge}`]: ge,
          "is--visible": pe,
          "is--disabled": ce,
          "is--active": j
        }]
      }, [
        o("div", {
          ref: v,
          class: "vxe-pulldown--content",
          onClick: G
        }, Oe ? Oe({ $pulldown: h }) : []),
        o(ks, {
          to: "body",
          disabled: J ? !A : !0
        }, [
          o("div", {
            ref: D,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", I ? r.isFunction(I) ? I({ $pulldown: h }) : I : "", {
              [`size--${ge}`]: ge,
              "is--shadow": B,
              "is--transfer": J,
              "ani--leave": fe,
              "ani--enter": pe
            }],
            placement: $,
            style: ne
          }, [
            o("div", {
              class: "vxe-pulldown--panel-wrapper"
            }, A && (!H || pe || fe) ? [
              Se ? o("div", {
                class: "vxe-pulldown--panel-header"
              }, Se({ $pulldown: h })) : Ve(),
              o("div", {
                class: "vxe-pulldown--panel-body"
              }, Ie ? Ie({ $pulldown: h }) : [
                ye(M)
              ]),
              de ? o("div", {
                class: "vxe-pulldown--panel-footer"
              }, de({ $pulldown: h })) : Ve()
            ] : [])
          ])
        ])
      ]);
    };
    return h.renderVN = se, h;
  },
  render() {
    return this.renderVN();
  }
}), f1 = Object.assign(bc, {
  install: function(e) {
    e.component(bc.name, bc);
  }
});
Ht.use(f1);
Ce.component(bc);
const p1 = Object.assign(Mi, {
  install: function(e) {
    e.component(Mi.name, Mi);
  }
});
Ht.use(p1);
Ce.component(Mi);
const m1 = Object.assign(Ii, {
  install: function(e) {
    e.component(Ii.name, Ii);
  }
});
Ht.use(m1);
Ce.component(Ii);
const g1 = Object.assign(Jo, {
  install: function(e) {
    e.component(Jo.name, Jo);
  }
});
Ht.use(g1);
Ce.component(Jo);
const h1 = Object.assign({}, $i, {
  install(e) {
    e.component($i.name, $i);
  }
});
Ht.use(h1);
Ce.component($i);
const xc = pt({
  name: "VxeResult",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    type: [String, Number],
    status: [String, Number],
    title: [String, Number],
    content: [String, Number]
  },
  emits: [],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = r.uniqueId(), l = ke(), a = Rt({}), c = {
      refElem: l
    }, m = {}, u = {
      xID: i,
      props: e,
      context: t,
      reactData: a,
      getRefMaps: () => c,
      getComputeMaps: () => m
    };
    Object.assign(u, {
      dispatchEvent: (D, S, x) => {
        n(D, Zt(x, { $result: u }, S));
      }
    }, {});
    const v = () => {
      const { imageUrl: D, imageStyle: S, icon: x, title: h, type: O, content: g } = e, b = e.status || O, E = s.extra;
      return o("div", {
        ref: "refElem",
        class: ["vxe-result", {
          [`theme--${b}`]: b
        }]
      }, [
        o("div", {
          class: "vxe-result--inner"
        }, [
          D ? o("div", {
            class: "vxe-result--img-wrapper"
          }, [
            o("img", {
              src: D,
              style: S
            })
          ]) : o("div", {
            class: "vxe-result--icon-wrapper"
          }, [
            o("i", {
              class: [x, O ? ht()[`RESULT_${O}`.toLocaleUpperCase()] : ""]
            })
          ]),
          o("div", {
            class: "vxe-result--title-wrapper"
          }, `${h || ""}`),
          o("div", {
            class: "vxe-result--content-wrapper"
          }, `${g || ""}`),
          E ? o("div", {
            class: "vxe-result--extra-wrapper"
          }, E({})) : Yn()
        ])
      ]);
    };
    return u.renderVN = v, u;
  },
  render() {
    return this.renderVN();
  }
}), v1 = Object.assign({}, xc, {
  install(e) {
    e.component(xc.name, xc);
  }
});
Ht.use(v1);
Ce.component(xc);
const b1 = Object.assign({}, zl, {
  install(e) {
    e.component(zl.name, zl);
  }
});
Ht.use(b1);
Ce.component(zl);
const x1 = Object.assign(vs, {
  install: function(e) {
    e.component(vs.name, vs);
  }
});
Ht.use(x1);
Ce.component(vs);
const y1 = Object.assign({}, Ri, {
  install(e) {
    e.component(Ri.name, Ri);
  }
});
Ht.use(y1);
Ce.component(Ri);
const yc = pt({
  name: "VxeSteps",
  props: {},
  emits: [],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), i = ke(), l = Rt({}), a = {
      refElem: i
    }, c = {}, m = {
      xID: s,
      props: e,
      context: t,
      reactData: l,
      getRefMaps: () => a,
      getComputeMaps: () => c
    };
    Object.assign(m, {
      dispatchEvent: (v, D, S) => {
        n(v, Zt(S, { $steps: m }, D));
      }
    }, {});
    const w = () => o("div", {
      ref: i,
      class: "vxe-steps"
    }, []);
    return m.renderVN = w, m;
  },
  render() {
    return this.renderVN();
  }
}), C1 = Object.assign({}, yc, {
  install(e) {
    e.component(yc.name, yc);
  }
});
Ht.use(C1);
Ce.component(yc);
const w1 = Object.assign(ao, {
  install: function(e) {
    e.component(ao.name, ao);
  }
});
Ht.use(w1);
Ce.component(ao);
const E1 = Object.assign({}, qs, {
  install(e) {
    e.component(qs.name, qs);
  }
});
Ht.use(E1);
Ce.component(qs);
function S1() {
  return r.uniqueId("row_");
}
const Cc = pt({
  name: "VxeTableSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => r.eqNull(oe().tableSelect.placeholder) ? Pe("vxe.base.pleaseSelect") : oe().tableSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    prefixIcon: String,
    placement: String,
    columns: Array,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => oe().select.size || oe().size
    },
    popupConfig: Object,
    gridConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click"
  ],
  setup(e, t) {
    const { emit: n, slots: s } = t, i = Ce.getComponent("VxeGrid"), l = mt("$xeModal", null), a = mt("$xeDrawer", null), c = mt("$xeTable", null), m = mt("$xeForm", null), u = mt("xeFormItemInfo", null), d = r.uniqueId(), { computeSize: p } = dn(e), w = ke(), v = ke(), D = ke(), S = ke(), x = ke(), h = Rt({
      initialized: !1,
      tableColumns: [],
      fullOptionList: [],
      fullRowMaps: {},
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: !1,
      visiblePanel: !1,
      isAniVisible: !1,
      isActivated: !1
    }), O = {
      // hpTimeout: undefined,
      // vpTimeout: undefined
    }, g = {
      refElem: w
    }, b = _(() => {
      const { readonly: De } = e;
      return De === null ? m ? m.props.readonly : !1 : De;
    }), E = _(() => {
      const { disabled: De } = e;
      return De === null ? m ? m.props.disabled : !1 : De;
    }), C = _(() => {
      const { transfer: De } = e;
      if (De === null) {
        const Re = oe().select.transfer;
        if (r.isBoolean(Re))
          return Re;
        if (c || l || a || m)
          return !0;
      }
      return De;
    }), V = _(() => e.optionProps || {}), Q = _(() => {
      const De = K.value;
      return Object.assign({}, De.rowConfig, {
        isCurrent: !0
      });
    }), Z = _(() => Q.value.keyField || "_X_ROW_KEY"), G = _(() => V.value.label || "label"), ue = _(() => V.value.value || "value"), Y = _(() => Object.assign({}, oe().tableSelect.popupConfig, e.popupConfig)), K = _(() => Object.assign({}, oe().tableSelect.gridConfig, e.gridConfig, { data: void 0, columns: void 0 })), L = _(() => {
      const { modelValue: De } = e, { fullRowMaps: Re } = h, Be = G.value;
      return (r.isArray(De) ? De : [De]).map((ve) => {
        const Ne = Re[ve];
        return Ne ? Ne.item[Be] : ve;
      }).join(", ");
    }), ye = _(() => {
      const De = Y.value, { height: Re, width: Be } = De, ve = {};
      return Be && (ve.width = cn(Be)), Re && (ve.height = cn(Re)), ve;
    }), se = {}, P = {
      xID: d,
      props: e,
      context: t,
      reactData: h,
      getRefMaps: () => g,
      getComputeMaps: () => se
    }, M = (De, Re, Be) => {
      n(De, Zt(Be, { $tableSelect: P }, Re));
    }, I = (De) => {
      n("update:modelValue", De);
    }, B = {
      dispatchEvent: M
    }, H = {}, ce = (De) => {
      const Re = Z.value, Be = De[Re];
      return Be ? encodeURIComponent(Be) : "";
    }, A = (De) => {
      const { fullRowMaps: Re } = h, Be = [];
      return (r.eqNull(De) ? [] : r.isArray(De) ? De : [De]).forEach((Ne) => {
        const q = Re[Ne];
        q && Be.push(q.item);
      }), Be;
    }, j = (De) => {
      const { multiple: Re } = e;
      me(() => {
        const Be = x.value;
        if (Be) {
          const ve = A(De);
          ve.length && (Re ? Be.setCheckboxRow(ve, !0) : Be.setRadioRow(ve[0]));
        }
      });
    }, fe = (De) => {
      const { multiple: Re } = e, Be = [];
      Re ? Be.push({
        type: "checkbox",
        width: 70
      }) : Be.push({
        type: "radio",
        width: 70
      }), h.tableColumns = Be.concat(De || []);
    }, pe = () => {
      const { options: De } = e, Re = Z.value, Be = ue.value, ve = K.value, { treeConfig: Ne } = ve, q = {}, z = {};
      Ne || r.arrayEach(De || [], (R, le, F) => {
        let re = ce(R);
        re || (re = S1()), z[re] && Ao("vxe.error.repeatKey", [Re, re]), z[re] = !0;
        const N = R[Be];
        q[N] && Ao("vxe.error.repeatKey", [Be, N]), q[N] = { item: R, index: le, items: F, parent: null, nodes: [] };
      }), h.fullOptionList = De || [], h.fullRowMaps = q, j(e.modelValue);
    }, ne = () => {
      h.panelIndex < ws() && (h.panelIndex = ds());
    }, $ = () => me().then(() => {
      const { placement: De } = e, { panelIndex: Re } = h, Be = w.value, ve = S.value, Ne = C.value;
      if (ve && Be) {
        const q = Be.offsetHeight, z = Be.offsetWidth, R = ve.offsetHeight, le = ve.offsetWidth, F = 5, re = {
          zIndex: Re
        }, { boundingTop: N, boundingLeft: ee, visibleHeight: be, visibleWidth: we } = br(Be);
        let Te = "bottom";
        if (Ne) {
          let ze = ee, st = N + q;
          De === "top" ? (Te = "top", st = N - R) : De || (st + R + F > be && (Te = "top", st = N - R), st < F && (Te = "bottom", st = N + q)), ze + le + F > we && (ze -= ze + le + F - we), ze < F && (ze = F), Object.assign(re, {
            left: `${ze}px`,
            top: `${st}px`,
            minWidth: `${z}px`
          });
        } else
          De === "top" ? (Te = "top", re.bottom = `${q}px`) : De || N + q + R > be && N - q - R > F && (Te = "top", re.bottom = `${q}px`);
        return h.panelStyle = re, h.panelPlacement = Te, me();
      }
    }), J = () => {
      const { loading: De } = e, Re = E.value;
      !De && !Re && (O.vpTimeout && clearTimeout(O.vpTimeout), O.hpTimeout && clearTimeout(O.hpTimeout), h.initialized || (h.initialized = !0), h.isActivated = !0, h.isAniVisible = !0, O.vpTimeout = setTimeout(() => {
        h.visiblePanel = !0, j(e.modelValue), O.vpTimeout = void 0;
      }, 10), ne(), $());
    }, ge = () => {
      h.visiblePanel = !1, O.vpTimeout && clearTimeout(O.vpTimeout), O.hpTimeout && clearTimeout(O.hpTimeout), O.hpTimeout = window.setTimeout(() => {
        h.isAniVisible = !1, O.hpTimeout = void 0;
      }, 350);
    }, Oe = (De, Re) => {
      const { fullRowMaps: Be } = h;
      if (I(Re), Re !== e.modelValue) {
        const ve = Be[Re];
        M("change", { value: Re, row: ve ? ve.item : null }, De), m && u && m.triggerItemEvent(De, u.itemConfig.field, Re);
      }
    }, Se = (De, Re) => {
      Oe(De, Re), M("clear", { value: Re }, De);
    }, de = (De, Re) => {
      Se(Re, null), ge();
    }, Ie = (De) => {
      const { visiblePanel: Re } = h;
      if (!E.value && Re) {
        const ve = S.value;
        jn(De, ve).flag ? $() : ge();
      }
    }, je = (De) => {
      const { visiblePanel: Re } = h;
      if (!E.value) {
        const ve = w.value, Ne = S.value;
        h.isActivated = jn(De, ve).flag || jn(De, Ne).flag, Re && !h.isActivated && ge();
      }
    }, Ue = () => {
      ge();
    }, Ae = (De) => {
      E.value || h.visiblePanel || (h.triggerFocusPanel = !0, J(), setTimeout(() => {
        h.triggerFocusPanel = !1;
      }, 150)), M("focus", {}, De);
    }, _e = (De) => {
      vt(De), M("click", {}, De);
    }, it = (De) => {
      h.isActivated = !1, M("blur", {}, De);
    }, vt = (De) => {
      const { $event: Re } = De;
      Re.preventDefault(), h.triggerFocusPanel ? h.triggerFocusPanel = !1 : h.visiblePanel ? ge() : J();
    }, dt = (De) => {
      const { $event: Re, row: Be } = De, ve = ue.value, Ne = Be[ve];
      Oe(Re, Ne), ge();
    }, at = (De) => {
      const { $grid: Re, $event: Be } = De, ve = ue.value, q = Re.getCheckboxRecords().map((z) => z[ve]);
      Oe(Be, q);
    }, Et = (De) => {
      at(De);
    };
    Object.assign(P, B, H);
    const Qe = () => {
      const { className: De, options: Re, loading: Be } = e, { initialized: ve, isActivated: Ne, isAniVisible: q, visiblePanel: z, tableColumns: R } = h, le = p.value, F = E.value, re = L.value, N = C.value, ee = b.value, be = Y.value, { className: we } = be, Te = K.value, ze = Q.value, st = ye.value, ct = s.header, Ke = s.footer, wt = s.prefix;
      return ee ? o("div", {
        ref: w,
        class: ["vxe-table-select--readonly", De]
      }, [
        o("span", {
          class: "vxe-table-select-label"
        }, re)
      ]) : o("div", {
        ref: w,
        class: ["vxe-table-select", De ? r.isFunction(De) ? De({ $tableSelect: P }) : De : "", {
          [`size--${le}`]: le,
          "is--visible": z,
          "is--disabled": F,
          "is--loading": Be,
          "is--active": Ne
        }]
      }, [
        o(Wn, {
          ref: v,
          clearable: e.clearable,
          placeholder: Be ? Pe("vxe.select.loadingText") : e.placeholder,
          readonly: !0,
          disabled: F,
          type: "text",
          prefixIcon: e.prefixIcon,
          suffixIcon: Be ? ht().TABLE_SELECT_LOADED : z ? ht().TABLE_SELECT_OPEN : ht().TABLE_SELECT_CLOSE,
          modelValue: Be ? "" : re,
          onClear: de,
          onClick: _e,
          onFocus: Ae,
          onBlur: it,
          onSuffixClick: vt
        }, wt ? {
          prefix: () => wt({})
        } : {}),
        o(ks, {
          to: "body",
          disabled: N ? !ve : !0
        }, [
          o("div", {
            ref: S,
            class: ["vxe-table--ignore-clear vxe-table-select--panel", we ? r.isFunction(we) ? we({ $tableSelect: P }) : we : "", {
              [`size--${le}`]: le,
              "is--transfer": N,
              "ani--leave": !Be && q,
              "ani--enter": !Be && z
            }],
            placement: h.panelPlacement,
            style: h.panelStyle
          }, ve ? [
            o("div", {
              class: "vxe-table-select--panel-wrapper"
            }, [
              ct ? o("div", {
                class: "vxe-table-select--panel-header"
              }, ct({})) : Yn(),
              o("div", {
                class: "vxe-table-select--panel-body"
              }, [
                o("div", {
                  ref: D,
                  class: "vxe-table-select-grid--wrapper",
                  style: st
                }, [
                  i ? o(i, Object.assign(Object.assign({}, Te), { class: "vxe-table-select--grid", ref: x, rowConfig: ze, data: Re, columns: R, height: "100%", autoResize: !0, onRadioChange: dt, onCheckboxChange: at, onCheckboxAll: Et }), Object.assign({}, s, {
                    header: void 0,
                    footer: void 0,
                    prefixSlot: void 0
                  })) : Yn()
                ])
              ]),
              Ke ? o("div", {
                class: "vxe-table-select--panel-footer"
              }, Ke({})) : Yn()
            ])
          ] : [])
        ])
      ]);
    };
    return lt(() => e.options, () => {
      pe();
    }), lt(() => e.columns, (De) => {
      fe(De || []);
    }), lt(() => e.modelValue, (De) => {
      j(De);
    }), fe(e.columns || []), pe(), wn(() => {
      ut.on(P, "mousewheel", Ie), ut.on(P, "mousedown", je), ut.on(P, "blur", Ue);
    }), $n(() => {
      ut.off(P, "mousewheel"), ut.off(P, "mousedown"), ut.off(P, "blur");
    }), process.env.NODE_ENV === "development" && me(() => {
      i || Ao("vxe.error.reqComp", ["vxe-grid"]);
    }), bn("$xeTableSelect", P), P.renderVN = Qe, P;
  },
  render() {
    return this.renderVN();
  }
}), D1 = Object.assign({}, Cc, {
  install(e) {
    e.component(Cc.name, Cc);
  }
});
Ht.use(D1);
Ce.component(Cc);
const O1 = Object.assign({}, ol, {
  install(e) {
    e.component(ol.name, ol);
  }
});
Ht.use(O1);
Ce.component(ol);
const wc = pt({
  name: "VxeTag",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    content: [String, Number],
    size: {
      type: String,
      default: () => oe().tag.size || oe().size
    }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { slots: n, emit: s } = t, i = r.uniqueId(), { computeSize: l } = dn(e), a = ke(), c = Rt({}), m = {
      refElem: a
    }, u = {}, d = {
      xID: i,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => u
    }, p = (h, O, g) => {
      s(h, Zt(g, { $tag: d }, O));
    }, w = {
      dispatchEvent: p
    }, v = {}, D = (h) => {
      p("click", {}, h);
    };
    Object.assign(d, w, v);
    const S = () => {
      const { icon: h, content: O } = e, g = n.default, b = n.icon;
      return [
        b || h ? o("span", {
          class: "vxe-tag--icon"
        }, b ? Nt(b({})) : [
          o("i", {
            class: h
          })
        ]) : Ve(),
        o("span", {
          class: "vxe-tag--content"
        }, g ? g({}) : r.toValueString(O))
      ];
    }, x = () => {
      const { status: h, title: O } = e, g = l.value;
      return o("span", {
        ref: a,
        class: ["vxe-tag", {
          [`size--${g}`]: g,
          [`theme--${h}`]: h
        }],
        title: O,
        onClick: D
      }, S());
    };
    return d.renderVN = x, d;
  },
  render() {
    return this.renderVN();
  }
}), T1 = Object.assign({}, wc, {
  install(e) {
    e.component(wc.name, wc);
  }
});
Ht.use(T1);
Ce.component(wc);
const Ec = pt({
  name: "VxeTextEllipsis",
  props: {
    content: [String, Number],
    lineClamp: [String, Number],
    status: String,
    title: [String, Number],
    loading: Boolean,
    offsetLength: [String, Number],
    size: {
      type: String,
      default: () => oe().textEllipsis.size || oe().size
    }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), { computeSize: i } = dn(e), l = ke(), a = ke(), c = Rt({
      resizeObserver: null,
      visibleLen: 0
    }), m = {
      refElem: l
    }, u = _(() => r.toNumber(e.lineClamp)), d = _(() => r.toValueString(e.content)), p = _(() => e.offsetLength ? r.toNumber(e.offsetLength) : 0), w = _(() => {
      const { visibleLen: V } = c, Q = u.value, Z = d.value, G = p.value;
      return Q > 1 && Z.length > V ? `${Z.slice(0, Math.max(1, V - 3 + G))}...` : Z;
    }), v = {}, D = {
      xID: s,
      props: e,
      context: t,
      reactData: c,
      getRefMaps: () => m,
      getComputeMaps: () => v
    }, S = (V, Q, Z) => {
      n(V, Zt(Z, { $textEllipsis: D }, Q));
    }, x = (V) => {
      const Q = l.value, Z = a.value;
      if (Q && Z) {
        let G = 12;
        try {
          G = Math.max(10, r.toNumber(getComputedStyle(Z).fontSize));
        } catch {
        }
        const ue = d.value;
        let Y = Math.floor(V / G), K = ue.slice(0, Y);
        Z.textContent = K, c.visibleLen = K.length;
        let L = 0;
        for (; V > Z.clientWidth && L < 30; ) {
          L++;
          const ye = Math.floor((V - Z.clientWidth) / G);
          if (ye)
            Y += ye, K = ue.slice(0, Y), Z.textContent = K, c.visibleLen = K.length;
          else
            break;
        }
        Z.textContent = "", Z.style.display = "", Z.style.position = "", Z.style.top = "", Z.style.left = "";
      }
    }, h = () => {
      const V = l.value, Q = a.value, Z = d.value, G = u.value;
      if (V && Q) {
        const ue = V.clientWidth;
        Q.style.display = "block", Q.style.position = "absolute", Q.style.top = "-3000px", Q.style.left = "-3000px", Q.textContent = Z;
        const Y = Q.offsetWidth, K = Math.floor(ue * G);
        K > Y ? c.visibleLen = Z.length : x(K);
      } else
        c.visibleLen = Z.length;
    }, O = {
      dispatchEvent: S
    }, g = () => {
      n("click", {});
    }, b = () => {
      const { resizeObserver: V } = c, Q = u.value;
      if (!V) {
        const Z = l.value;
        if (Z && Q > 1 && window.ResizeObserver) {
          const G = new window.ResizeObserver(r.throttle(() => {
            h();
          }, 300, { leading: !0, trailing: !0 }));
          G.observe(Z), c.resizeObserver = G;
        }
      }
    };
    Object.assign(D, O, {});
    const C = () => {
      const { loading: V, status: Q, title: Z } = e, G = i.value, ue = w.value, Y = u.value;
      return o("div", {
        ref: l,
        class: ["vxe-text-ellipsis", Y > 1 ? "is--multi" : "is--single", {
          [`size--${G}`]: G,
          [`theme--${Q}`]: Q,
          "is--loading": V
        }],
        title: Z,
        onClick: g
      }, [
        o("span", {
          ref: a,
          class: "vxe-text-ellipsis-reality"
        }),
        o("span", {
          class: "vxe-text-ellipsis-content"
        }, ue)
      ]);
    };
    return lt(() => e.content, () => {
      h();
    }), lt(() => e.lineClamp, () => {
      b(), h();
    }), wn(() => {
      b(), h();
    }), Us(() => {
      const { resizeObserver: V } = c, Q = l.value, Z = a.value;
      Z && (Z.textContent = ""), V && (Q && V.unobserve(Q), V.disconnect(), c.resizeObserver = null);
    }), D.renderVN = C, D;
  },
  render() {
    return this.renderVN();
  }
}), M1 = Object.assign({}, Ec, {
  install(e) {
    e.component(Ec.name, Ec);
  }
});
Ht.use(M1);
Ce.component(Ec);
const I1 = Object.assign({}, Ps, {
  install(e) {
    e.component(Ps.name, Ps);
  }
});
Ht.use(I1);
Ce.component(Ps);
const V1 = Object.assign(Wl, {
  install: function(e) {
    e.component(Wl.name, Wl);
  }
});
Ht.use(V1);
Ce.component(Wl);
const P1 = Object.assign({}, Vl, {
  install(e) {
    e.component(Vl.name, Vl), e.component("VxeTipsComponent", Vl);
  }
});
Ht.use(P1);
Ce.component(Vl);
const sb = Object.assign({}, Rr, {
  install(e) {
    e.component(Rr.name, Rr);
  }
});
Ht.use(sb);
Ce.component(Rr);
const k1 = Object.assign({}, Pi, {
  install(e) {
    e.component(Pi.name, Pi);
  }
});
Ht.use(k1);
Ce.component(Pi);
const $1 = Object.assign({}, ki, {
  install(e) {
    e.component(ki.name, ki);
  }
});
Ht.use($1);
Ce.component(ki);
const rb = Object.assign({}, Hl, {
  install(e) {
    e.component(Hl.name, Hl);
  }
});
Ht.use(rb);
Ce.component(Hl);
Ce.saveFile = cA;
Ce.readFile = zv;
let Dl = null, ar = null;
const ju = {};
function R1() {
  return Dl || (Dl = document.createElement("canvas"), Dl.style.position = "absolute", Dl.style.top = "0", Dl.style.left = "0"), Dl;
}
function qu(e) {
  if (e) {
    const t = e.parentNode;
    t && t.removeChild(e);
  }
}
function N1(e, t) {
  const n = `${t}_${e}`;
  if (!ju[n]) {
    ar || (ar = document.createElement("span")), ar.parentNode || document.body.append(ar), ar.textContent = e, ar.style.fontSize = cn(t);
    const s = ar.offsetWidth, i = ar.offsetHeight;
    ju[n] = {
      width: s,
      height: i
    };
  }
  return ju[n];
}
function F1(e) {
  let t = 0, n = 0;
  return e.forEach((s) => {
    t = Math.max(s.width, t), n = Math.max(s.height, n);
  }), {
    contentWidth: t,
    contentHeight: n
  };
}
function L1(e, t) {
  const { gap: n } = t, [s = 0, i = 0] = n ? r.isArray(n) ? n : [n, n] : [], l = e + r.toNumber(s), a = e + r.toNumber(i);
  return {
    canvasWidth: l,
    canvasHeight: a
  };
}
function Pl(e, t, n) {
  return (e.font ? e.font[t] : "") || (n.font ? n.font[t] : "");
}
function Uu(e, t, n) {
  const { offset: s } = n, i = r.toValueString(e.textContent), l = r.toNumber(Pl(e, "fontSize", n) || t) || 14, [a = 0, c = 0] = s ? r.isArray(s) ? s : [s, s] : [], { width: m, height: u } = N1(i, l);
  return {
    text: i,
    fontSize: l,
    font: e.font,
    width: m + r.toNumber(a),
    height: u + r.toNumber(c)
  };
}
function A1(e, t, n) {
  const s = Pl(t, "fontWeight", n);
  e.fillStyle = `${Pl(t, "color", n) || "rgba(0, 0, 0, 0.15)"}`, e.font = [
    Pl(t, "fontStyle", n) || "normal",
    s === "bold" || s === "bolder" ? "bold" : "",
    cn(t.fontSize),
    Pl(t, "fontFamily", n) || "sans-serif"
  ].join(" ");
}
function B1(e, t, n) {
  const s = Object.assign({}, n), { rotate: i } = s, l = r.toNumber(i), a = (r.isArray(e) ? e : [e]).map((c) => c ? c.textContent ? Uu(c, t, s) : Uu({
    textContent: `${c}`
  }, t, s) : Uu({
    textContent: ""
  }, t, s));
  return qu(ar), new Promise((c) => {
    const m = R1();
    m.parentNode || document.body.append(m);
    const u = m.getContext("2d");
    if (u && a.length) {
      const { contentWidth: d, contentHeight: p } = F1(a), { canvasWidth: w, canvasHeight: v } = L1(d, s);
      m.width = w, m.height = v;
      const D = (w - d) / 2, S = (v - p) / 2, x = D + d / 2, h = S + p / 2;
      u.save(), u.translate(x, h), u.rotate(l * Math.PI / 180), u.translate(-x, -h);
      let O = 0;
      a.forEach((g) => {
        const b = Pl(g, "align", s);
        A1(u, g, s), u.fillText(g.text, D + (b === "center" ? (d - g.width) / 2 : 0), S + (p + p) / 2 + O, d), O += g.height;
      }), u.restore(), c(m.toDataURL()), qu(m);
    } else
      c(""), qu(m);
  });
}
const Sc = pt({
  name: "VxeWatermark",
  props: {
    width: String,
    height: String,
    imageUrl: String,
    rotate: {
      type: [Number, String],
      default: () => oe().watermark.rotate
    },
    gap: {
      type: [Array, Number, String],
      default: () => r.clone(oe().watermark.gap, !0)
    },
    content: [String, Array],
    font: Object,
    offset: Object,
    zIndex: [String, Number]
  },
  emits: [],
  setup(e, t) {
    const { emit: n } = t, s = r.uniqueId(), i = ke(), l = Rt({
      markUrl: ""
    }), a = {
      refElem: i
    }, c = _(() => r.assign({}, r.clone(oe().watermark.font, !0), e.font)), m = _(() => {
      const { width: x, height: h, zIndex: O } = e, { markUrl: g } = l, b = {};
      return x && (b.width = cn(x)), h && (b.height = cn(h)), g && (b.backgroundImage = `url(${g})`), O && (b.zIndex = O), b;
    }), u = {}, d = {
      xID: s,
      props: e,
      context: t,
      reactData: l,
      getRefMaps: () => a,
      getComputeMaps: () => u
    }, w = {
      dispatchEvent: (x, h, O) => {
        n(x, Zt(O, { $watermark: d }, h));
      }
    }, v = () => {
      const { content: x, gap: h, rotate: O, offset: g } = e, b = i.value, E = c.value;
      b && x && B1(x, getComputedStyle(b).fontSize, {
        font: E,
        rotate: O,
        gap: h,
        offset: g
      }).then((C) => {
        l.markUrl = C;
      });
    };
    Object.assign(d, w, {});
    const S = () => {
      const x = m.value;
      return o("div", {
        ref: i,
        class: "vxe-watermark",
        style: x
      });
    };
    return lt(() => e.imageUrl, () => {
      v();
    }), lt(() => e.content, () => {
      v();
    }), lt(() => e.gap, () => {
      v();
    }), lt(() => e.rotate, () => {
      v();
    }), lt(() => e.width, () => {
      v();
    }), lt(() => e.height, () => {
      v();
    }), lt(() => e.font, () => {
      v();
    }), wn(() => {
      v(), ut.on(d, "resize", r.throttle(() => {
        v();
      }, 300, { trailing: !0, leading: !0 }));
    }), $n(() => {
      ut.off(d, "resize");
    }), d.renderVN = S, d;
  },
  render() {
    return this.renderVN();
  }
}), _1 = Object.assign({}, Sc, {
  install(e) {
    e.component(Sc.name, Sc);
  }
});
Ht.use(_1);
Ce.component(Sc);
const W1 = {
  load(e) {
    return Yc(), Vs.globalWatermark = Object.assign({}, e), Promise.resolve();
  },
  clear() {
    return Vs.globalWatermark = null, Promise.resolve();
  }
};
Ce.watermark = W1;
const lb = "zh-CN";
Oh(lb, ZF);
Dh(lb);
Hc("light");
var kd = {};
Object.defineProperty(kd, "__esModule", {
  value: !0
});
var ib = kd.default = void 0;
ib = kd.default = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择",
      comma: "，",
      fullStop: "。"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      downErr: "下载失败",
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入",
      treeCrossDrag: "只能拖拽第一层级的数据",
      treeDragChild: "父级数据不能拖拽到自己的子级中",
      reqPlugin: '可选扩展插件 "{1}" https://vxeui.com/other{0}/#/{1}/install'
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "序号",
      actionTitle: "操作",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expError: "导出失败",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customClose: "关闭",
      customCancel: "取消",
      customRestore: "恢复默认",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个",
      dragTip: "移动：{0}"
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      gotoTitle: "页数",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整列的排序",
        colTitle: "标题",
        colResizable: "列宽（像素）",
        colVisible: "是否显示",
        colFixed: "冻结列",
        colFixedMax: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖方式（直接覆盖表格数据）",
        insert: "底部追加（在表格的底部追加新数据）",
        insertTop: "顶部追加（在表格的顶部追加新数据）",
        insertBottom: "底部追加（在表格的底部追加新数据）"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impMode: "导入模式",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开层级",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      errTitle: "错误提示",
      zoomMin: "最小化",
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭",
      miniMaxSize: "最小化窗口的数量不能超过 {0} 个",
      footPropErr: "show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用"
    },
    drawer: {
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelFixed: "取消冻结列"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "周",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    imagePreview: {
      popupTitle: "预览",
      operBtn: {
        zoomOut: "缩小",
        zoomIn: "放大",
        pctFull: "等比例缩放",
        pct11: "显示原始尺寸",
        rotateLeft: "向左旋转",
        rotateRight: "向右旋转",
        print: "点击打印图片",
        download: "点击下载图片"
      }
    },
    upload: {
      fileBtnText: "点击或拖拽上传",
      imgBtnText: "点击或拖拽上传",
      dragPlaceholder: "请把文件拖放到这个区域即可上传",
      imgSizeHint: "单张{0}",
      imgCountHint: "最多{0}张",
      fileTypeHint: "支持 {0} 文件类型",
      fileSizeHint: "单个文件大小不超过{0}",
      fileCountHint: "最多可上传{0}个文件",
      uploadTypeErr: "文件类型不匹配！",
      overCountErr: "最多只能选择{0}个文件！",
      overCountExtraErr: "已超出最大数量{0}个，超出的{1}个文件将被忽略！",
      overSizeErr: "文件大小最大不能超过{0}！",
      reUpload: "重新上传",
      uploadProgress: "上传中 {0}%",
      uploadErr: "上传失败",
      uploadSuccess: "上传成功",
      moreBtnText: "更多（{0}）",
      viewItemTitle: "点击查看",
      morePopup: {
        readTitle: "查看列表",
        imageTitle: "上传图片",
        fileTitle: "上传文件"
      }
    },
    empty: {
      defText: "暂无数据"
    },
    formDesign: {
      formName: "表单名称",
      defFormTitle: "未命名的表单",
      widgetPropTab: "控件属性",
      widgetFormTab: "表单属性",
      error: {
        wdFormUni: "该类型的控件在表单中只允许添加一个",
        wdSubUni: "该类型的控件在子表中只允许添加一个"
      },
      styleSetting: {
        btn: "样式设置",
        title: "表单的样式设置",
        layoutTitle: "控件布局",
        verticalLayout: "上下布局",
        horizontalLayout: "横向布局",
        styleTitle: "标题样式",
        boldTitle: "标题加粗",
        fontBold: "加粗",
        fontNormal: "常规",
        colonTitle: "显示冒号",
        colonVisible: "显示",
        colonHidden: "隐藏",
        alignTitle: "对齐方式",
        widthTitle: "标题宽度",
        alignLeft: "居左",
        alignRight: "居右",
        unitPx: "像素",
        unitPct: "百分比"
      },
      widget: {
        group: {
          base: "基础控件",
          layout: "布局控件",
          system: "系统控件",
          module: "模块控件",
          chart: "图表控件",
          advanced: "高级控件"
        },
        copyTitle: "副本_{0}",
        component: {
          input: "输入框",
          textarea: "文本域",
          select: "下拉选择",
          row: "一行多列",
          title: "标题",
          text: "文本",
          subtable: "子表",
          VxeSwitch: "是/否",
          VxeInput: "输入框",
          VxeNumberInput: "数字",
          VxeDatePicker: "日期",
          VxeTextarea: "文本域",
          VxeSelect: "下拉选择",
          VxeTreeSelect: "树形选择",
          VxeRadioGroup: "单选框",
          VxeCheckboxGroup: "复选框",
          VxeUploadFile: "文件",
          VxeUploadImage: "图片",
          VxeRate: "评分",
          VxeSlider: "滑块"
        }
      },
      widgetProp: {
        name: "控件名称",
        placeholder: "提示语",
        required: "必填校验",
        multiple: "允许多选",
        displaySetting: {
          name: "显示设置",
          pc: "电脑端",
          mobile: "手机端",
          visible: "显示",
          hidden: "隐藏"
        },
        dataSource: {
          name: "数据源",
          defValue: "选项{0}",
          addOption: "添加选项",
          batchEditOption: "批量编辑",
          batchEditTip: "每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。",
          batchEditSubTip: "每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。",
          buildOption: "生成选项"
        },
        rowProp: {
          colSize: "列数",
          col2: "两列",
          col3: "三列",
          col4: "四列",
          col6: "六列",
          layout: "布局"
        },
        textProp: {
          name: "内容",
          alignTitle: "对齐方式",
          alignLeft: "居左",
          alignCenter: "居中",
          alignRight: "居右",
          colorTitle: "字体颜色",
          sizeTitle: "字体大小",
          boldTitle: "字体加粗",
          fontNormal: "常规",
          fontBold: "加粗"
        },
        subtableProp: {
          seqTitle: "序号",
          showSeq: "显示序号",
          showCheckbox: "允许多选",
          errSubDrag: "子表不支持该控件，请使用其他控件",
          colPlace: "将控件拖拽进来"
        },
        uploadProp: {
          limitFileCount: "文件数量限制",
          limitFileSize: "文件大小限制",
          multiFile: "允许上传多个文件",
          limitImgCount: "图片数量限制",
          limitImgSize: "图片大小限制",
          multiImg: "允许上传多张图片"
        }
      }
    },
    listDesign: {
      fieldSettingTab: "字段设置",
      listSettingTab: "参数设置",
      searchTitle: "查询条件",
      listTitle: "列表字段",
      searchField: "查询字段",
      listField: "列表字段",
      activeBtn: {
        ActionButtonUpdate: "编辑",
        ActionButtonDelete: "删除"
      },
      search: {
        addBtn: "编辑",
        emptyText: "未配置查询条件",
        editPopupTitle: "编辑查询字段"
      },
      searchPopup: {
        colTitle: "标题",
        saveBtn: "保存"
      }
    },
    text: {
      copySuccess: "已复制到剪贴板",
      copyError: "当前环境不支持该操作"
    },
    countdown: {
      formats: {
        yyyy: "年",
        MM: "月",
        dd: "天",
        HH: "时",
        mm: "分",
        ss: "秒"
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          selectErr: "无法操作指定区域的单元格",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结到左侧",
          fixedRight: "冻结到右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
};
Ce.setI18n("zh-CN", ib);
Ce.setLanguage("zh-CN");
function z1(e) {
  e.use(vv), e.use(bv), e.use(Cv), e.use(Rv), e.use(jv), e.use(qv), e.use(Uv), e.use(Xc), e.use(Kv), e.use(eb), e.use(ob), e.use(sb), e.use(rb);
}
function H1(e) {
  e.use(av), e.use($N), e.use(RN), e.use(uv), e.use(cv);
}
em.install = function(e) {
  z1(e), H1(e), e.component("BGrid", em);
};
export {
  em as BGrid,
  em as default,
  H1 as lazyVxeTable,
  z1 as lazyVxeUI
};
